diff -r 07c0144bc7fd include/private/gc_priv.h
--- a/include/private/gc_priv.h	Fri Jul 26 22:53:18 2013 +0100
+++ b/include/private/gc_priv.h	Tue Aug 20 23:51:18 2013 +0100
@@ -724,6 +724,14 @@
 #   define CPP_LOG_HBLKSIZE 13
 # elif HBLKSIZE == 16384
 #   define CPP_LOG_HBLKSIZE 14
+# elif HBLKSIZE == 32768
+#   define CPP_LOG_HBLKSIZE 15
+# elif HBLKSIZE == 65536
+#   define CPP_LOG_HBLKSIZE 16
+# elif HBLKSIZE == 131072
+#   define CPP_LOG_HBLKSIZE 17
+# elif HBLKSIZE == 262144
+#   define CPP_LOG_HBLKSIZE 18
 # else
     --> fix HBLKSIZE
 # endif
diff -r 07c0144bc7fd include/private/gcconfig.h
--- a/include/private/gcconfig.h	Fri Jul 26 22:53:18 2013 +0100
+++ b/include/private/gcconfig.h	Tue Aug 20 23:51:18 2013 +0100
@@ -25,6 +25,13 @@
 #ifndef GCCONFIG_H
 #define GCCONFIG_H
 
+/* Override system-specific block size so that thread-local allocations
+ * are more efficient.
+ */
+#ifndef HBLKSIZE
+#define HBLKSIZE 8192
+#endif
+
 # ifndef GC_PRIVATE_H
     /* Fake ptr_t declaration, just to avoid compilation errors.        */
     /* This avoids many instances if "ifndef GC_PRIVATE_H" below.       */
diff -r 07c0144bc7fd mark.c
--- a/mark.c	Fri Jul 26 22:53:18 2013 +0100
+++ b/mark.c	Tue Aug 20 23:51:18 2013 +0100
@@ -16,6 +16,10 @@
 
 #include "private/gc_pmark.h"
 
+#ifndef MAX_MARKERS
+# define MAX_MARKERS 16
+#endif
+
 #include <stdio.h>
 
 #if defined(MSWIN32) && defined(__GNUC__)
@@ -1116,13 +1120,15 @@
     }
 }
 
+GC_INNER mse GC_local_mark_stacks[MAX_MARKERS+1][LOCAL_MARK_STACK_SIZE];
+
 /* Perform Parallel mark.                       */
 /* We hold the GC lock, not the mark lock.      */
 /* Currently runs until the mark stack is       */
 /* empty.                                       */
 STATIC void GC_do_parallel_mark(void)
 {
-    mse local_mark_stack[LOCAL_MARK_STACK_SIZE];
+    mse *local_mark_stack = &(GC_local_mark_stacks[0][0]);
                 /* Note: local_mark_stack is quite big (up to 128 KiB). */
 
     GC_acquire_mark_lock();
@@ -1155,13 +1161,12 @@
     GC_notify_all_marker();
 }
 
-
 /* Try to help out the marker, if it's running.         */
 /* We do not hold the GC lock, but the requestor does.  */
 GC_INNER void GC_help_marker(word my_mark_no)
 {
     unsigned my_id;
-    mse local_mark_stack[LOCAL_MARK_STACK_SIZE];
+    mse *local_mark_stack;
                 /* Note: local_mark_stack is quite big (up to 128 KiB). */
 
     if (!GC_parallel) return;
@@ -1172,6 +1177,7 @@
       GC_wait_marker();
     }
     my_id = GC_helper_count;
+    local_mark_stack = &(GC_local_mark_stacks[my_id][0]);
     if (GC_mark_no != my_mark_no || my_id > (unsigned)GC_markers_m1) {
       /* Second test is useful only if original threads can also        */
       /* act as helpers.  Under Linux they can't.                       */
@@ -1242,6 +1248,10 @@
 GC_INNER void GC_mark_init(void)
 {
     alloc_mark_stack(INITIAL_MARK_STACK_SIZE);
+#   ifdef PARALLEL_MARK
+        GC_exclude_static_roots_inner(GC_local_mark_stacks,
+	    (char *)GC_local_mark_stacks + sizeof(GC_local_mark_stacks));
+#   endif
 }
 
 /*
diff -r 07c0144bc7fd os_dep.c
--- a/os_dep.c	Fri Jul 26 22:53:18 2013 +0100
+++ b/os_dep.c	Tue Aug 20 23:51:18 2013 +0100
@@ -740,6 +740,8 @@
         }
       }
 #   endif
+    if (HBLKSIZE > GC_page_size)
+      GC_page_size = HBLKSIZE;
   }
 
 # ifndef CYGWIN32
@@ -799,6 +801,8 @@
 #   if defined(MPROTECT_VDB) || defined(PROC_VDB) || defined(USE_MMAP)
       GC_page_size = GETPAGESIZE();
       if (!GC_page_size) ABORT("getpagesize failed");
+      if (HBLKSIZE > GC_page_size)
+        GC_page_size = HBLKSIZE;
 #   else
       /* It's acceptable to fake it.    */
       GC_page_size = HBLKSIZE;
@@ -2048,12 +2052,24 @@
 #   endif
 
     if (bytes & (GC_page_size - 1)) ABORT("Bad GET_MEM arg");
+    bytes += GC_page_size;
     result = mmap(last_addr, bytes, (PROT_READ | PROT_WRITE)
                                     | (GC_pages_executable ? PROT_EXEC : 0),
                   GC_MMAP_FLAGS | OPT_MAP_ANON, zero_fd, 0/* offset */);
 #   undef IGNORE_PAGES_EXECUTABLE
 
     if (result == MAP_FAILED) return(0);
+
+    if ((word) result & (GC_page_size - 1)) {
+        word delta = (word) result & (GC_page_size - 1);
+	if (delta) delta = GC_page_size - delta;
+        munmap(result, delta);
+        result = (char *) result + delta;
+        munmap((char *) result + bytes, GC_page_size - delta);
+    } else {
+        munmap((char *) result + bytes, GC_page_size);
+    }
+
     last_addr = (ptr_t)result + bytes + GC_page_size - 1;
     last_addr = (ptr_t)((word)last_addr & ~(GC_page_size - 1));
 #   if !defined(LINUX)
