<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  domain.msk                   GAP documentation              Thomas Breuer -->
<!-- %% -->
<!-- %A  @(#)<M>Id: domain.msk,v 1.29 2002/04/15 10:02:28 sal Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Domains and their Elements">
<Heading>Domains and their Elements</Heading>

<#Include Label="[1]{domain}">
<P/>
An introduction to the most important facts about domains is given
in Chapter&nbsp;<Ref Chap="Domains" BookName="tut"/>.
<P/>
There are only few <E>operations</E> especially for domains
(see&nbsp;<Ref Sect="Operations for Domains"/>),
operations such as <Ref Func="Intersection" Label="for a list"/>
and <Ref Func="Random" Label="for a list or collection"/>
are defined for the more
general situation of collections (see Chapter&nbsp;<Ref Chap="Collections"/>).

<!-- %%  The fundamental suport for domains in &GAP; was designed and implemented by -->
<!-- %%  Thomas Breuer. -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operational Structure of Domains">
<Heading>Operational Structure of Domains</Heading>

Domains have an <E>operational structure</E>,
that is, a collection of operations under which the domain is closed.
For example, a group is closed under multiplication,
taking the zeroth power of elements, and taking inverses of elements.
The operational structure may be empty,
examples of domains without additional structure are
the underlying relations of general mappings
(see&nbsp;<Ref Sect="Properties and Attributes of (General) Mappings"/>).
<P/>
The operations under which a domain is closed are a subset of
the operations that the elements of a domain admit.
It is possible that the elements admit more operations.
For example, matrices can be multiplied and added.
But addition plays no role in a group of matrices,
and multiplication plays no role in a vector space of matrices.
In particular, a matrix group is not closed under addition.
<P/>
Note that the elements of a domain exist independently of this domain,
usually they existed already before the domain was created.
So it makes sense to say that a domain is <E>generated</E> by some elements
with respect to certain operations.
<P/>
Of course, different sets of operations yield different notions of
generation.
For example, the group generated by some matrices is different from
the ring generated by these matrices, and these two will in general be
different from the vector space generated by the same matrices,
over a suitable field.
<P/>
The other way round,
the same set of elements may be obtained by generation w.r.t.&nbsp;different
notions of generation.
For example, one can get the group generated by two elements <M>g</M> and <M>h</M>
also as the monoid generated by the elements <M>g</M>, <M>g^{{-1}}</M>,
<M>h</M>, <M>h^{{-1}}</M>;
if both <M>g</M> and <M>h</M> have finite order then of course the group generated
by <M>g</M> and <M>h</M> coincides with the monoid generated by <M>g</M> and <M>h</M>.
<P/>
Additionally to the operational structure,
a domain can have properties.
For example, the multiplication of a group is associative,
and the multiplication in a field is commutative.
<P/>
Note that associativity and commutativity depend on the set of
elements for which one considers the multiplication,
i.e., it depends on the domain.
For example, the multiplication in a full matrix ring over a field
is not commutative, whereas its restriction to the set of diagonal
matrices is commutative.
<P/>
One important difference between the operational structure and the
properties of a domain is that the operational structure is fixed when
the domain is constructed, whereas properties can be discovered later.
For example, take a domain whose operational structure is given by
closure under multiplication.
If it is discovered that the inverses of all its elements
also do (by chance) lie in this domain,
being closed under taking inverses is <E>not</E> added to the operational
structure.
But a domain with operational structure of multiplication,
taking the identity, and taking inverses
will be treated as a group as soon as the multiplication is found out to
be associative for this domain.
<P/>
The operational structures available in &GAP; form a hierarchy,
which is explicitly formulated in terms of domain categories,
see&nbsp;<Ref Sect="Domain Categories"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Equality and Comparison of Domains">
<Heading>Equality and Comparison of Domains</Heading>

<#Include Label="[2]{domain}">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Constructing Domains">
<Heading>Constructing Domains</Heading>

For several operational structures (see&nbsp;<Ref Sect="Operational Structure of Domains"/>),
&GAP; provides functions to construct domains with this structure
(note that such functions do not exist for all operational structures).
For example, <Ref Func="Group" Label="for several generators"/>
returns groups, <Ref Func="VectorSpace"/> returns vector spaces etc.:
<P/>
<Index Key="Struct"><A>Struct</A></Index>
<C><A>Struct</A>( <A>arg1</A>, <A>arg2</A>, ... )</C>
<P/>
The syntax of these functions may vary, dependent on the structure in question.
Usually a domain is constructed as the closure of some elements under the
given operations, that is, the domain is given by its <E>generators</E>.
For example, a group can be constructed from a list of generating
permutations or matrices or whatever is admissible as group elements,
and a vector space over a given field <M>F</M> can be constructed from <M>F</M> and
a list of appropriate vectors.
<P/>
The idea of generation and generators in &GAP; is that the domain
returned by a function such as <C>Group</C>, <C>Algebra</C>, or <C>FreeLeftModule</C>
<E>contains</E> the given generators.
This implies that the generators of a group must know how they are
multiplied and inverted,
the generators of a module must know how they are added and how scalar
multiplication works, and so on.
Thus one cannot use for example permutations as generators of a vector
space.
<P/>
The function <A>Struct</A> first checks whether the arguments admit
the construction of a domain with the desired structure.
This is done by calling the operation
<P/>
<C>IsGeneratorsOf<A>Struct</A>( [<A>info</A>, ]<A>gens</A> )</C>
<P/>
<Index Key="IsGeneratorsOfStruct"><C>IsGeneratorsOf<A>Struct</A></C></Index>
<P/>
where <A>arglist</A> is the list of given generators and <A>info</A> an argument
of <A>Struct</A>, for example the field of scalars in the case that a
vector space shall be constructed.
If the check failed then <A>Struct</A> returns <K>fail</K>,
otherwise it returns the result of <C><A>Struct</A>ByGenerators</C> (see below).
(So if one wants to omit the check then one should call
<C><A>Struct</A>ByGenerators</C> directly.)
<P/>
<Index Key="GeneratorsOfStruct"><C>GeneratorsOf<A>Struct</A></C></Index>
<C>GeneratorsOf<A>Struct</A>( <A>D</A>)</C>
<P/>
For a domain <A>D</A> with operational structure corresponding to <A>Struct</A>,
the attribute <C>GeneratorsOf<A>Struct</A></C> returns a list of corresponding
generators of <A>D</A>.
If these generators were not yet stored in <A>D</A> then <A>D</A> must know <E>some</E>
generators if <C>GeneratorsOf<A>Struct</A></C> shall have a chance to compute the
desired result;
for example, monoid generators of a group can be computed from known
group generators (and vice versa).
Note that several notions of generation may be meaningful for a given
domain, so it makes no sense to ask for <Q>the generators of a domain</Q>.
Further note that the generators may depend on other information about <A>D</A>.
For example the generators of a vector space depend on the underlying field
of scalars; the vector space generators of a vector space over the field
with four elements need not generate the same vector space when this is
viewed as a space over the field with two elements.
<P/>
<Index Key="StructByGenerators"><C><A>Struct</A>ByGenerators</C></Index>
<C><A>Struct</A>ByGenerators( [<A>info</A>, ]<A>gens</A> )</C>
<P/>
Domain construction from generators <A>gens</A> is implemented by operations
<C><A>Struct</A>ByGenerators</C>,
which are called by the simple functions <A>Struct</A>;
methods can be installed only for the operations.
Note that additional information <A>info</A> may be necessary
to construct the domain;
for example, a vector space needs the underlying field of scalars
in addition to the list of vector space generators.
The <C>GeneratorsOf<A>Struct</A></C> value of the returned domain need <E>not</E>
be equal to <A>gens</A>.
But if a domain <A>D</A> is printed as <C><A>Struct</A>([<A>a</A>, <A>b</A>, ...])</C> and if
there is an attribute <C>GeneratorsOf<A>Struct</A></C> then the list
<C>GeneratorsOf<A>Struct</A>( <A>D</A> )</C> is guaranteed to be equal to
<C>[ <A>a</A>, <A>b</A>, ... ]</C>.
<P/>
<Index Key="StructWithGenerators"><C><A>Struct</A>WithGenerators</C></Index>
<C><A>Struct</A>WithGenerators( [<A>info</A>, ]<A>gens</A> )</C>
<P/>
The only difference between <C><A>Struct</A>ByGenerators</C> and
<C><A>Struct</A>WithGenerators</C> is that the latter guarantees that the
<C>GeneratorsOf<A>Struct</A></C> value of the result is equal to the given
generators <A>gens</A>.
<P/>
<Index Key="ClosureStruct"><C>Closure<A>Struct</A></C></Index>
<C>Closure<A>Struct</A>( <A>D</A>, <A>obj</A> )</C>
<P/>
For constructing a domain as the closure of a given domain with an
element or another domain, one can use the operation <C>Closure<A>Struct</A></C>.
It returns the smallest domain with operational structure corresponding to
<A>Struct</A> that contains <A>D</A> as a subset and <A>obj</A> as an element.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Changing the Structure">
<Heading>Changing the Structure</Heading>

The same set of elements can have different operational structures.
For example, it may happen that a monoid <M>M</M> does in fact contain
the inverses of all of its elements;
if <M>M</M> has not been constructed as a group (see&nbsp;<Ref Sect="Domain Categories"/>)
then it is reasonable to ask for the group that is equal to <M>M</M>.
<P/>
<Index Key="AsStruct"><C>As<A>Struct</A></C></Index>
<C>As<A>Struct</A>( [<A>info</A>, ]<A>D</A> )</C>
<P/>
If <A>D</A> is a domain that is closed under the operational structure
given by <A>Struct</A> then <C>As<A>Struct</A></C> returns a domain <A>E</A> that consists
of the same elements (that is, <C><A>D</A> = <A>E</A></C>) and that has this
operational structure (that is, <C>Is<A>Struct</A>( <A>E</A> )</C> is <K>true</K>);
if <A>D</A> is not closed under the structure given by <A>Struct</A> then
<C>As<A>Struct</A></C> returns <K>fail</K>.
<P/>
If additional information besides generators are necessary to define <A>D</A>
then the argument <A>info</A> describes the value of this information for the
desired domain.
For example, if we want to view <A>D</A> as a vector space over the field
with two elements then we may call <C>AsVectorSpace( GF(2), <A>D</A> )</C>;
this allows us to change the underlying field of scalars,
for example if <A>D</A> is a vector space over the field with four elements.
Again, if <A>D</A> is not equal to a domain with the desired structure and
additional information then <K>fail</K> is returned.
<P/>
In the case that no additional information <A>info</A> is related to the
structure given by <A>Struct</A>,
the operation <C>As<A>Struct</A></C> is in fact an attribute (see&nbsp;<Ref Sect="Attributes"/>).
<P/>
See the index of the &GAP; Reference Manual for an overview of the available
<C>As<A>Struct</A></C> functions.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Changing the Representation">
<Heading>Changing the Representation</Heading>

Often it is useful to answer questions about a domain via computations in
a different but isomorphic domain.
In the sense that this approach keeps the structure and changes the
underlying set of elements, it can be viewed as a counterpart of keeping the
set of elements and changing its structure
(see&nbsp;<Ref Sect="Changing the Structure"/>).
<P/>
One reason for doing so can be that computations with the elements in the
given domain are not very efficient.
For example, if one is given a solvable matrix group
(see Chapter&nbsp;<Ref Chap="Matrix Groups"/>)
then one can compute an isomorphism to a
polycyclicly presented group <M>G</M>,
say (see Chapter&nbsp;<Ref Chap="Polycyclic Groups"/>);
the multiplication of two matrices &ndash;which is essentially determined by
the dimension of the matrices&ndash; is much more expensive than the
multiplication of two elements in <M>G</M>
&ndash;which is essentially determined by the composition length of <M>G</M>.
<P/>
<Index Key="IsomorphismRepStruct"><C>Isomorphism<A>Rep</A><A>Struct</A></C></Index>
<C>Isomorphism<A>Rep</A><A>Struct</A>( <A>D</A> )</C>
<P/>
If <A>D</A> is a domain that is closed under the operational structure
given by <A>Struct</A> then <C>Isomorphism<A>Rep</A><A>Struct</A></C> returns
a mapping <A>hom</A>
from <A>D</A> to a domain <M>E</M> having structure given by <A>Struct</A>,
such that <A>hom</A> respects the structure <A>Struct</A>
and <A>Rep</A> describes the representation of the elements in <M>E</M>.
If no domain <M>E</M> with the required properties exists then <K>fail</K> is
returned.
<P/>
For example, <Ref Func="IsomorphismPermGroup"/> takes a
group as its argument and returns a group homomorphism
(see&nbsp;<Ref Chap="Group Homomorphisms"/>) onto an isomorphic permutation group
(see Chapter&nbsp;<Ref Chap="Permutation Groups"/>) provided the original
group is finite;
for infinite groups, <Ref Func="IsomorphismPermGroup"/> returns <K>fail</K>.
Similarly, <Ref Func="IsomorphismPcGroup"/> returns a group
homomorphism from its argument to a polycyclicly presented group
(see&nbsp;<Ref Chap="Pc Groups"/>) if the argument is polycyclic,
and <K>fail</K> otherwise.
<P/>
See the index of the &GAP; Reference Manual for an overview of the available
<C>Isomorphism<A>Rep</A><A>Struct</A></C> functions.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Domain Categories">
<Heading>Domain Categories</Heading>

As mentioned in&nbsp;<Ref Sect="Operational Structure of Domains"/>,
the operational structure of a domain is fixed when the domain is
constructed.
For example, if <A>D</A> was constructed by
<Ref Func="Monoid" Label="for various generators"/>
then <A>D</A> is in general not regarded as a group in &GAP;,
even if <A>D</A> is in fact closed under taking inverses.
In this case, <Ref Func="IsGroup"/> returns <K>false</K> for <A>D</A>.
The operational structure determines which operations are applicable for
a domain, so for example <Ref Func="SylowSubgroup"/> is not defined for
<A>D</A> and therefore will signal an error.
<P/>
<Index Key="IsStruct"><C>Is<A>Struct</A></C></Index>
<C>Is<A>Struct</A>( <A>D</A> )</C>
<P/>
The functions <C>Is<A>Struct</A></C> implement the tests whether a domain
<A>D</A> has the respective operational structure (upon construction).
<C>Is<A>Struct</A></C> is a filter (see&nbsp;<Ref Chap="Types of Objects"/>)
that involves certain categories (see&nbsp;<Ref Sect="Categories"/>)
and usually also certain properties (see&nbsp;<Ref Sect="Properties"/>).
For example, <Ref Func="IsGroup"/> is equivalent to
<C>IsMagmaWithInverses and IsAssociative</C>,
the first being a category and the second being a property.
<P/>
Implications between domain categories describe the hierarchy of
operational structures available in &GAP;.
Here are some typical examples.
<P/>
<List>
<Item>
    <Ref Func="IsDomain"/> is implied by each domain category,
</Item>
<Item>
    <Ref Func="IsMagma"/> is implied by each category that describes the
    closure under multiplication <C>*</C>,
</Item>
<Item>
    <Ref Func="IsAdditiveMagma"/> is implied by each category that describes
    the closure under addition <C>+</C>,
</Item>
<Item>
    <Ref Func="IsMagmaWithOne"/> implies <Ref Func="IsMagma"/>;
    a <E>magma-with-one</E> is a magma such that each element
    (and thus also the magma itself) can be asked for its zeroth power,
</Item>
<Item>
    <Ref Func="IsMagmaWithInverses"/> implies <Ref Func="IsMagmaWithOne"/>;
    a <E>magma-with-inverses</E> is a magma such that each element
    can be asked for its inverse;
    important special cases are <E>groups</E>,
    which in addition are associative,
</Item>
<Item>
    a <E>ring</E> is a magma that is also an additive group,
</Item>
<Item>
    a <E>ring-with-one</E> is a ring that is also a magma-with-one,
</Item>
<Item>
    a <E>division ring</E> is a ring-with-one that is also closed under taking
    inverses of nonzero elements,
</Item>
<Item>
    a <E>field</E> is a commutative division ring.
</Item>
</List>
<P/>
Each operational structure <A>Struct</A> has associated with it 
a domain category <C>Is<A>Struct</A></C>,
and operations <C><A>Struct</A>ByGenerators</C> for constructing a domain
from generators,
<C>GeneratorsOf<A>Struct</A></C> for storing and accessing generators
w.r.t.&nbsp;this structure,
<C>Closure<A>Struct</A></C> for forming the closure,
and <C>As<A>Struct</A></C> for getting a domain with the desired structure
from one with weaker operational structure and for testing whether a given
domain can be regarded as a domain with <A>Struct</A>.
<P/>
The functions applicable to domains with the various structures
are described in the corresponding chapters of the Reference Manual.
For example, functions for rings, fields, groups, and vector spaces
are described in Chapters&nbsp;<Ref Chap="Rings"/>,
<Ref Chap="Fields and Division Rings"/>,
<Ref Chap="Groups"/>, and <Ref Chap="Vector Spaces"/>, respectively.
More general functions for arbitrary collections can be found in
Chapter&nbsp;<Ref Chap="Collections"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Parents">
<Heading>Parents</Heading>

<#Include Label="Parent">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Constructing Subdomains">
<Heading>Constructing Subdomains</Heading>

<Index>Subdomains</Index>
For many domains <A>D</A>, there are functions that construct certain subsets <A>S</A>
of <A>D</A> as domains with parent (see&nbsp;<Ref Sect="Parents"/>) already set to <A>D</A>.
For example, if <A>G</A> is a group that contains the elements in the list <A>gens</A>
then <C>Subgroup( <A>G</A>, <A>gens</A> )</C> returns a group <A>S</A> that is generated by the
elements in <A>gens</A> and with <C>Parent( <A>S</A> ) = <A>G</A></C>.
<P/>
<Index Key="Substruct"><C>Sub<A>struct</A></C></Index>
<C>Sub<A>struct</A>( <A>D</A>, <A>gens</A> )</C>
<P/>
More general, if <A>D</A> is a domain whose algebraic structure is given by the
function <A>Struct</A> (for example <C>Group</C>, <C>Algebra</C>, <C>Field</C>)
then the function <C>Sub<A>struct</A></C> (for example <C>Subgroup</C>, <C>Subalgebra</C>,
<C>Subfield</C>) returns domains with structure <A>Struct</A> and parent set to
the first argument.
<P/>
<Index Key="SubstructNC"><C>Sub<A>struct</A>NC</C></Index>
<C>Sub<A>struct</A>NC( <A>D</A>, <A>gens</A> )</C>
<P/>
Each function <C>Sub<A>struct</A></C> checks that the <A>Struct</A> generated by
<A>gens</A> is in fact a subset of <A>D</A>.
If one wants to omit this check then one can call <C>Sub<A>struct</A>NC</C> instead;
the suffix <C>NC</C> stands for <Q>no  check</Q>.
<P/>
<Index Key="AsSubstruct"><C>AsSub<A>struct</A></C></Index>
<C>AsSub<A>struct</A>( <A>D</A>, <A>S</A> )</C>
<P/>
first constructs <C>As<A>Struct</A>( [<A>info</A>, ]<A>S</A> )</C>,
where <A>info</A> depends on <A>D</A> and <A>S</A>,
and then sets the parent (see&nbsp;<Ref Sect="Parents"/>) of this new domain to <A>D</A>.
<P/>
<Index Key="IsSubstruct"><C>IsSub<A>struct</A></C></Index>
<C>IsSub<A>struct</A>( <A>D</A>, <A>S</A> )</C>
<P/>
There is no real need for functions that check whether a domain <A>S</A> is a
<C>Sub<A>struct</A></C> of a domain <A>D</A>,
since this is equivalent to the checks whether <A>S</A> is a <A>Struct</A> and <A>S</A>
is a subset of <A>D</A>.
Note that in many cases, only the subset relation is what one really wants
to check, and that appropriate methods for the operation
<Ref Func="IsSubset"/> are available for many special situations,
such as the test whether a group is contained in another group,
where only generators need to be checked.
<P/>
If a function <C>IsSub<A>struct</A></C> is available in &GAP; then it is implemented
as first a call to <C>Is<A>Struct</A></C> for the second argument and then a call to
<Ref Func="IsSubset"/> for the two arguments.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Domains">
<Heading>Operations for Domains</Heading>

For the meaning of the attributes <Ref Attr="Characteristic"/>,
<Ref Attr="One"/>, <Ref Attr="Zero"/>
in the case of a domain argument,
see&nbsp;<Ref Sect="Attributes and Properties of Elements"/>.

<#Include Label="IsGeneralizedDomain">
<#Include Label="GeneratorsOfDomain">
<#Include Label="Domain">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Attributes and Properties of Elements">
<Heading>Attributes and Properties of Elements</Heading>

The following attributes and properties for elements and domains
correspond to the operational structure.

<#Include Label="Characteristic">
<#Include Label="OneImmutable">
<#Include Label="ZeroImmutable">
<#Include Label="MultiplicativeZeroOp">
<#Include Label="IsOne">
<#Include Label="IsZero">
<#Include Label="IsIdempotent">
<#Include Label="InverseImmutable">
<#Include Label="AdditiveInverseImmutable">
<#Include Label="Order">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparison Operations for Elements">
<Heading>Comparison Operations for Elements</Heading>

Binary comparison operations have been introduced already in
<Ref Sect="Comparisons"/>.
The underlying operations for which methods can be installed are the
following.


<ManSection>
<Heading>\= and \&lt;</Heading>
<Oper Name="\=" Arg='left-expr, right-expr'/>
<Oper Name="\&lt;" Arg='left-expr, right-expr'/>

<Description>
<Index Subkey="operation">equality</Index>
<Index Subkey="operation">comparison</Index>
Note that the comparisons via <C>&lt;></C>, <C>&lt;=</C>, <C>></C>,
and <C>>=</C>
are delegated to the operations <Ref Oper="\="/> and <Ref Oper="\&lt;"/>.
<P/>
In general, objects in <E>different</E> families cannot be compared with
<Ref Oper="\&lt;"/>.
For the reason and for exceptions from this rule,
see&nbsp;<Ref Sect="Comparisons"/>.
</Description>
</ManSection>

<#Include Label="CanEasilyCompareElements">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Arithmetic Operations for Elements">
<Heading>Arithmetic Operations for Elements</Heading>

<E>Binary</E> arithmetic operations have been introduced already in
<Ref Sect="Arithmetic Operators"/>.
The underlying operations for which methods can be installed are the
following.

<ManSection>
<Heading>\+, \*, \/, \^, \mod</Heading>
<Oper Name="\+" Arg='left-expr, right-expr'/>
<Oper Name="\*" Arg='left-expr, right-expr'/>
<Oper Name="\/" Arg='left-expr, right-expr'/>
<Oper Name="\^" Arg='left-expr, right-expr'/>
<Oper Name="\mod" Arg='left-expr, right-expr'/>

<Description>
<Index Subkey="operation">addition</Index>
<Index Subkey="operation">multiplication</Index>
<Index Subkey="operation">division</Index>
<Index Subkey="operation">exponentiation</Index>
<Index Subkey="operation">remainder</Index>
For details about special methods for <Ref Oper="\*"/>, 
<Ref Oper="\/"/>, <Ref Oper="\^"/> and <Ref Oper="\mod"/>, 
consult the appropriate index entries for them.
<!-- % (no Declaration available for them?) -->
</Description>
</ManSection>


<#Include Label="LeftQuotient">
<#Include Label="Comm">
<#Include Label="LieBracket">
<#Include Label="Sqrt">

<!-- % missing facts about the others ... -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Relations Between Domains">
<Heading>Relations Between Domains</Heading>

Domains are often constructed relative to other domains.
The probably most usual case is to form a <E>subset</E> of a domain,
for example the intersection
(see&nbsp;<Ref Func="Intersection" Label="for a list"/>) of two domains,
or a Sylow subgroup of a given group (see&nbsp;<Ref Func="SylowSubgroup"/>).
<P/>
In such a situation, the new domain can gain knowledge by exploiting that
several attributes are maintained under taking subsets.
For example, the intersection of an arbitrary domain with a finite domain
is clearly finite, a Sylow subgroup of an abelian group is abelian, too,
and so on.
<P/>
Since usually the new domain has access to the knowledge of the old domain(s)
only when it is created (see&nbsp;<Ref Sect="Constructing Subdomains"/> for the exception),
this is the right moment to take advantage of the subset relation,
using <Ref Func="UseSubsetRelation"/>.
<P/>
Analogous relations occur when a <E>factor structure</E> is created from a
domain and a subset (see <Ref Func="UseFactorRelation"/>),
and when a domain <E>isomorphic</E> to a given one is created
(see <Ref Func="UseIsomorphismRelation"/>).
<P/>
The functions <Ref Func="InstallSubsetMaintenance"/>,
<Ref Func="InstallIsomorphismMaintenance"/>, and
<Ref Func="InstallFactorMaintenance"/> are used to tell &GAP;
under what conditions an attribute is maintained under taking subsets,
or forming factor structures or isomorphic domains.
This is used only when a new attribute is created,
see&nbsp;<Ref Sect="Creating Attributes and Properties"/>.
For the attributes already available,
such as <Ref Func="IsFinite"/> and <Ref Func="IsCommutative"/>,
the maintenances are already notified.

<#Include Label="UseSubsetRelation">
<#Include Label="UseFactorRelation">
<#Include Label="UseIsomorphismRelation">

<#Include Label="InstallSubsetMaintenance">
<#Include Label="InstallFactorMaintenance">
<#Include Label="InstallIsomorphismMaintenance">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Useful Categories of Elements">
<Heading>Useful Categories of Elements</Heading>

This section and the following one are rather technical,
and may be interesting only for those &GAP; users who want to implement
new kinds of elements.
<P/>
It deals with certain categories of elements that are useful mainly for the
design of elements, from the viewpoint that one wants to form certain domains
of these elements.
For example, a domain closed under multiplication <C>*</C> (a so-called magma,
see Chapter&nbsp;<Ref Chap="Magmas"/>) makes sense only if its elements can be multiplied,
and the latter is indicated by the category
<Ref Func="IsMultiplicativeElement"/> for each element.
Again note that the underlying idea is that a domain is regarded as
<E>generated</E> by given elements, and that these elements carry information
about the desired domain.
For general information on categories and their hierarchies,
see&nbsp;<Ref Sect="Categories"/>.
<P/>
More special categories of this kind are described in the contexts where
they arise,
they are <Ref Func="IsRowVector"/>,
<Ref Func="IsMatrix"/>,
<Ref Func="IsOrdinaryMatrix"/>,
and <Ref Func="IsLieMatrix"/>.
<P/>
<#Include Label="IsExtAElement">
<#Include Label="IsNearAdditiveElement">
<#Include Label="IsAdditiveElement">
<#Include Label="IsNearAdditiveElementWithZero">
<#Include Label="IsAdditiveElementWithZero">
<#Include Label="IsNearAdditiveElementWithInverse">
<#Include Label="IsAdditiveElementWithInverse">
<#Include Label="IsExtLElement">
<#Include Label="IsExtRElement">
<#Include Label="IsMultiplicativeElement">
<#Include Label="IsMultiplicativeElementWithOne">
<#Include Label="IsMultiplicativeElementWithZero">
<#Include Label="IsMultiplicativeElementWithInverse">
<#Include Label="IsVector">
<#Include Label="IsNearRingElement">
<#Include Label="IsRingElement">
<#Include Label="IsNearRingElementWithOne">
<#Include Label="IsRingElementWithOne">
<#Include Label="IsNearRingElementWithInverse">
<#Include Label="IsRingElementWithInverse">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Useful Categories for all Elements of a Family">
<Heading>Useful Categories for all Elements of a Family</Heading>

The following categories of elements are to be understood mainly as
categories for all objects in a family,
they are usually used as third argument of <C>NewFamily</C>
(see&nbsp;<Ref Sect="Creating Families"/>).
The purpose of each of the following categories is then to guarantee that
each collection of its elements automatically lies in its collections
category (see&nbsp;<Ref Func="CategoryCollections"/>).
<P/>
For example, the multiplication of permutations is associative,
and it is stored in the family of permutations that each permutation lies
in <Ref Func="IsAssociativeElement"/>.
As a consequence, each magma consisting of permutations
(more precisely: each collection that lies in the family
<C>CollectionsFamily( PermutationsFamily )</C>,
see&nbsp;<Ref Func="CollectionsFamily"/>)
automatically lies in <C>CategoryCollections( IsAssociativeElement )</C>.
A magma in this category is always known to be associative, via a logical
implication (see&nbsp;<Ref Sect="Logical Implications"/>).
<P/>
Similarly, if a family knows that all its elements are in the categories
<Ref Func="IsJacobianElement"/> and <Ref Func="IsZeroSquaredElement"/>,
then each algebra of these elements is automatically known to be a
Lie algebra (see Chapter&nbsp;<Ref Chap="Algebras"/>).

<#Include Label="IsAssociativeElement">
<#Include Label="IsAdditivelyCommutativeElement">
<#Include Label="IsCommutativeElement">
<#Include Label="IsFiniteOrderElement">
<#Include Label="IsJacobianElement">
<#Include Label="IsZeroSquaredElement">

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->

