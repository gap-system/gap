<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  grphomom.msk                GAP documentation            Alexander Hulpke -->
<!-- %% -->
<!-- %A  @(#)<M>Id: grphomom.msk,v 1.47 2006/01/10 23:26:49 gap Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Group Homomorphisms">
<Heading>Group Homomorphisms</Heading>

A group homomorphism is a mapping from one group to another that respects
multiplication and inverses.
They are implemented as a special class of mappings,
so in particular all operations for mappings, such as
<Ref Func="Image" Label="set of images of the source of a general mapping"/>,
<Ref Func="PreImage" Label="set of preimages of the range of a general mapping"/>,
<Ref Func="PreImagesRepresentative"/>,
<Ref Func="KernelOfMultiplicativeGeneralMapping"/>,
<Ref Func="Source"/>, <Ref Func="Range" Label="of a general mapping"/>, 
<Ref Func="IsInjective"/> and <Ref Func="IsSurjective"/>
(see chapter&nbsp;<Ref Chap="Mappings"/>, in particular
section&nbsp;<Ref Sect="Mappings that Respect Multiplication"/>)
are applicable to them.
<P/>
Homomorphisms can be used to transfer calculations into isomorphic groups in
another representation, for which better algorithms are available.
Section&nbsp;<Ref Sect="Nice Monomorphisms"/> explains a technique
how to enforce this automatically.
<P/>
Homomorphisms are also used to represent group automorphisms, and section
<Ref Sect="Group Automorphisms"/> explains explains &GAP;'s facilities to work
with automorphism groups.
<P/>
Section <Ref Sect="Searching for Homomorphisms"/> explains
how to make &GAP; to search for all homomorphisms between two groups which
fulfill certain specifications.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Group Homomorphisms">
<Heading>Creating Group Homomorphisms</Heading>

The most important way of creating group homomorphisms is to give images for
a set of group generators and to extend it to the group generated by them
by the homomorphism property.
<P/>
<E>A second</E> way to create homomorphisms is to give functions
that compute image and preimage.
(A similar case are homomorphisms that are induced by conjugation.
Special constructors for such mappings are described in
section&nbsp;<Ref Sect="Group Automorphisms"/>).
<P/>
<E>The third</E> class are epimorphisms from a group onto its factor
group. Such homomorphisms can be constructed by
<Ref Func="NaturalHomomorphismByNormalSubgroup"/>.
<P/>
<E>The fourth</E> class is homomorphisms in a permutation group
that are induced by an action on a set.
Such homomorphisms are described in the context of group actions,
see chapter&nbsp;<Ref Chap="Group Actions"/> and in particular
<Ref Func="ActionHomomorphism" Label="for a group, an action domain, etc."/>.

<#Include Label="GroupHomomorphismByImages">
<#Include Label="GroupHomomorphismByImagesNC">
<#Include Label="GroupGeneralMappingByImages">
<#Include Label="GroupHomomorphismByFunction">
<#Include Label="AsGroupGeneralMappingByImages">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Group Homomorphisms">
<Heading>Operations for Group Homomorphisms</Heading>
<Index Subkey="group homomorphism">kernel</Index>

Group homomorphisms are mappings, so all the operations and properties for
mappings described in chapter&nbsp;<Ref Chap="Mappings"/> are applicable to
them.
(However often much better methods,
than for general mappings are available.)
<P/>
Group homomorphisms will map groups to groups by just mapping the set of
generators.
<P/>
<Ref Func="KernelOfMultiplicativeGeneralMapping"/> can be used to compute
the kernel of a group homomorphism.
<P/>
<Example><![CDATA[
gap> hom:=GroupHomomorphismByImages(g,h,gens,[(1,2),(1,3)]);;
gap> Kernel(hom);
Group([ (1,4)(2,3), (1,2)(3,4) ])
]]></Example>
<P/>
Homomorphisms can map between groups in different representations and are
also used to get isomorphic groups in a different representation.
<P/>
<Example><![CDATA[
gap> m1:=[[0,-1],[1,0]];;m2:=[[0,-1],[1,1]];;
gap> sl2z:=Group(m1,m2);; # SL(2,Integers) as matrix group
gap> F:=FreeGroup(2);;
gap> psl2z:=F/[F.1^2,F.2^3]; #PSL(2,Z) as FP group
<fp group on the generators [ f1, f2 ]>
gap> phom:=GroupHomomorphismByImagesNC(sl2z,psl2z,[m1,m2],
> GeneratorsOfGroup(psl2z)); # the non NC-version would be expensive
[ [ [ 0, -1 ], [ 1, 0 ] ], [ [ 0, -1 ], [ 1, 1 ] ] ] -> [ f1, f2 ]
gap> Kernel(phom); # the diagonal matrices
Group([ [ [ -1, 0 ], [ 0, -1 ] ], [ [ -1, 0 ], [ 0, -1 ] ] ])
gap> p1:=(1,2)(3,4);;p2:=(2,4,5);;a5:=Group(p1,p2);;
gap> ahom:=GroupHomomorphismByImages(psl2z,a5,
> GeneratorsOfGroup(psl2z),[p1,p2]); # here homomorphism test is cheap.
[ f1, f2 ] -> [ (1,2)(3,4), (2,4,5) ]
gap> u:=PreImage(ahom,Group((1,2,3),(1,2)(4,5)));
Group(<fp, no generators known>)
gap> Index(psl2z,u);
10
gap> isofp:=IsomorphismFpGroup(u);; Image(isofp);
<fp group of size infinity on the generators [ F1, F2, F3, F4 ]>
gap> RelatorsOfFpGroup(Image(isofp));
[ F1^2, F4^2, F3^3 ]
gap> up:=PreImage(phom,u);;
gap> List(GeneratorsOfGroup(up),TraceMat);
[ -2, -2, 0, -4, 1, 0 ]
]]></Example>
<P/>
For an automorphism <A>aut</A>,
<Ref Func="Inverse"/>
<Index Subkey="group homomorphism">Inverse</Index>
returns the inverse automorphism <M><A>aut</A>^{{-1}}</M>.
However if <A>hom</A> is a bijective homomorphism between
different groups, or if <A>hom</A> is injective and considered to be
a bijection to its image,
the operation <Ref Func="InverseGeneralMapping"/> should be used instead.
(See&nbsp;<Ref Func="Inverse"/> for a further discussion of this problem.)
<P/>
<Example><![CDATA[
gap> iso:=IsomorphismPcGroup(g);
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]) -> [ f1, f2, f3, f4 ]
gap> Inverse(iso);
#I  The mapping must be bijective and have source=range
#I  You might want to use `InverseGeneralMapping'
fail
gap> InverseGeneralMapping(iso);
[ f1, f2, f3, f4 ] -> Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Efficiency of Homomorphisms">
<Heading>Efficiency of Homomorphisms</Heading>

&GAP; permits to create homomorphisms between arbitrary groups.
This section considers the efficiency of the implementation and shows ways
how to choose suitable representations.
For permutation groups (see&nbsp;<Ref Chap="Permutation Groups"/>)
or Pc groups (see&nbsp;<Ref Chap="Pc Groups"/>)
this is normally nothing to worry about,
unless the groups get extremely large. For other groups however
certain calculations might be expensive and some precaution might be needed
to avoid unnecessarily expensive calculations.
<P/>
In short, it is always worth to tell a mapping that it is a homomorphism
(this can be done by calling <C>SetIsMapping</C>)
(or to create it directly with <Ref Func="GroupHomomorphismByImagesNC"/>).
<P/>
The basic operations required are to compute image and preimage of elements
and to test whether a mapping is a homomorphism. Their cost
will differ depending on the type of the mapping.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Mappings given on generators">
<Heading>Mappings given on generators</Heading>

See <Ref Func="GroupHomomorphismByImages"/> and
<Ref Func="GroupGeneralMappingByImages"/>.
<P/>
Computing images requires to express an element of the source as word in the
generators. If it cannot be done effectively (this is determined by
<Ref Func="KnowsHowToDecompose"/> which returns <K>true</K> for
example for arbitrary permutation groups, for Pc groups or for finitely
presented groups with the images of the free generators) the span of the
generators has to be computed elementwise which can be very expensive and
memory consuming.
<P/>
Computing preimages adheres to the same rules with swapped r√¥les of
generators and their images.
<P/>
The test whether a mapping is a homomorphism requires
the computation of a presentation for the source and evaluation of its
relators in the images of its generators. For larger groups this can be
expensive and <Ref Func="GroupHomomorphismByImagesNC"/> should be used
if the mapping is known to be a homomorphism.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Action homomorphisms">
<Heading>Action homomorphisms</Heading>

See
<Ref Func="ActionHomomorphism" Label="for a group, an action domain, etc."/>.
<P/>
The calculation of images is determined by the acting function used and
&ndash;for large domains&ndash; is often dominated by the search for the
position of an image in a list of the domain elements.
This can be improved by sorting this list if an efficient method for
<Ref Func="\&lt;"/> to compare elements of the domain is available.
<P/>
Once the images of a generating set are computed, computing preimages
(which is done via <Ref Func="AsGroupGeneralMappingByImages"/>)
and computing the kernel behaves the same as for a homomorphism
created with <Ref Func="GroupHomomorphismByImages"/> from a permutation
group.
<P/>
&GAP; will always assume that the acting function provided implements
a proper group action and thus that the mapping is indeed a homomorphism.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Mappings given by functions">
<Heading>Mappings given by functions</Heading>

See <Ref Func="GroupHomomorphismByFunction" Label="by function (and inverse function) between two domains"/>.
<!-- commented out a reference to a nonexisting function: -->
<!-- , <Ref Func="GroupGeneralMappingByFunctions"/>.-->
<P/>
Computing images is wholly determined by the function that performs the
image calculation. If no function to compute preimages is given, computing
preimages requires mapping every element of the source to find an element
that maps to the requested image. This is time and memory consuming.
<P/>
<!-- commented out a paragraph on a nonexisting function: -->
<!-- Testing whether a mapping constructed with
<Ref Func="GroupGeneralMappingByFunctions"/> is a homomorphism would
require mapping all products of elements and thus should be avoided. -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Other operations">
<Heading>Other operations</Heading>

To compute the kernel of a homomorphism (unless the mapping is known to be
injective) requires the capability to compute a
presentation of the image and to evaluate the relators of this presentation
in preimages of the presentations generators.
<P/>
The calculation of the
<Ref Func="Image" Label="set of images of the source of a general mapping"/>
(respectively <Ref Func="ImagesSource"/>) value requires to map
a generating set of the source,
testing surjectivity is a comparison for equality with the range.
<P/>
Testing injectivity is a test for triviality of the kernel.
<P/>
The comparison of mappings is based on a lexicographic comparison of a
sorted element list of the source.
For group homomorphisms, this can be simplified,
using <Ref Func="ImagesSmallestGenerators"/>

</Subsection>

<#Include Label="ImagesSmallestGenerators">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Homomorphism for very large groups">
<Heading>Homomorphism for very large groups</Heading>

Some homomorphisms (notably particular actions) transfer known information
about the source group (such as a stabilizer chain) to the image group if
this is substantially cheaper than to compute the information in the image
group anew. In most cases this is no problem and in fact speeds up further
calculations notably.
<P/>
For a huge source group, however this can be time consuming or take a large
amount of extra memory for storage. In this case it can be helpful to avoid
as much automatism as possible.
<P/>
The following list of tricks might be useful in such a case. (However you
will lose much automatic deduction. So please restrict the use of these to
cases where the standard approach does not work.)
<List>
<Item>
  Compute only images (or the <Ref Func="PreImagesRepresentative"/>) of
  group elements.
  Do not compute the images of (sub)groups or the full preimage of a subgroup.
</Item>
<Item>
  Create action homomorphisms as <Q>surjective</Q> (see
  <Ref Func="ActionHomomorphism" Label="for a group, an action domain, etc."/>),
  otherwise the range is set to be the full symmetric group.
  However do not compute <Ref Func="Range" Label="of a general mapping"/> or
  <Ref Func="Image" Label="set of images of the source of a general mapping"/>
  values,
  but only the images of a generator set.
</Item>
<Item>
  If you suspect an action homomorphism to do too much internally,
  replace the action function with a function that does the same;
  i.e. replace <Ref Func="OnPoints"/> by
  <C>function( p, g ) return p^g; end;</C>.
  The action will be the same, but as the action function is not
  <Ref Func="OnPoints"/>,
  the extra processing for special cases is not triggered.
</Item>
</List>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Nice Monomorphisms">
<Heading>Nice Monomorphisms</Heading>

&GAP; contains very efficient algorithms for some special representations
of groups (for example pc groups or permutation groups) while for other
representations only slow generic methods are available. In this case it
can be worthwhile to do all calculations rather in an isomorphic image of
the group, which is in a <Q>better</Q> representation. The way to achieve this
in &GAP; is via <E>nice monomorphisms</E>.
<P/>
For this mechanism to work, of course there must be effective methods to
evaluate the <Ref Func="NiceMonomorphism"/> value on elements and to take
preimages under it.
As by definition no good algorithms exist for the source group,
normally this can only be achieved by using the result of a call to
<Ref Func="ActionHomomorphism" Label="for a group, an action domain, etc."/>
or <Ref Func="GroupHomomorphismByFunction" Label="by function (and inverse function) between two domains"/>
(see also section&nbsp;<Ref Sect="Efficiency of Homomorphisms"/>).

<#Include Label="IsHandledByNiceMonomorphism">
<#Include Label="NiceMonomorphism">
<#Include Label="NiceObject">
<#Include Label="IsCanonicalNiceMonomorphism">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Group Automorphisms">
<Heading>Group Automorphisms</Heading>

Group automorphisms are bijective homomorphism from a group onto itself.
An important subclass are automorphisms which are induced by conjugation of
the group itself or a supergroup.

<#Include Label="ConjugatorIsomorphism">
<#Include Label="ConjugatorAutomorphism">
<#Include Label="InnerAutomorphism">
<#Include Label="IsConjugatorIsomorphism">
<#Include Label="ConjugatorOfConjugatorIsomorphism">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Groups of Automorphisms">
<Heading>Groups of Automorphisms</Heading>

Group automorphism can be multiplied and inverted and thus it is possible
to form groups of automorphisms.

<#Include Label="AutomorphismGroup">
<#Include Label="IsGroupOfAutomorphisms">
<#Include Label="AutomorphismDomain">
<#Include Label="IsAutomorphismGroup">
<#Include Label="InnerAutomorphismsAutomorphismGroup">
<#Include Label="InducedAutomorphism">

<!-- %%  The code for automorphism groups was designed and implemented by Bettina -->
<!-- %%  Eick and Alexander Hulpke. -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Calculating with Group Automorphisms">
<Heading>Calculating with Group Automorphisms</Heading>

Usually the best way to calculate in a group of automorphisms is to
translate all calculations to an isomorphic group in a representation, for
which better algorithms are available, say a permutation group. This
translation can be done automatically using <Ref Func="NiceMonomorphism"/>.
<P/>
Once a group knows to be a group of automorphisms (this can be achieved
by testing or setting the property <Ref Func="IsGroupOfAutomorphisms"/>),
&GAP; will try itself to find such a nice monomorphism once calculations in
the automorphism group are done.
<P/>
Note that nice homomorphisms inherit down to subgroups, but cannot
necessarily be extended from a subgroup to the whole group. Thus when
working with a group of automorphisms, it can be beneficial to 
enforce calculation of the nice monomorphism for the whole group
(for example by explicitly calling
<Ref Func="Random" Label="for a list or collection"/> and ignoring
the result &ndash;it will be stored internally) at the start of the
calculation.
Otherwise &GAP; might first calculate a nice monomorphism for the subgroup,
only to be forced to calculate a new nice monomorphism for the whole group
later on.
<P/>
If a good domain for a faithful permutation action is known already, a
homomorphism for the action on it can be created using
<Ref Func="NiceMonomorphismAutomGroup"/>.
It might be stored by <C>SetNiceMonomorphism</C>
(see <Ref Func="NiceMonomorphism"/>).
<P/>
Another nice way of representing automorphisms as permutations has been
described in <Cite Key="Sims97"/>.
It is not yet available in &GAP;, a description however can be found
in section
&nbsp;<Ref Sect="Stabilizer Chains for Automorphisms Acting on Enumerators"/>.

<#Include Label="AssignNiceMonomorphismAutomorphismGroup">
<#Include Label="NiceMonomorphismAutomGroup">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Searching for Homomorphisms">
<Heading>Searching for Homomorphisms</Heading>

<Index Subkey="find all">homomorphisms</Index>

<#Include Label="IsomorphismGroups">
<#Include Label="AllHomomorphismClasses">
<#Include Label="AllHomomorphisms">
<#Include Label="GQuotients">
<#Include Label="IsomorphicSubgroups">
<#Include Label="MorClassLoop">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Representations for Group Homomorphisms">
<Heading>Representations for Group Homomorphisms</Heading>

The different representations of group homomorphisms are used to indicate
from what type of group to what type of group they map and thus determine
which methods are used to compute images and preimages.
<P/>
The information in this section is mainly relevant for implementing new
methods and not for using homomorphisms.

<#Include Label="IsGroupGeneralMappingByImages">
<#Include Label="MappingGeneratorsImages">
<#Include Label="IsGroupGeneralMappingByAsGroupGeneralMappingByImages">
<#Include Label="IsPreimagesByAsGroupGeneralMappingByImages">
<#Include Label="IsPermGroupGeneralMapping">
<#Include Label="IsToPermGroupGeneralMappingByImages">
<#Include Label="IsGroupGeneralMappingByPcgs">
<#Include Label="IsPcGroupGeneralMappingByImages">
<#Include Label="IsToPcGroupGeneralMappingByImages">
<#Include Label="IsFromFpGroupGeneralMappingByImages">
<#Include Label="IsFromFpGroupStdGensGeneralMappingByImages">

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->

