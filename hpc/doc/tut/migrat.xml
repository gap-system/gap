<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  migrat.tex               GAP manual                  Alexander Hulpke -->
<!-- %% -->
<!-- %H  @(#)<M>Id: migrat.tex,v 4.35 2002/10/04 12:04:17 gap Exp </M> -->
<!-- %% -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Migrating to GAP 4">
<Heading>Migrating to &GAP;&nbsp;4</Heading>

This chapter is intended to give users who have experience with &GAP;&nbsp;3
some information about what has changed in &GAP;&nbsp;4.
<P/>
In particular, it informs about changed command line options
(see&nbsp;<Ref Sect="Changed Command Line Options"/>),
the new global variable <K>fail</K> (see&nbsp;<Ref Sect="Fail"/>),
some functions that have changed their behaviour
(see&nbsp;<Ref Sect="Changed Functionality"/>) or their names
(see&nbsp;<Ref Sect="Changed Variable Names"/>),
and some conventions used for variable names (see&nbsp;<Ref Sect="Naming Conventions"/>).
<P/>
Then the new concepts of &GAP;&nbsp;4 are sketched,
first that of mutability or immutability (see&nbsp;<Ref Sect="Immutability"/>),
with the explanation of related changes in functions that copy objects
(see&nbsp;<Ref Sect="Copy"/>),
then the concepts of operations and method selection, which are compared
with the use of operations records in &GAP;&nbsp;3
(see&nbsp;<Ref Sect="Attributes vs. Record Components"/>, <Ref Sect="Operations Records"/>,
and&nbsp;<Ref Sect="Operations vs. Dispatcher Functions"/>).
<P/>
More local changes affect the concepts of notions of generation
(see&nbsp;<Ref Sect="Different Notions of Generation"/>),
of parents (see&nbsp;<Ref Sect="Parents and Subgroups"/>),
of homomorphisms (see&nbsp;<Ref Sect="Homomorphisms vs. General Mappings"/>,
<Ref Sect="Homomorphisms vs. Factor Structures"/>,
and&nbsp;<Ref Sect="Isomorphisms vs. Isomorphic Structures"/>),
how elements in finitely presented groups are treated
(see&nbsp;<Ref Sect="Elements of Finitely Presented Groups"/>),
how information about progress of computations can be obtained
(see&nbsp;<Ref Sect="The Info Mechanism"/>),
and how one gets information in a <C>break</C> loop
(see&nbsp;<Ref Sect="Debugging"/>).
<P/>
While a <Q>&GAP;&nbsp;3 compatibility mode</Q> is provided
(see <Ref Sect="Compatibility Mode"/>),
its use will disable some of the new features of &GAP;&nbsp;4.
Also it certainly can only try to provide partial compatibility.
<P/>
For a detailed explanation of the new features and concepts of &GAP;&nbsp;4,
see the manual <Q>Programming in GAP</Q>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Changed Command Line Options">
<Heading>Changed Command Line Options</Heading>

In &GAP;&nbsp;4, the <C>-l</C> option is used to specify the <E>root directory</E>
(see&nbsp;<Ref Sect="GAP Root Directory" BookName="ref"/>)
of the &GAP; distribution,
which is the directory containing the <C>lib</C> and <C>doc</C> subdirectories.
Note that in &GAP;&nbsp;3 this option was used to specify the path to the
<C>lib</C> directory.
<P/>
The <C>-h</C> option of &GAP;&nbsp;3 has been removed,
the path(s) for the documentation are deduced automatically in &GAP;&nbsp;4.
<P/>
The option <C>-g</C> is now used to print information only about full garbage
collections.
The new option <C>-g -g</C> generates  information about partial
garbage collections too.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Fail">
<Heading>Fail</Heading>

There is a new global variable
<Index>fail instead of false</Index>
<P/>
<ManSection>
<Var Name="fail"/>
<Description>
in &GAP;&nbsp;4.
It is intended as a return value of a function for the case that it
could not perform its task.
For example, <C>Inverse</C> returns <K>fail</K> if it is called with a singular
matrix, and <C>Position</C> returns <K>fail</K> if the second argument is not
contained in the list given as first argument.
<P/>
&GAP;&nbsp;3 handled such situations by either signalling an error,
for example if it was asked for the inverse of a singular matrix,
or by (mis)using <K>false</K> as return value, as in the example <C>Position</C>.
Note that in the first example, in &GAP;&nbsp;3 it was necessary to check
the invertibility of a matrix before one could safely ask for its
inverse, which meant that roughly the same work was done twice.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Changed Functionality">
<Heading>Changed Functionality</Heading>

Some functions that were already available in &GAP;&nbsp;3  behave
differently in &GAP;&nbsp;4.  This section lists them.
<P/>
<ManSection>
<Func Name="Orbit" Arg="G, pnt"/>
<Description>
The &GAP;&nbsp;3 manual promised that <A>pnt</A> would be the first entry of the
resulting orbit. This was wrong already there in a few cases, therefore
&GAP;&nbsp;4 does not promise anything about the ordering of points in an orbit.
</Description>
</ManSection>
<P/>
<ManSection>
<Attr Name="Order" Arg="g"/>
<Description>
only takes the element <A>g</A> and computes its multiplicative order.
Calling <C>Order</C> with two arguments is permitted only in the
&GAP;&nbsp;3 compatibility mode, see&nbsp;<Ref Sect="Compatibility Mode"/>.
(Note that it does not make sense anymore to specify a group as
first argument w.r.t. which the order of the second argument shall
be computed, see&nbsp;<Ref Sect="Elements of Finitely Presented Groups"/>.)
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="Position" Arg="list, obj"/>
<Description>
If <A>obj</A> is not contained in the list <A>list</A> then <K>fail</K> is returned
in &GAP;&nbsp;4 (see&nbsp;<Ref Sect="Fail"/>), whereas <K>false</K> was returned in &GAP;&nbsp;3.
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="PermGroupOps.ElementProperty" Arg="G, prop[, K]"/>
<Description>
In &GAP;&nbsp;3, this function took either two or three arguments,
the optional argument <A>K</A> being a subgroup of <A>G</A> that stabilizes <A>prop</A>
in the sense that for any element <A>g</A> in <A>G</A>,
either all elements or no element in the coset <C><A>g</A> * <A>K</A></C> have the
property <A>prop</A>.
<P/>
The &GAP;&nbsp;4 function <C>ElementProperty</C>, however,
takes between two and four arguments,
and the subgroup <A>K</A> known from &GAP;&nbsp;3 has to be entered as the <E>fourth</E>
argument <E>not</E> the third.
(The third argument in the &GAP;&nbsp;4 function denotes a subgroup <A>U</A>
stabilizing <A>prop</A> in the sense that either all elements or no element
in right cosets <C><A>U</A> * <A>g</A></C> have the property <A>prop</A>.)
<P/>
(This discrepancy was discovered only in March&nbsp;2002,
short before the release of &GAP;&nbsp;4.3.)
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="Print" Arg="obj, ..."/>
<Description>
Objects may appear on the screen in a different way,
depending on whether they are printed by the read eval print loop
or by an explicit call of <C>Print</C>.
The reason is that the read eval print loop calls the operation <C>ViewObj</C>
and not <C>PrintObj</C>, whereas <C>Print</C> calls <C>PrintObj</C> for each of its
arguments.
This permits the installation of methods for printing objects in a short form
in the read eval print loop while retaining <C>Print</C> to display
the object completely.
See also Section&nbsp;<Ref Sect="View and Print" BookName="ref"/>.
<P/>
(<C>PrintObj</C> is installed as standard method <C>ViewObj</C>, so it is
not really necessary to have a <C>ViewObj</C> method for an object.)
</Description>
</ManSection>
<P/>
<ManSection>
<Func Name="PrintTo" Arg="filename, obj, ..."/>
<Description>
In &GAP;&nbsp;3, <C>PrintTo</C> could be (mis)used to <Q>redirect</Q> the text
<E>printed</E> by a function (that is, <E>not</E> only the output of a function)
to a file by entering the function call as second argument.
This was used mainly in order to avoid many calls of <C>AppendTo</C>.
In &GAP;&nbsp;4, this feature has disappeared.
One can use streams (see Chapter&nbsp;<Ref Chap="Streams" BookName="ref"/>)
instead in order to write files efficiently.
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Changed Variable Names">
<Heading>Changed Variable Names</Heading>

<Index Key="AgGroup"><C>AgGroup</C></Index>
<Index Key="ApplyFunc"><C>ApplyFunc</C></Index>
<Index Key="Backtrace"><C>Backtrace</C></Index>
<Index Key="CharTable"><C>CharTable</C></Index>
<Index Key="Denominator"><C>Denominator</C></Index>
<Index Key="DepthVector"><C>DepthVector</C></Index>
<Index Key="Elements"><C>Elements</C></Index>
<Index Key="IsBijection"><C>IsBijection</C></Index>
<Index Key="IsFunc"><C>IsFunc</C></Index>
<Index Key="IsMat"><C>IsMat</C></Index>
<Index Key="IsRec"><C>IsRec</C></Index>
<Index Key="IsSet"><C>IsSet</C></Index>
<Index Key="LengthWord"><C>LengthWord</C></Index>
<Index Key="NOfCyc"><C>NOfCyc</C></Index>
<Index Key="Numerator"><C>Numerator</C></Index>
<Index Key="RandomInvertableMat"><C>RandomInvertableMat</C></Index>
<Index Key="RecFields"><C>RecFields</C></Index>
<Index Key="X"><C>X</C></Index>

Some functions have changed their name without changing the
functionality.
A -- probably incomplete -- list follows
<P/>
<Log><![CDATA[
    GAP 3                   GAP 4

    AgGroup                 PcGroup            # (also composita)
    ApplyFunc               CallFuncList
    Backtrace               Where
    CharTable               CharacterTable     # (also composita)
    Denominator             DenominatorRat
    DepthVector             PositionNonZero
    Elements                AsSSortedList
    IsBijection             IsBijective
    IsFunc                  IsFunction
    IsMat                   IsMatrix
    IsRec                   IsRecord
    IsSet                   IsSSortedList
    LengthWord              Length
    NOfCyc                  Conductor
    Numerator               NumeratorRat
    NormedVector            NormedRowVector
    Operation               Action            # (also composita)
    Order(G,g)              Order(g)
    OrderMat                Order
    OrderPerm               Order
    RandomInvertableMat     RandomInvertibleMat
    RecFields               RecNames
    X                       Indeterminate
]]></Log>
<P/>
See Section&nbsp;<Ref Sect="Compatibility Mode"/> for a way to make the old names
available again.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Naming Conventions">
<Heading>Naming Conventions</Heading>

The way functions are named has been unified in &GAP;&nbsp;4.
This might help to memorize or even guess names of library functions.
<P/>
If a variable name consists of several words then the first
letter of each word is capitalized.
<P/>
If the first part of the name of a function is a verb then the function
may modify its argument(s) but does not return anything,
for example <C>Append</C> appends the list given as second argument to the
list given as first argument.
Otherwise the function returns an object without changing the arguments,
for example <C>Concatenation</C> returns the concatenation of the lists
given as arguments.
<P/>
If the name of a function contains the word <C>By</C> then the return value is
thought of as built in a certain way from the parts given as arguments.
For example, <C>GroupByGenerators</C> returns a group built from its group
generators, and creating a group as a factor group of a given group
by a normal subgroup can be done by taking the image of
<C>NaturalHomomorphismByNormalSubgroup</C>
(see also&nbsp;<Ref Sect="Homomorphisms vs. Factor Structures"/>).
Other examples of <Q><C>By</C></Q> functions are <C>GroupHomomorphismByImages</C> and
<C>UnivariateLaurentPolynomialByCoefficients</C>.
<P/>
If the name of a function contains the word <C>Of</C> then the return value is
thought of as information deduced from the arguments.
Usually such functions are attributes
(see&nbsp;<Ref Sect="Attributes"/> in this Tutorial and&nbsp;<Ref Sect="Attributes" BookName="ref"/>).
Examples are <C>GeneratorsOfGroup</C>, which returns a list of generators for
the group entered as argument, or <C>DiagonalOfMat</C>.
<P/>
For the setter and tester functions of an attribute <A>attr</A>
(see&nbsp;<Ref Sect="Attributes vs. Record Components"/> in this Tutorial
and&nbsp;<Ref Sect="Attributes" BookName="ref"/>)
the names <C>Set<A>attr</A></C> resp.&nbsp;<C>Has<A>attr</A></C> are available.
<P/>
If the name of a function <A>fun1</A> ends with <C>NC</C> then there is another
function <A>fun2</A> with the same name except that the <C>NC</C> is missing.
<C>NC</C> stands for <Q>no check</Q>.
When <A>fun2</A> is called then it checks whether its arguments are valid,
and if so then it calls <A>fun1</A>.
The functions <C>SubgroupNC</C> and <C>Subgroup</C> are a typical example.
<P/>
The idea is that the possibly time consuming check of the arguments
can be omitted if one is sure that they are unnecessary.
For example, if an algorithm produces generators of the derived subgroup
of a group then it is guaranteed that they lie in the original group;
<C>Subgroup</C> would check this, and <C>SubgroupNC</C> omits the check.
<P/>
Needless to say, all these rules are not followed slavishly,
for example there is one operation <C>Zero</C> instead of two operations
<C>ZeroOfElement</C> and <C>ZeroOfAdditiveGroup</C>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Immutable Objects">
<Heading>Immutable Objects</Heading>

&GAP;&nbsp;4 supports <Q>immutable</Q> objects.  Such objects cannot be
changed, attempting to do so issues an error.  Typically attribute
values are immutable, and also the results of those binary arithmetic
operations where both arguments are immutable,
see Section&nbsp;<Ref Sect="Vectors and Matrices"/>.
For example, <C>[ 1 .. 100 ] + [ 1 .. 100 ]</C> is a
mutable list and <C>2 * Immutable( [ 1 .. 100 ] )</C> is an immutable
list, both are equal to the (mutable) list <C>[ 2, 4 .. 200 ]</C>.
<P/>
There is no way to <E>make</E> an immutable object mutable, one can only
get a mutable copy by <C>ShallowCopy</C>.  The other way round,
<C>MakeImmutable</C> makes a (mutable or immutable) object and all its
subobjects immutable; one must be very careful to use <C>MakeImmutable</C>
only for those objects that are really newly created, for such objects
the advantage over <C>Immutable</C> is that no copy is made.
<P/>
More about immutability can be found in Sections&nbsp;<Ref Sect="Immutability"/> in
this tutorial and&nbsp;<Ref Sect="Mutability and Copyability" BookName="ref"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Copy">
<Heading>Copy</Heading>

<Index Key="StructuralCopy"><C>StructuralCopy</C></Index>
<Index Key="ShallowCopy"><C>ShallowCopy</C></Index>
The function <C>Copy</C> of &GAP;&nbsp;3 is not supported in &GAP;&nbsp;4.  This
function was used to create a copy <A>cop</A> of its argument <A>obj</A> with
the properties that <A>cop</A> and <A>obj</A> had no subobjects in common and
that if two subobjects of <A>obj</A> were identical then also the
corresponding subobjects of <A>cop</A> were identical.
<P/>
The possibility of having immutable objects (see&nbsp;<Ref Sect="Immutability"/>) can and
should be used to avoid unnecessary copying.
Namely, given an immutable object one needs to copy it only if one wants
to get a modified object, and in such a situation usually it is
sufficient to use <C>ShallowCopy</C>, or at least one knows how deep one must
copy in order to do the changes one has in mind.
<P/>
For example, suppose you have a matrix group, and you want to
construct a list of matrices by modifying the group generators.  This
list of generators is immutable, so you call <C>ShallowCopy</C> to get a
mutable list that contains the same matrices.  If you only want to
exchange some of them, or to append some other matrices, this shallow
copy is already what you need.  So suppose that you are interested in
a list of matrices where some rows are also changed.  For that, you
call <C>ShallowCopy</C> for the matrices in question, and you get matrices
whose rows can be changed.  If you want to change single entries in
some rows, <C>ShallowCopy</C> must be called to get mutable copies of these
rows.  Note that in all these situations there is no danger to change,
i.e., to destroy the original generators of the matrix group.
<P/>
If one needs the facility of the <C>Copy</C> function of &GAP;&nbsp;3 to get a
copy with the same structure then one can use the new &GAP;&nbsp;4
function <C>StructuralCopy</C>.  It returns a structural copy that has no
<E>mutable</E> subobject in common with its argument.  So if
<C>StructuralCopy</C> is called with an immutable object then this object
itself is returned, and if <C>StructuralCopy</C> is called with a mutable
list of immutable objects then a shallow copy of this list is
returned.
<P/>
Note that <C>ShallowCopy</C> now is an operation.  So if you create your
own type of (copyable) objects then you must define what a shallow
copy of these objects is, and install an appropriate method.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Attributes vs. Record Components">
<Heading>Attributes vs. Record Components</Heading>

In &GAP;&nbsp;3, many complex objects were represented via records, for
example all domains.  Information about these objects was stored in
components of these records.  For the user, this was usually not
relevant, since there were functions for computing information about
the objects in question.  For example, if one was interested in the
size of a group then one could call <C>Size</C>.
<P/>
But since it was guaranteed that the size of a domain <A>D</A> was stored
as value of the component <C>size</C>, it was allowed to access <C><A>D</A>.size</C>
if this component was bound, and a check for this was possible via
<C>IsBound( <A>D</A>.size )</C>.
<P/>
In &GAP;&nbsp;4, only the access via functions is admissible.  One reason
is the following basic rule.
<P/>
<E>From the information that a given &GAP;&nbsp;4 object is for example a
domain, one cannot conclude that this object has a certain
representation.</E>
<P/>
For attributes like <C>Size</C>, &GAP;&nbsp;4 provides two related functions,
the <E>setter</E> and the <E>tester</E> of the attribute, which can be used to
set an attribute value and to check whether the value of an attribute
is already stored for an object (see also&nbsp;<Ref Sect="Attributes" BookName="ref"/>).  For example, if <A>D</A> is a domain in &GAP;&nbsp;4 then
<C>HasSize( <A>D</A> )</C> is <K>true</K> if the size of <A>D</A> is already stored, and
<K>false</K> otherwise.  In the latter case, if you know that the size of
<A>D</A> is <A>size</A> then you may store it by <C>SetSize( <A>D</A>, <A>size</A> )</C>.
<P/>
Besides the flexibility in the internal representation of objects,
storing information only via function calls has also the advantage
that &GAP;&nbsp;4 is able to draw conclusions automatically.  For example,
as soon as it is stored that a group is nilpotent, it is also stored
that it is solvable, see Chapters&nbsp;<Ref Chap="Types of Objects" BookName="ref"/> and&nbsp;<Ref Chap="Method Selection" BookName="ref"/>
for the details.
<P/>
As a consequence, you cannot put your favourite information into a
domain <A>D</A> by assigning it to a new component like
<C><A>D</A>.myPrivateInfo</C>.  Instead you can introduce a new attribute and
then use its setter, see&nbsp;<Ref Sect="Attributes" BookName="ref"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Different Notions of Generation">
<Heading>Different Notions of Generation</Heading>

As in &GAP;&nbsp;3, a <E>domain</E> in &GAP;&nbsp;4 is a structured set.
<P/>
The same set can have different structures, for example a field can be
regarded as a ring or as an algebra or vector space over a subfield.
<P/>
In &GAP;&nbsp;3, however, an object representing a ring did not represent
a field, and an object representing a field did not represent a ring.
One reason for this was that the record component <C>generators</C> was
used to denote the appropriate generators of the domain.  For a ring
<A>R</A>, the component <C><A>R</A>.generators</C> was a list of ring generators, and
for a field <A>F</A>, <C><A>F</A>.generators</C> was a list of field generators.
<P/>
&GAP;&nbsp;4 cleans this up, see&nbsp;<Ref Sect="Notions of Generation"/>.  It supports
many different notions of generation, for example one can ask for
magma generators of a group or for generators of a field as an additive
group.  A subtle but important distinction is that between generators
of an algebra and of an algebra-with-one.
<P/>
So the attributes <C>GeneratorsOfGroup</C>, <C>GeneratorsOfMagma</C>,
<C>GeneratorsOfRing</C>, <C>GeneratorsOfField</C>, <C>GeneratorsOfVectorSpace</C>,
and so on, replace the access to the <C>generators</C> component.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations Records">
<Heading>Operations Records</Heading>

Already in &GAP;&nbsp;3 there were several functions that were applicable
to many different kinds of objects, for example <C>Size</C> could be
applied to any domain, and the binary infix multiplication <C>*</C> could
be used to multiply two matrices, an integer with a row vector, or a
permutation with a permutation group.  This was implemented as
follows.  Functions like <C>Size</C> and <C>*</C> tried to find out what
situation was described by its arguments, and then it called a more
specific function to compute the desired information.  These more
specific functions, let us call them <E>methods</E> as they are also called
in &GAP;&nbsp;4, were stored in so-called <E>operations records</E> of the
arguments.
<P/>
For example, every domain in &GAP;&nbsp;3 was represented as a record, and
the operations record was stored in the record component <C>operations</C>.
If <C>Size</C> was called for the domain then the method to compute the
size of the domain was found as value of the <C>Size</C> component of the
operations record.
<P/>
This was fine for functions taking only one argument, and in principle
it is possible that for those functions an object stored an optimal
method in its operations record.  But in the case of more arguments
this is not possible.  In a multiplication of two objects in &GAP;&nbsp;3,
one had to choose between the methods stored in the operations records
of the arguments, and if for example the method stored for the left
operand was called, this method had to handle all possible right
operands.
<P/>
So operations records turned out to be not flexible enough.
In &GAP;&nbsp;4, operations records are not supported
(see&nbsp;<Ref Sect="Compatibility Mode"/> for a possibility
to use your &GAP;&nbsp;3 code that utilizes operations records,
at least to some extent).
A detailed description
of the new mechanism to select methods can be found in
Chapter&nbsp;<Ref Chap="Method Selection" BookName="ref"/>.
<P/>
An important point is that the new mechanism allows &GAP; to take the
relation between arguments into account.  So it is possible (and
recommended) to install different methods for different relations
between the arguments.  Note that such methods need not do the
extensive argument checking that was necessary in &GAP;&nbsp;3, because
most of the checks are done already by the method selection mechanism.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations vs. Dispatcher Functions">
<Heading>Operations vs. Dispatcher Functions</Heading>

&GAP;&nbsp;3 functions like <C>Size</C>, <C>CommutatorSubgroup</C>, or
<C>SylowSubgroup</C> did mainly call an appropriate method
(see&nbsp;<Ref Sect="Operations Records"/>)
after they had checked their arguments.
Such functions were
called <E>dispatchers</E> in &GAP;&nbsp;3.  In &GAP;&nbsp;4, many dispatchers have
been replaced by <E>operations</E>, due to the fact that methods are no
longer stored in operations records (see&nbsp;<Ref Chap="Method Selection" BookName="ref"/> for the details).
<P/>
Most dispatchers taking only one argument were treated in a special
way in &GAP;&nbsp;3, they had the additional task of storing computed
values and using these values in subsequent calls.  For example, the
dispatcher <C>Size</C> first checked whether the size of the argument was
already stored, and if so then this value was returned; otherwise a
method was called, the value returned by this method was stored in the
argument, and then returned by <C>Size</C>.
<P/>
In &GAP;&nbsp;4, computed values of operations that take one argument
(these operations are called <E>attributes</E>) are also stored, only the
mechanism to achieve this has changed, see&nbsp;<Ref Sect="Attributes" BookName="ref"/>
and&nbsp;<Ref Sect="Properties" BookName="ref"/>.
<P/>
So the behaviour of <C>Size</C> is the same in &GAP;&nbsp;3 and &GAP;&nbsp;4.  But
note that in &GAP;&nbsp;4, it is not possible to access <C><A>D</A>.size</C>,
see&nbsp;<Ref Sect="Attributes vs. Record Components"/>.
As described in&nbsp;<Ref Sect="Operations Records"/>,
&GAP;&nbsp;4 does not admit <Q>bypassing the dispatcher</Q> by
calling for example <C><A>D</A>.operations.Size</C>.  This was done in &GAP;&nbsp;3
often for efficiency reasons, but the method selection mechanism of
&GAP;&nbsp;4 is fast enough to make this unnecessary.
<P/>
If you had written your own dispatchers and put your own methods into
existing operations records then this code will not work in &GAP;&nbsp;4.
See&nbsp;<Ref Chap="Creating New Objects" BookName="ref"/>
and&nbsp;<Ref Chap="Method Selection" BookName="ref"/>
for a description of how to define operations
and to install methods.
<P/>
Finally, some functions in &GAP;&nbsp;3 were hidden in
operations records, e.g., <C>PermGroupOps.MovedPoints</C>.
These functions became proper operations in &GAP;&nbsp;4.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Parents and Subgroups">
<Heading>Parents and Subgroups</Heading>

In &GAP;&nbsp;3 there was a strict distinction between parent groups and
subgroups.
The use of the name <Q>parent</Q> (instead of <Q>supergroup</Q>)
was chosen to indicate that the parent of an object was more than just
useful information.
In fact the main reason for the introduction of parents was to provide
a common roof for example for all groups of polycyclic words that
belonged to the same PC-presentation, or for all subgroups of a finitely
presented group (see&nbsp;<Ref Sect="Elements of Finitely Presented Groups"/>).
A subgroup was never a parent group, and it was possible to create
subgroups only of parent groups.
<P/>
In &GAP;&nbsp;4 this common roof is provided already by the concept of
<E>families</E>, see&nbsp;<Ref Sect="Families" BookName="ref"/>.
Thus it is no longer compulsory to use parent groups at all.
On the other hand, parents <E>may</E> be used in &GAP;&nbsp;4 to provide
information about an object, for example the normalizer of a group in its
parent group may be stored as an attribute value.
Note that there is no restriction on the supergroup that is set to be
the parent,
it is possible to create a subgroup of
any group, this group then being the parent of the new subgroup.
This permits for example chains of subgroups with respective parents,
of arbitrary length.
<P/>
As a consequence, the <C>Parent</C> command cannot be used in &GAP;&nbsp;4 to
test whether the two arguments of <C>CommutatorSubgroup</C> fit together,
this is now a question that concerns the relation between the families
of the groups.  So the 2-argument version of <C>Parent</C> and the now
meaningless function <C>IsParent</C> have been abolished.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Homomorphisms vs. General Mappings">
<Heading>Homomorphisms vs. General Mappings</Heading>

In &GAP;&nbsp;3 there had been a confusion between group homomorphisms and
general mappings, as <C>GroupHomomorphismByImages</C> created only a
general mapping that did <E>not</E> store whether it was a mapping.  This
caused expensive, unwanted, and unnecessary tests whether the mapping
was in fact a group homomorphism.  Moreover, the <Q>official</Q>
workaround to set some components of the mapping record was quite
unwieldy.
<P/>
In &GAP;&nbsp;4, <C>GroupHomomorphismByImages</C> checks whether the desired
mapping is indeed a group homomorphism; if so then this property is
stored in the returned mapping, otherwise <K>fail</K> is returned.  If you
want to avoid the checks then you can use
<C>GroupHomomorphismByImagesNC</C>.  If you want to check whether a general
mapping that respects the group operations is really a group
homomorphism, you can construct it via <C>GroupGeneralMappingByImages</C>
and then call <C>IsGroupHomomorphism</C> for it.  (Note that
<C>IsGroupHomomorphism</C> returns <K>true</K> if and only if both
<C>IsGroupGeneralMapping</C> and <C>IsMapping</C> do, so one does in fact check
<C>IsMapping</C> in this case.)
<P/>
There is <E>no</E> function <C>IsHomomorphism</C> in &GAP;&nbsp;4,
since there are several different operations with respect to which a
mapping can be a homomorphism.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Homomorphisms vs. Factor Structures">
<Heading>Homomorphisms vs. Factor Structures</Heading>

If <M>F</M> is a factor structure of <M>G</M>, with kernel <M>N</M>, complete
information about the connection between <M>F</M> and <M>G</M> is provided by
the <E>natural homomorphism</E>.
<P/>
In &GAP;&nbsp;3, the <Q>official way</Q> to construct this natural homomorphism
was to create first the factor structure <M>F</M>, and then to call
<C>NaturalHomomorphism</C> with the arguments <M>G</M> and <M>F</M>.
For that, the data necessary to compute the homomorphism was stored in
<M>F</M> when <M>F</M> was constructed.
<P/>
In &GAP;&nbsp;4, factor structures are not treated in a special way,
in particular they do not store information about a homomorphism.
Instead, the more natural way is taken to construct the natural
homomorphism from <M>G</M> and <M>N</M> by <C>NaturalHomomorphismByNormalSubgroup</C>
if <M>N</M> is a normal subgroup of the group <M>G</M>,
or by <C>NaturalHomomorphismByIdeal</C> if <M>N</M> is an ideal in the ring <M>G</M>.
The factor <M>F</M> can then be accessed as the image of this homomorphism,
and of course <M>G</M> is the preimage and <M>N</M> is the kernel.
<P/>
Note that &GAP;&nbsp;4 does not guarantee anything about the representation
of the factor <M>F</M>, it may be a permutation group or a polycyclically
presented group or another kind of group.
Also note that a natural homomorphism need not be surjective.
<P/>
A consequence of this change is that &GAP;&nbsp;4 does <E>not</E> allow you to
construct a natural homomorphism from the groups <M>G</M> and <M>F</M>.
<P/>
The other common type of homomorphism in &GAP; 3, <Q>operation
homomorphisms</Q>, have been replaced (just a name change) by <E>action
homomorphisms</E>, which are handled in a similar fashion.  That is, an
action homomorphism is constructed from an acting group, an action
domain, and a function describing the operation.  The permutation
group arising by the induced action is then the image of this
operation homomorphism.
<P/>
The &GAP;&nbsp;3 function <C>Operation</C> is still supported, under the name <C>Action</C>,
but from the original group and the result of <C>Action</C> it is not
possible to construct the action homomorphism.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Isomorphisms vs. Isomorphic Structures">
<Heading>Isomorphisms vs. Isomorphic Structures</Heading>

In &GAP;&nbsp;3, a different representation of a group could be obtained by
calling <C>AgGroup</C> to get an isomorphic polycyclically presented group,
<C>PermGroup</C> to get an isomorphic permutation group, and so on.
The returned objects stored an isomorphism in the record component
<C>bijection</C>.
<P/>
For the same reason as in&nbsp;<Ref Sect="Homomorphisms vs. Factor Structures"/>,
&GAP;&nbsp;4 puts emphasis on the isomorphism,
and the isomorphic object in the desired representation can be accessed
as its image.
So you can call <C>IsomorphismPcGroup</C> or <C>IsomorphismPermGroup</C> in order
to get an isomorphism to a polycyclically presented group or a
permutation group, respectively, and then call <C>Image</C> to get the
isomorphic group.
<P/>
Note that the image of an action homomorphism with trivial kernel is
also an isomorphic permutation group, but an action homomorphism need
not be surjective, since it may be easier to define it into the full
symmetric group.
<P/>
Further note that in &GAP;&nbsp;3, a usual application of isomorphisms to
polycyclically presented groups was to utilize the usually more
effective algorithms for solvable groups.  However, the new concept of
polycyclic generating systems in &GAP;&nbsp;4 makes it possible to apply
these algorithms to arbitrary solvable groups, independent of the
representation.  For example, &GAP;&nbsp;4 can handle polycyclic
generating systems of solvable permutation groups.  So in many cases,
a change of the representation for efficiency reasons may be not
necessary any longer.
<P/>
In general <C>IsomorphismFpGroup</C> will define a presentation on generators
chosen by the algorithm. The corresponding elements of the original
group can be obtained by the command
<P/>
<Log><![CDATA[
gens:=List(GeneratorsOfGroup(Image(isofp)),i->PreImagesRepresentative(isofp,i));
]]></Log>
<P/>
If a presentation in the given generators is needed, the command
<C>IsomorphismFpGroupByGenerators(<A>G</A>, <A>gens</A>)</C> will produce one.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Elements of Finitely Presented Groups">
<Heading>Elements of Finitely Presented Groups</Heading>

Strictly speaking, &GAP;&nbsp;3 did not support elements of finitely
presented groups.  Instead, the <Q>words in abstract generators</Q> of
the underlying free groups were (mis)used.  This caused problems
whenever calculations with elements were involved, the most obvious
ones being wrong results of element comparisons.  Also functions
that should in principle work for any group were not applicable to
finitely presented groups.  In effect, a finitely presented group had
to be treated in a special way in &GAP;&nbsp;3.
<P/>
&GAP;&nbsp;4 distinguishes free groups and their elements from finitely
presented groups and their elements.  Comparing two elements of a
finitely presented group will yield either the correct result or no
result at all.
<P/>
Note that in &GAP;&nbsp;4, the arithmetic and comparison operations for
group elements do not depend on a context provided by a group that
contains the elements.  In particular, in &GAP;&nbsp;4 it is not
meaningful to call <C>Order( <A>G</A>, <A>g</A> )</C> for a group <A>G</A> and an element
<A>g</A>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Polynomials">
<Heading>Polynomials</Heading>

In &GAP;&nbsp;3, polynomials were defined over a field. So a polynomial over
<C>GF(3)</C> was different from a polynomial over <C>GF(9)</C>, even if the
coefficients were exactly the same.
<P/>
&GAP;&nbsp;4 defines polynomials only over a characteristic. This makes it
possible for example to multiply a polynomial over <C>GF(3)</C> with a polynomial
over <C>GF(9)</C> without the need to convert the former to the larger field.
<P/>
However it has an effect on the result of <C>DefaultRing</C> for polynomials:
In &GAP;&nbsp;3 the default ring for a polynomial was the polynomial ring of the
field over which the polynomial was defined. In &GAP;&nbsp;4 no field is
associated, so (to avoid having to define the algebraic closure as the only
other sensible alternative) the default ring of a polynomial is the
<C>DefaultRing</C> of its coefficients.
<P/>
This has an effect on <C>Factors</C>: If no ring is given, a polynomial is
factorized over its <C>DefaultRing</C> and so <C>Factors(<A>poly</A>)</C>
might return different results.
<P/>
To be safe from this problem, if you are not working over prime fields,
rather call <C>Factors(<A>pring</A>,<A>poly</A>)</C> with the appropriate polynomial ring
and change your code accordingly.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="The Info Mechanism">
<Heading>The Info Mechanism</Heading>

Sometimes it is useful to get information about the progress of a
calculation.
Many &GAP; functions contain statements to display such information
under certain conditions.
<P/>
In &GAP;&nbsp;3, these statements were calls to functions such as
<C>InfoGroup1</C> or <C>InfoGroup2</C>, and if the user assigned <C>Print</C> to
these variables then this had the effect to switch on the printing of
information.
<C>InfoGroup2</C> was used for more detailed information than <C>InfoGroup1</C>.
One could switch off the printing again by assigning <C>Ignore</C> to the
variables, and <C>Ignore</C> was also the default value.
<P/>
&GAP;&nbsp;4 uses one function <C>Info</C> for the same purpose,
which is a function that takes as first argument an <E>info class</E> such as
<C>InfoGroup</C>, as second argument an <E>info level</E>, and the print statements
as remaining arguments.
The level of an info class <A>class</A> is set to <A>level</A> by calling
<C>SetInfoLevel( <A>class</A>, <A>level</A> )</C>.
An <C>Info</C> statement is printed only if its second argument is smaller than
or equal to the current info level.
<P/>
<Example><![CDATA[
gap> test:= function( obj )
> Info( InfoGroup, 2, "This is useful, isn't it?" );
> return obj;
> end;;
gap> test( 1 );
1
gap> SetInfoLevel( InfoGroup, 2 );
gap> test( 1 );
#I  This is useful, isn't it?
1
]]></Example>
<P/>
As in &GAP;&nbsp;3, if an info statement is ignored then its arguments are
not evaluated.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Debugging">
<Heading>Debugging</Heading>

<Index Key="Backtrace"><C>Backtrace</C></Index>
<Index Key="DownEnv"><C>DownEnv</C></Index>
<Index Key="Where"><C>Where</C></Index>
If &GAP;&nbsp;4 runs into an error or is interrupted,
it enters a break loop.
The command <C>Where( <A>number</A> )</C>, which replaces <C>Backtrace</C> of &GAP;&nbsp;3,
can be used to display <A>number</A> lines of information about the current
function call stack.
<P/>
As in &GAP;&nbsp;3, access is only possible to the variables of the current
level in the function stack,
but in &GAP;&nbsp;4 the function <C>DownEnv</C>, with a positive or negative
integer as argument, permits one to step down or up in the
stack.
<P/>
When interrupting, the first line printed by <C>Where</C> actually may be
one level higher, as shown below.
<P/>
<Log><![CDATA[
gap> OnBreak := function() Where(0); end;; # eliminate back-tracing on
gap>                                       # entry to break loop
gap> test:= function( n )
>    if n > 3 then Error( "!\n" ); fi; test( n+1 ); end;;
gap> test( 1 );
Error, !
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> Where();
 called from
test( n + 1 ); called from
test( n + 1 ); called from
test( n + 1 ); called from
<function>( <arguments> ) called from read-eval-loop
brk> n;
4
brk> DownEnv();
brk> n;
3
brk> Where();  
 called from
test( n + 1 ); called from
test( n + 1 ); called from
<function>( <arguments> ) called from read-eval-loop
brk> DownEnv( 2 );
brk> n;
1
brk> Where();     
 called from
<function>( <arguments> ) called from read-eval-loop
brk> DownEnv( -2 );
brk> n;
3
brk> quit;
gap> OnBreak := Where;; # restore OnBreak to its default value
]]></Log>
<P/>
For purposes of debugging, it can be helpful sometimes, to see what
information is stored within an object. In &GAP;&nbsp;3 this was possible using
<C>RecFields</C> because the objects in question were represented via records.
For component objects, &GAP;&nbsp;4 permits the same by
<C>NamesOfComponents( <A>object</A> )</C>, which will list all components present.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Compatibility Mode">
<Heading>Compatibility Mode</Heading>

For users who want to use &GAP;&nbsp;3 code with as little changes as
possible, a compatibility mode is provided by &GAP;&nbsp;4.
This mode must be turned on explicitly by the user.
<P/>
It should be noted that this compatibility mode has not been tested
thoroughly.
<P/>
The compatibility mode can be turned on by loading some of the following
files with <C>ReadLib</C>.
The different files address different aspects of compatibility.
<P/>
<List>
<Mark><C>compat3a.g</C> </Mark>
<Item>
    makes some &GAP;&nbsp;3 function names available that were changed
    in &GAP;&nbsp;4,
    and provides code for some &GAP;&nbsp;3 features that were
    deliberately left out from the &GAP;&nbsp;4 library.
    For example,
    almost all variable names concerning character theory that are
    mentioned in the &GAP;&nbsp;3 manual,
    such as <C>CharTable</C> and <C>SubgroupFusions</C>,
    are available after <C>compat3a.g</C> has been read;
    the only exceptions are names of operations records.
</Item>
<Mark><C>compat3b.g</C> </Mark>
<Item>
    implements the availability of <Q>components</Q> of domains;
    besides components that have no meaning for the rest of the &GAP;&nbsp;4
    library, such as <C><A>D</A>.myInfo</C>, there are components associated to
    attributes; for example <C><A>D</A>.size</C> is redirected to the call of the
    attribute <C>Size</C>, <C>IsBound( <A>D</A>.size )</C> to the call of its tester,
    and <C><A>D</A>.size:= <A>val</A></C> to the call of its setter.
    (An important special case is the component <C>operations</C>, see below.)
</Item>
<Mark><C>compat3c.g</C> </Mark>
<Item>
    permits you to implement your own elements represented as records,
    and using operations records to provide a <C>Print</C> method and
    the basic arithmetic operations.
    When using operations records, it is probably a good idea to
    use <E>immutable</E> operations records; for example, if the results
    of arithmetic operations are records with operations records then
    this avoids to create shallow copies of the operations records 
    in the call to <C>Immutable</C> for the results.
</Item>
</List>
<P/>
The following features are accessible only via starting &GAP; with
the command line option <C>-O</C> and may damage some features of &GAP;&nbsp;4
permanently for the current session. 
<P/>
 With this option, also the files listed above are read automatically.
<P/>
<List>
<Mark><C>compat3d.g</C> </Mark>
<Item>
    provides some &GAP;&nbsp;3 functions like <C>Domain</C>, simulates the
    &GAP;&nbsp;3 behaviour of <C>IsString</C> (to convert a list to string
    representation if possible), and replaces <K>fail</K> by <K>false</K>;
    these changes destroy parts of the functionality of &GAP;&nbsp;4.
</Item>
</List>
<P/>
Some words concerning the simulation of operations records may be
necessary.
<P/>
The operations records of the &GAP;&nbsp;3 library, such as <C>DomainOps</C>
and <C>GroupOps</C>, are available <E>only</E> for access to their components,
whose values are &GAP;&nbsp;4 operations; for example, the value of both
<C>DomainOps.Size</C> and <C>GroupOps.Size</C> is the operation <C>Size</C>.  So it
is <E>not</E> safely possible to delegate from a <C>Size</C> method in another
operations record to <C>DomainOps.Size</C>.  Also it is not possible to
change these predefined operations records.
<P/>
If one wants to install individual methods for a given object <A>obj</A>
via the mechanism of operations records then one can construct a new
operations record with <C>OperationsRecord</C>, assign the desired methods
to components of this record, and then assign the operations record to
<C><A>obj</A>.operations</C>.  Whenever an operation that is associated with a
component <A>nam</A> of the operations record is called with <A>obj</A> as first
argument, the value of <A>nam</A> is chosen as the method.
<P/>
In the case of the binary operations <C>=</C>, <C>&lt;</C>, <C>+</C>, <C>-</C>, <C>*</C>, <C>/</C>,
<C>Comm</C>, and <C>LeftQuotient</C>,
this also happens if <A>obj</A> is the right-hand argument.
As in &GAP;&nbsp;3, if both arguments of one of the above binary operations
have operations records containing a function for this operation,
then the function in the operations record of the right-hand argument
is chosen.
<P/>
We give a small example how the compatibility mode works.
<P/>
Suppose we want to deal with new objects that are derived from known
field elements by distorting their multiplication.  Namely, let <M>a'</M>
and <M>b'</M> be the new objects corresponding to the field elements <M>a</M>,
<M>b</M>, and define <M>a' * b' = a b - a - b + 2</M>.
<P/>
In &GAP;&nbsp;3, this problem was solved by representing each new object
by a record that stored the corresponding <Q>old</Q> object and an
operations record, where the latter was a record containing the
functions applicable to the new object.  After the library file
<C>compat3c.g</C> has been read, we can use this construction of the
operations record and of the new objects.  Note that operations
records must be created with the function <C>OperationsRecord</C> (this was
also the norm in &GAP;&nbsp;3), starting with an empty record would not work.
For our intended application, we thus start with the following two
lines of code.
<P/>
<Log><![CDATA[
gap> ReadLib( "compat3c.g" );
gap> MyOps:= OperationsRecord( "MyOps" );; 
HasMyOps := NewFilter( "HasMyOps" );
]]></Log>
<P/>
In order to make the translation from &GAP;&nbsp;3 code to &GAP;&nbsp;4
easier, &GAP; prints the definition of filters associated with
operations records and the method installations for operations
corresponding to components of the operations records.  The output
line printed by &GAP; after the call of <C>OperationsRecord</C> is one
such case.
<P/>
Now we add our multiplication function to the operations record,
and again &GAP;&nbsp;4 prints a translation to &GAP;&nbsp;4 code.
<P/>
<Log><![CDATA[
gap> MyOps.\* := function( a, b )
>        return rec( x:= a.x * b.x - a.x - b.x + 2,
>                    operations := MyOps );
>    end;;
# If the following method installation matches the requirements
# of the operation `PROD' then `InstallMethod' should be used.
# It might be useful to replace the rank `SUM_FLAGS' by `0'.
InstallOtherMethod( PROD,
    "for object with `MyOps' as first argument",
    true,
    [ HasMyOps, IsObject ], SUM_FLAGS,
    MyOps.\* );

# For binary infix operators, a second method is installed
# for the case that the object with `MyOps' is the right operand;
# since this case has higher priority in GAP 3, the method is
# installed with higher rank `SUM_FLAGS + 1'.
InstallOtherMethod( PROD,
    "for object with `MyOps' as second argument",
    true,
    [ IsObject, HasMyOps ], SUM_FLAGS + 1,
    MyOps.\* );
]]></Log>
<P/>
Let us look how this installation works.
<P/>
<Log><![CDATA[
gap> a:= rec( x:= 3, operations:= MyOps );
rec( x := 3, operations := MyOps )
gap> b:= rec( x:= 5, operations:= MyOps );
rec( x := 5, operations := MyOps )
gap> a * b;
rec( x := 9, operations := MyOps )
]]></Log>
<P/>
(In more complicated cases, we might run into problems, but this was
already the case in &GAP;&nbsp;3.  For example, suppose we want to support
the multiplication of two operands having different operations
records; then it is not clear which of the two multiplication
functions is to be chosen, and in &GAP;&nbsp;3, the only way out was to
change the multiplication functions, in order to make them aware of
such situations.)
<P/>
If we are now interested to translate the code to &GAP;&nbsp;4 in the
sense that no compatibility mode is needed, we can use what &GAP;&nbsp;4
has printed above.  (The same example is dealt with in
Chapter&nbsp;<Ref Chap="An Example -- Designing Arithmetic Operations" BookName="ref"/>.)
<P/>
The objects will no longer be records with <C>operations</C> component.
Instead of records we may use so-called component objects
with record-like access to components, 
and instead of the <C>operations</C> component, we give the objects a
type that has the filter <C>HasMyOps</C> set.
<P/>
<Log><![CDATA[
HasMyOps := NewFilter( "HasMyOps" );
MyType := NewType( NewFamily( "MyFamily" ),
                   HasMyOps and IsComponentObjectRep );
]]></Log>
<P/>
(More about families and representations in this context can be found
in the chapter of <Q>Programming in &GAP;</Q> mentioned above.)
<P/>
The next step is to write a function that creates a new object.
It may look as follows.
<P/>
<Log><![CDATA[
MyObject := function( val )
    return Objectify( MyType, rec( x:= val ) );
end;
]]></Log>
<P/>
The multiplication function shall return an object with the
filter <C>HasMyOp</C>, so we change it as follows.
<P/>
<Log><![CDATA[
gap> MyMult := function( a, b )                          
>        return MyObject( x:= a!.x * b!.x - a!.x - b!.x + 2 );
>    end;; 
]]></Log>
<P/>
Note that the component access for these objects
works via <C>!.</C> instead of <C>.</C>;
further note that no operations record needs to appear here,
the filter takes its role.
<P/>
Finally, we install the multiplication for at least one argument
with the new filter, as had been printed by &GAP;&nbsp;4 in the
session shown above.
<P/>
<Log><![CDATA[
InstallOtherMethod( PROD,
    "for object with `MyOps' as first argument",
    true,
    [ HasMyOps, IsObject ], 0,
    MyMult );

InstallOtherMethod( PROD,
    "for object with `MyOps' as second argument",
    true,
    [ IsObject, HasMyOps ], 1,
    MyMult );
]]></Log>
<P/>
And now it works (again).
<P/>
<Log><![CDATA[
gap> a:= MyObject( 3 );
<object>
gap> b:= MyObject( 5 );
<object>
gap> a * b;
<object>
gap> last!.x
9
]]></Log>
<P/>
We may install a method to print our objects in a nice way;
we could have done this for the operations record <C>MyOps</C>
in the compatibility mode,
the printed output would look similar to the following.
<P/>
<Log><![CDATA[
InstallOtherMethod( PRINT_OBJ,
    "for object with `MyOps' as first argument",
    true,
    [ HasMyOps ], 0,
    function( obj ) Print( "MyObject( ", obj!.x, " )" ); end );
]]></Log>
<P/>
Now output looks as follows.
<P/>
<Log><![CDATA[
gap> a;  b;  a * b;
MyObject( 3 )
MyObject( 5 )
MyObject( 9 )
]]></Log>
<P/>
Maybe now we want to improve the installation.
The multiplication function we want to use is apparently
thought only for the case that <E>both</E> operands have
the filter <C>HasMyOps</C> (and a component <C>x</C>).
So it is reasonable to replace the two methods for
the multiplication by one method for which both arguments
are required to have the filter.
<P/>
<Log><![CDATA[
InstallOtherMethod( PROD,
    "for two objects with `MyOps'",
    true,
    [ HasMyOps, HasMyOps ], 0,
    MyMult );
]]></Log>
<P/>
At first sight, the &GAP;&nbsp;4 approach seems to be much more
complicated.
But the last example shows that in &GAP;&nbsp;4,
each method can be installed more specifically for the appropriate
situation.
Moreover, it is for example possible to install a method
for the multiplication of an integer and a <C>HasMyOps</C> object;
note that --contrary to the situation in &GAP;&nbsp;3--
such a method is independent from already existing methods
in the sense that these need not be changed when
new functionality is added.
<P/>
Another example that uses this part of the compatibility mode can be
found in the file <F>tst/compat3.tst</F> of the &GAP;&nbsp;4 distribution.

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->

