%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  objselms.tex              GAP manual                    Thomas Breuer
%W                                                       Martin Schoenert
%%
%H  @(#)$Id$
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Objects and Elements}

An *object* is everything in {\GAP} that can be assigned to a variable,
so nearly everything in {\GAP} is an object.

Different objects can be regarded as equal w.r.t. the equivalence
relation '`='',
in this case we say that the objects describe the same *element*.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Objects}

Nearly all things one deals with in {\GAP} are *objects*.
For example, an integer is an object, as is a list of integers, a matrix,
a permutation, a function, a list of functions, a group,
a coset or a conjugacy class in a group.

Examples of things that are not objects are
comments which are only lexical constructs,
`while' loops which are only syntactical constructs,
and expressions, such as `1 + 1';
but note that the value of an expression, in this case the integer '2',
is an object.

Objects can be assigned to variables,
and everything that can be assigned to a variable is an object.
Analogously, objects can be used as arguments of functions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Elements}

The equality operation '`='' defines an equivalence relation on all
{\GAP} objects.
The equivalence classes are called *elements*.

There are basically three reasons to regard different objects as equal.
Firstly, the same information may be stored in different places.
Secondly, the same information may be stored in different ways;
for example, a polynomial can be stored sparsely or densely.
Thirdly, different information may be equal modulo a mathematical
equivalence relation;
for example, in a finitely presented group with the relation $a^2 = 1$
the different objects $a$ and $a^3$ describe the same element.

As an example for all three aspects, consider the possibility to store
an integer in several places of the memory,
to represent it as a fraction with denominator 1,
or to represent it as a fraction with any denominator, with numerator
a suitable multiple of it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Domains}

A *domain* in {\GAP} is a structured set.
Domains are objects.

For example, every group is a domain, every conjugacy class of elements
in a group is a domain, every coset in a group is a domain.

Domains are the most important objects in {\GAP}.
In a sense, the only reason to introduce objects such as integers and
permutations in {\GAP} is the wish to form domains of them.

Domains have an *operational structure*,
that is, a collection of operations under that the domain is closed.
For example, a group is closed under multiplication,
taking the zeroth power of elements, and taking inverses of elements.

The operations under that a domain is closed are a subset of
the operations that the elements of a domain admit.
It is possible that the elements admit more operations.
For example, matrices can be multiplied and added.
But addition plays no role in a group of matrices,
and multiplication plays no role in a vector space of matrices.
Especially, a matrix group is not closed under addition.

Note that the elements of a domain exist independently of this domain,
usually they existed already before the domain was created.
So it makes sense to say that a domain is *generated* by some elements
with respect to certain operations.

Of course, different sets of operations yield different notions of
generation.
For example, the group generated by some matrices is different from
the ring generated by these matrices, and these two will be in general
different from the vector space generated by the same matrices,
over a suitable field.

Additionally to the operational structure,
a domain can have properties.
For example, the multiplication of a group is associative,
and the multiplication in a field is commutative.

Note that associativity and commutativity depend on the set of
elements for which one considers the multiplication,
i.e., it depends on the domain.
For example, the multiplication in a full matrix ring over a field
is not commutative, whereas its restriction to the set of diagonal
matrices is commutative.

One important difference between the operational structure and the
properties of a domain is that the operational structure is fixed when
the domain is constructed, whereas properties can be found out later.
For example, take a domain whose operational structure is given by
closure under multiplication.
Also if it is found out that by chance also the inverses of all elements
lie in this domain,
being closed under taking inverses is not added to the operational
structure.
But a domain with operational structure multiplication,
taking the identity, and taking inverses
will be treated as a group as soon as the multiplication is found out to
be associative for this domain.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Identical Objects}

Two objects that are equal *as objects* and not only w.r.t. the equality
relation '`='' are called *identical*.
So identical objects do of course describe the same element.

Usually one may deal with objects but think of elements,
because one is not interested in places in memory, ways of storing,
and information beyond underlying equivalence relations.

But there are cases where it is important to distinguish the relations
identity and equality.
This is best illustrated with an example.
\beginexample
    gap> l1:= [ 1, 2, 3 ];; l2:= [ 1, 2, 3 ];;
    gap> l1 = l2;
    true
    gap> IsIdentical( l1, l2 );
    false
    gap> l1[3]:= 4;; l1; l2;
    [ 1, 2, 4 ]
    [ 1, 2, 3 ]
    gap> l1 = l2;
    false
\endexample
The two lists `l1' and `l2' are equal but not identical.
Thus a change in `l1' does not affect `l2'.
\beginexample
    gap> l1:= [ 1, 2, 3 ];; l2:= l1;;
    gap> l1 = l2;
    true
    gap> IsIdentical( l1, l2 );
    true
    gap> l1[3]:= 4;; l1; l2;
    [ 1, 2, 4 ]
    [ 1, 2, 4 ]
    gap> l1 = l2;
    true
\endexample
Here, `l1' and `l2' are identical objects,
so changing `l1' means to change also `l2'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Mutability and Copyability}

For many purposes, *mutable* objects are useful.
One example are mutable lists,
they can be changed by assigning values to positions
or by unbinding values at certain positions.
Similarly, one can assign values to components of a mutable record,
or unbind them.

In other situations, however,
one wants to ensure that certain objects are *immutable*,
i. e., that they cannot be changed.
For example, take the identity of a matrix group.
Since this matrix may be referred to as identity of the group in several
places, it would be fatal to modify its entries, or add or unbind rows.

An immutable copy of an object <obj> is obtained as

\>Immutable( <obj> )

The subobjects of `Immutable( <obj> )' are immutable copies of the
subobjects of <obj>.
If <obj> is immutable then `Immutable' returns <obj> itself.

Conversely, if {\GAP} supports a mutable form of an object <obj>
then this is obtained as

\>ShallowCopy( <obj> )

The subobjects of `ShallowCopy( <obj> )' are *identical* to the
subobjects of <obj>.
Note that the object returned by `ShallowCopy' is always a new object,
especially it is not identical with the argument <obj>,
no matter whether <obj> is mutable or immutable.

Further note that it is not possible to turn a mutable object into an
immutable one or vice versa,
only mutable resp. immutable copies can be made.
With this approach,
it is possible to store an immutable identity matrix
or an immutable list of generators,
and to make a mutable copy whenever it is needed.
Compared to the situation without immutable objects,
much unnecessary copying is avoided this way.
Another advantage of immutability is
that lists of immutable objects may store whether they are sorted,
which is not possible for lists of mutable objects.

Objects for which only an immutable form exists in {\GAP}
are called *constants*.
Examples of constants are integers, permutations, and domains.
Called with a constant as argument,
`Immutable' and `ShallowCopy' return this argument.

If both a mutable and an immutable form of an object can be made in
{\GAP}, the object is called *copyable*.
Examples of copyable objects are of course lists and records.
Given an immutable matrix <mat>,
`ShallowCopy' returns a mutable matrix whose rows are identical with the
rows of <mat>,
especially the rows are immutable.
To get a matrix whose rows are mutable,
one can use `List( <mat>, ShallowCopy )'.

Another interesting example of mutable objects is provided by
*iterators*, see "Iterators".
Every call of `NextIterator' changes the iterator until it is exhausted,
and this is the only possibility to change an iterator.

Many operations return immutable results.
Among them are all arithmetic operations,
such as `Zero', `One', `AdditiveInverse', `Inverse', `Comm',
and the infix operations `+', `-', `*', `/', `^', `mod'.
So the product of two matrices or of a vector and a matrix is immutable,
no matter whether the arguments are mutable or immutable.

In a few situations,
one wants to make a *structural copy* <scp> of an object <obj>.
This is defined as follows.
<scp> and <obj> are identical if <obj> is immutable.
Otherwise, <scp> is a mutable copy of <obj> such that
each subobject of <scp> is a structural copy of the corresponding
subobject of <obj>.
Furthermore, if two subobjects of <obj> are identical then
also the corresponding subobjects of <scp> are identical. 

Here is an example.
\beginexample
    gap> obj:= [ [ 0, 1 ] ];;
    gap> obj[2]:= obj[1];;
    gap> obj[3]:= Immutable( obj[1] );;
    gap> scp:= StructuralCopy( obj );;
    gap> scp = obj; IsIdentical( scp, obj );
    true
    false
    gap> IsIdentical( scp[1], obj[1] );
    false
    gap> IsIdentical( scp[3], obj[3] );
    true
    gap> IsIdentical( scp[1], scp[2] );
    true
\endexample

Note that being immutable does not forbid an object to store knowledge.
For example, if it is found out that an immutable list is strictly
sorted then the list may store this information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E
