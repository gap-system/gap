%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  ratfun.msk                  GAP documentation            Alexander Hulpke
%A                                                           Frank Celler
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
\Chapter{Polynomials and Rational Functions}

Let $R$ be a commutative ring-with-one. We call a free associative
algebra $A$ over $R$ a *polynomial ring* over $R$. The free generators of
$A$ are called *indeterminates*, they are usually denoted by
$x_1,x_2,\ldots$. The number of indeterminates is called the *rank* of $A$.
The elements of $A$ are called *polynomials*. Products of
indeterminates are called *monomials*, every
polynomial can be expressed as a finite sum of products of monomials with
ring elements in a form like
$r_{1,0}x_1+r_{1,1}x_1x_2+r_{0,1}x_2+\cdots$ with $r_{i,j}\in R$.

A polynomial ring of rank 1 is called an *univariate* polynomial ring, its
elements are *univariate polynomials*.

Polynomial rings of smaller rank naturally embed in rings of higher rank; if
$S$ is a subring of $R$ then a polynomial ring over $S$ naturally embeds in
a polynomial ring over $R$ of the same rank. Note however that {\GAP} does
not consider $R$ as a subset of a polynomial ring over $R$; for example the
zero of $R$ ($0$) and the zero of the polynomial ring ($0x^0$) are different
objects.

Internally, indeterminates are represented by positive integers, but it is
possible to give names to them to have them printed in a nicer way. Beware,
however that there is not necessarily any relation between the way an
indeterminate is called and the way it is printed. See section
"Indeterminates" for details.

If $R$ is an integral domain, the polynomial ring $A$ over $R$ is an integral domain as well and one can
therefore form its quotient field $Q$. This field is called a *field of
rational functions*. Again $A$ embeds naturally into $Q$ and {\GAP} will
perform this embedding implicitly. (In fact it implements the ring of rational
functions over $R$.) To avoid problems with leading
coefficients, however, $R$ must be a unique factorization domain.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Indeterminates}

\FileHeader{ringpoly}[2]

\Declaration{Indeterminate}
\beginexample
gap> a:=Indeterminate(GF(3));
x_1
gap> x:=Indeterminate(GF(3),"x");
x
gap> Indeterminate(GF(3),"x")=x;
false
gap> y:=Indeterminate(GF(3),"y");z:=Indeterminate(GF(3),"X");
y
X
gap> Indeterminate(GF(3),3);
y
gap> Indeterminate(GF(3),[y,z]);
x
\endexample

\Declaration{IndeterminateNumberOfUnivariateRationalFunction}
\Declaration{IndeterminateOfUnivariateRationalFunction}
\beginexample
gap> IndeterminateNumberOfUnivariateRationalFunction(z);
4
gap> IndeterminateOfUnivariateRationalFunction(z^5+z);
X
\endexample

\Declaration{IndeterminateName}
\beginexample
gap> IndeterminateName(FamilyObj(x),3);
"y"
gap> HasIndeterminateName(FamilyObj(x),5);
false
gap> SetIndeterminateName(FamilyObj(x),10,"bla");
gap> Indeterminate(GF(3),10);
bla
\endexample

As a convenience there is a special method installed for `SetName' that will
assign a name to an indeterminate.
\beginexample
gap> a:=Indeterminate(GF(3),5);
x_5
gap> SetName(a,"ah");
gap> a^5+a;
ah^5+ah
\endexample

\Declaration{CIUnivPols}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Rational Functions}

The rational functions form a field,
therefore all arithmetic operations are applicable to rational functions.

\>`<f> + <g>'{addition!rational functions}
\>`<f> - <g>'{subtraction!rational functions}
\>`<f> * <g>'{product!rational functions}
\>`<f> / <g>'{quotient!rational functions}

\beginexample
gap> x:=Indeterminate(Rationals,1);;y:=Indeterminate(Rationals,2);;
gap> f:=3+x*y+x^5;;g:=5+x^2*y+x*y^2;;
gap> a:=g/f;
(x_1^2*x_2+x_1*x_2^2+5)/(x_1^5+x_1*x_2+3)
\endexample

Note that the quotient `<f>/<g>' of two polynomials might be represented as
a rational function again. If <g> is known to divide <f> the call
`Quotient(<f>,<g>)' (see~"Quotient") should be used instead.

\>`<f> mod <g>'{mod!Laurent polynomials}
%\>`<f> mod <int>'{mod!integer polynomial}

For two Laurent polynomials <f> and <g>, `<f> mod <g>' is the Euclidean
remainder (see~"EuclideanRemainder") of <f> modulo <g>.
% For a polynomial <f> over the integers and an integer <int>, `<f> mod <int>'
% is the polynomial over the integers obtained by reducing the coefficients
% of <f> modulo <int>.
% Just a remark:
% These two methods would not be compatible if integers would be regarded
% as constant polynomials.
% Therefore, I leave the second method undocumented.

At the moment {\GAP} does not contain a proper multivariate Gcd algorithm.
Therefore it cannot be guaranteed that rational functions will always be
represented as a quotient of coprime polynomials. In certain unfortunate
situations this might lead to a degree explosion.

All polynomials as well as all the univariate polynomials in the same
indeterminate form subrings of this field. If two rational functions are
known to be in the same subring, the result will be expressed as element in
this subring.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comparison of Rational Functions}

\>`<f> = <g>'{comparison!rational functions}

Two rational functions <f> and <g> are equal if the product
$`Numerator'(<f>)*`Denominator'(<g>)$ equals
$`Numerator'(<g>)*`Denominator'(<f>)$.

\beginexample
gap> x:=Indeterminate(Rationals,"x");;y:=Indeterminate(Rationals,"y");;
gap> f:=3+x*y+x^5;;g:=5+x^2*y+x*y^2;;
gap> a:=g/f;
(x^2*y+x*y^2+5)/(x^5+x*y+3)
gap> b:=(g*f)/(f^2);
(x^7*y+x^6*y^2+5*x^5+x^3*y^2+x^2*y^3+3*x^2*y+3*x*y^2+5*x*y+15)/(x^10+2*x^6*y+6\
*x^5+x^2*y^2+6*x*y+9)
gap> a=b;
true
\endexample

\>`<f> \< <g>'{smaller!rational functions}

The ordering of rational functions is defined in several steps. Monomials
(products of indeterminates) are sorted first by degree, then
lexicographically (with $x_1>x_2$)
(see~"MonomialGrlexOrdering"). Products of monomials
with ring elements (``terms'') are compared first by their monomials and
then by their coefficients.

\beginexample
gap> x>y;
true
gap> x^2*y<x*y^2;
false
gap> x*y<x^2*y;
true
gap> x^2*y < 5* y*x^2;
true
\endexample
Polynomials are compared by comparing the largest terms in turn until they
differ.
\beginexample
gap> x+y<y;
false
gap> x<x+1;
true
\endexample
Rational functions are compared by comparing the polynomial
$`Numerator'(<f>)*`Denominator'(<g>)$ with the polynomial
$`Numerator'(<g>)*`Denominator'(<f>)$. (As the ordering of monomials used by
{\GAP} is invariant under multiplication this is independent of common
factors in numerator and denominator.)
\beginexample
gap> f/g<g/f;
false
gap> f/g<(g*g)/(f*g);
false
\endexample

For univariate polynomials this reduces to an ordering first by total degree
and then lexicographically on the coefficients.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Properties and Attributes of Rational Functions}

\Declaration{IsPolynomialFunction}

\Declaration{NumeratorOfRationalFunction}
\Declaration{DenominatorOfRationalFunction}
\beginexample
gap> x:=Indeterminate(Rationals,1);;y:=Indeterminate(Rationals,2);;
gap> DenominatorOfRationalFunction((x*y+x^2)/y);
y
gap> NumeratorOfRationalFunction((x*y+x^2)/y);
x^2+x*y
\endexample

\Declaration{IsPolynomial}
\beginexample
gap> IsPolynomial((x*y+x^2*y^3)/y);
true
gap> IsPolynomial((x*y+x^2)/y);
false
\endexample

\Declaration{AsPolynomial}
\beginexample
gap> AsPolynomial((x*y+x^2*y^3)/y);
x^2*y^2+x
\endexample

\Declaration{IsUnivariateRationalFunction}
\Declaration{CoefficientsOfUnivariateRationalFunction}

\Declaration{IsUnivariatePolynomial}
\Declaration{CoefficientsOfUnivariatePolynomial}

\Declaration{IsLaurentPolynomial}
The attribute `CoefficientsOfLaurentPolynomial'
(see~"CoefficientsOfLaurentPolynomial") gives a compact representation as
Laurent polynomial.

\Declaration{IsConstantRationalFunction}

All these tests are applicable to *every* rational function. Depending on the
internal representation of the rational function, however some of these
tests (in particular, univariateness) might be expensive in some cases.

For reasons of performance within algorithms it can be useful to use other
attributes, which give a slightly more technical representation. See
section~"The Representations of Rational Functions" for details.

\Declaration{IsPrimitivePolynomial}
\Declaration{SplittingField}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Univariate Polynomials}

Some of the operations are actually defined on the larger domain of Laurent
polynomials (see "Laurent Polynomials"). For this section you can simply
ignore the word ``Laurent'' if it occurs in a description.

\Declaration{UnivariatePolynomial}
\Declaration{UnivariatePolynomialByCoefficients}
\Declaration{DegreeOfLaurentPolynomial}
\beginexample
gap> p:=UnivariatePolynomial(Rationals,[1,2,3,4],1);
4*x^3+3*x^2+2*x+1
gap> UnivariatePolynomialByCoefficients(FamilyObj(1),[9,2,3,4],73);
4*x_73^3+3*x_73^2+2*x_73+9
gap> CoefficientsOfUnivariatePolynomial(p);
[ 1, 2, 3, 4 ]
gap> DegreeOfLaurentPolynomial(p);
3
gap> IndeterminateNumberOfLaurentPolynomial(p);
1
gap> IndeterminateOfLaurentPolynomial(p);
x
\endexample

We remark that some functions for multivariate polynomials (which will be
defined in the following sections) permit a different syntax for univariate
polynomials which drops the requirement to specify the indeterminate.
Examples are `Value', `Discriminant', `Derivative', `LeadingCoefficient' and
`LeadingMonomial':
\beginexample
gap> Value(p,Z(5));
Z(5)^2
gap> LeadingCoefficient(p);
4
gap> Derivative(p);
12*x^2+6*x+2
\endexample

\Declaration{RootsOfUPol}
\beginexample
gap> RootsOfUPol(50-45*x-6*x^2+x^3);
[ 10, 1, -5 ]
\endexample

\Declaration{UnivariatenessTestRationalFunction}

The info class for univariate polynomials is `InfoPoly'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Polynomials as Univariate Polynomials in one Indeterminate}

\Declaration{DegreeIndeterminate}
\beginexample
gap> f:=x^5+3*x*y+9*y^7+4*y^5*x+3*y+2;
9*y^7+4*x*y^5+x^5+3*x*y+3*y+2
gap> DegreeIndeterminate(f,1);
5
gap> DegreeIndeterminate(f,y);
7
\endexample

\Declaration{PolynomialCoefficientsOfPolynomial}
\beginexample
gap> PolynomialCoefficientsOfPolynomial(f,2);
[ x^5+2, 3*x+3, 0, 0, 0, 4*x, 0, 9 ]
\endexample

\Declaration{LeadingCoefficient}
\Declaration{LeadingMonomial}
\beginexample
gap> LeadingCoefficient(f,1);
1
gap> LeadingCoefficient(f,2);
9
gap> LeadingMonomial(f);
[ 2, 7 ]
gap> LeadingCoefficient(f);
9
\endexample

\Declaration{Derivative}
\beginexample
gap> Derivative(f,2);
63*y^6+20*x*y^4+3*x+3
\endexample
\Declaration{Discriminant}
\beginexample
gap> Discriminant(f,1);
20503125*y^28+262144*y^25+27337500*y^22+19208040*y^21+1474560*y^17+13668750*y^\
16+18225000*y^15+6075000*y^14+1105920*y^13+3037500*y^10+6489720*y^9+4050000*y^\
8+900000*y^7+62208*y^5+253125*y^4+675000*y^3+675000*y^2+300000*y+50000
\endexample

\Declaration{Resultant}
\beginexample
gap> Resultant(x^4+y,y^4+x,1);
y^16+y
gap> Resultant(x^4+y,y^4+x,2);
x^16+x
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Multivariate Polynomials}

\Declaration{Value}
\beginexample
gap> Value(x*y+y+x^7,[x,y],[5,7]);
78167
\endexample
Note that the default values for `one' can lead to different results than
one would expect: For example for a matrix $M$, the values $M+M^0$ and $M+1$
are *different*. As `Value' defaults to the one of the coefficient ring,
when evaluating Matrices in polynomials always the correct `one' should be
given!

\Declaration{OnIndeterminates}
\beginexample
gap> OnIndeterminates(x^7*y+x*y^4,(1,17)(2,28));
x_17^7*x_28+x_17*x_28^4
gap> Stabilizer(Group((1,2,3,4),(1,2)),x*y,OnIndeterminates);
Group([ (1,2), (3,4) ])
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Minimal Polynomials}

\indextt{MinimalPolynomial!over a ring}
\Declaration{MinimalPolynomial}
\beginexample
gap> MinimalPolynomial(Rationals,[[2,0],[0,2]]);
x-2
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Cyclotomic Polynomials}

\Declaration{CyclotomicPolynomial}
\beginexample
gap> CyclotomicPolynomial(Rationals,5);
x^4+x^3+x^2+x+1
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Polynomial Factorization}

At the moment {\GAP} provides only methods to factorize univariate
polynomials over finite fields (see Chapter~"Finite Fields") and
over subfields of cyclotomic fields (see Chapter~"Abelian Number Fields").

\>Factors([<R>,]<upoly>[,<opt>])!{of univariate polynomial}

returns a list of the irreducible factors of the univariate polynomial
<upoly> in the polynomial ring <R>. (That is factors over the
`CoefficientsRing' of <R>.)

It is possible to pass a record <opt> as a third
argument. This record can contain the following components:
\beginitems
`onlydegs'&is a set of positive integers. The factorization assumes
that all irreducible factors have a degree in this set.

`stopdegs'&is a set of positive integers. The factorization will stop once a
factor of degree in `stopdegs' has been found and will return the
factorization found so far.
\enditems

\beginexample
gap> f:= CyclotomicPolynomial( GF(2), 7 );
x_1^6+x_1^5+x_1^4+x_1^3+x_1^2+x_1+Z(2)^0
gap> Factors( f );
[ x_1^3+x_1+Z(2)^0, x_1^3+x_1^2+Z(2)^0 ]
gap> Factors( PolynomialRing( GF(8) ), f );
[ x_1+Z(2^3), x_1+Z(2^3)^2, x_1+Z(2^3)^3, x_1+Z(2^3)^4, x_1+Z(2^3)^5, 
  x_1+Z(2^3)^6 ]
gap> f:= MinimalPolynomial( Rationals, E(4) );
x^2+1
gap> Factors( f );
[ x^2+1 ]
gap> Factors( PolynomialRing( Rationals ), f );
[ x^2+1 ]
gap> Factors( PolynomialRing( CF(4) ), f );
[ x+-E(4), x+E(4) ]
\endexample

\Declaration{FactorsSquarefree}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Polynomials over the Rationals}

The following functions are only available to polynomials with rational
coefficients:

\Declaration{PrimitivePolynomial}

\Declaration{PolynomialModP}
\Declaration{GaloisType}
\Declaration{ProbabilityShapes}
\beginexample
gap> f:=x^9-9*x^7+27*x^5-39*x^3+36*x-8;;
gap> GaloisType(f);
25
gap> TransitiveGroup(9,25);
[1/2.S(3)^3]3
gap> ProbabilityShapes(f);
[ 25 ]
\endexample

The following operations are used by {\GAP} inside the factorization algorithm
but might be of interest also in other contexts.
\Declaration{BombieriNorm}
\Declaration{MinimizedBombieriNorm}
\Declaration{HenselBound}
\Declaration{OneFactorBound}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Laurent Polynomials}

A univariate polynomial can be written in the form $r_0+r_1x+\cdots+r_nx^n$
with $r_i\in R$.  Formally, there is no reason to start with 0, if $m$ is an
integer, we can consider objects of the form
$r_mx^m+r_{m+1}x^{m+1}+\cdots+r_nx^n$. We call these *Laurent polynomials*.
Laurent polynomials also can be considered as quotients of a univariate
polynomial by a power of the indeterminate.  The addition and multiplication
of univariate polynomials extends to Laurent polynomials (though it might be
impossible to interpret a Laurent polynomial as a function) and many
functions for univariate polynomials extend to Laurent polynomials (or
extended versions for Laurent polynomials exist).

\Declaration{LaurentPolynomialByCoefficients}
\Declaration{CoefficientsOfLaurentPolynomial}
\beginexample
gap> p:=LaurentPolynomialByCoefficients(FamilyObj(1),
> [1,2,3,4,5],-2);
5*x^2+4*x+3+2*x^-1+x^-2
gap> NumeratorOfRationalFunction(p);DenominatorOfRationalFunction(p);
5*x^4+4*x^3+3*x^2+2*x+1
x^2
gap> CoefficientsOfLaurentPolynomial(p*p);
[ [ 1, 4, 10, 20, 35, 44, 46, 40, 25 ], -4 ]
\endexample

\Declaration{IndeterminateNumberOfLaurentPolynomial}

\Declaration{QuotRemLaurpols}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Univariate Rational Functions}

\Declaration{UnivariateRationalFunctionByCoefficients}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Polynomial Rings}

While polynomials depend only on the family of the coefficients, polynomial
rings $A$ are defined over a base ring $R$. A polynomial is an element of
$A$ if and only if all its coefficients are contained in $R$. Besides
providing domains and an easy way to create polynomials, polynomial rings
can affect the behavior of operations like factorization into irreducibles.

\Declaration{PolynomialRing}
\Declaration{IndeterminatesOfPolynomialRing}
\Declaration{CoefficientsRing}
\beginexample
gap> r:=PolynomialRing(GF(7));
PolynomialRing(..., [ x_1 ])
gap>  r:=PolynomialRing(GF(7),3);
PolynomialRing(..., [ x_1, x_2, x_3 ])
gap> IndeterminatesOfPolynomialRing(r);
[ x_1, x_2, x_3 ]
gap> r2:=PolynomialRing(GF(7),[5,7,12]);
PolynomialRing(..., [ x_5, x_7, x_12 ])
gap> CoefficientsRing(r);
GF(7)
gap> r:=PolynomialRing(GF(7),3);
PolynomialRing(..., [ x_1, x_2, x_3 ])
gap> r2:=PolynomialRing(GF(7),3,IndeterminatesOfPolynomialRing(r));
PolynomialRing(..., [ x_4, x_5, x_6 ])
gap> r:=PolynomialRing(GF(7),["x","y","z","z2"]);
PolynomialRing(..., [ x, y, z, z2 ])
\endexample

If you need to work with a polynomial ring and its indeterminates the
following two approaches will produce a ring that contains given variables
(see section~"Indeterminates" for details about the internal numbering):
Either, first create the ring and then get the indeterminates as
`IndeterminatesOfPolynomialRing'. 

\beginexample
gap> r := PolynomialRing(Rationals,["x","y"]);;
gap> indets := IndeterminatesOfPolynomialRing(r);;
gap> x := indets[1]; y := indets[2];
x
y
\endexample

Alternatively, first create the
indeterminates and then create the ring including these indeterminates.
\beginexample
gap> x:=X(Rationals,"x");;y:=X(Rationals,"y");;
gap> PolynomialRing(Rationals,[x,y]);;
\endexample

As a convenient shortcut, intended mainly for interactive working, the
indeterminates of a polynomial ring 'r' can be accessed as 'r.<i>',
which corresponds exactly to `IndeterminatesOfPolynomialRing(r)[<i>]'
or, if they have names, as 'r.<name>'. *Note* that the number <i> is
*not* an indeterminate number, but simply an index into the
indeterminates list of `r';

\beginexample
gap> r := PolynomialRing(Rationals, ["x", "y"] );;
gap> r.1; r.2; r.x; r.y;
x
y
x
y
gap> IndeterminateNumberOfLaurentPolynomial(r.1);
7
\endexample


As {\GAP} objects polynomials can exist without a polynomial ring being
defined and polynomials cannot be associated to a particular polynomial
ring. (For example dividing a polynomial which is in a polynomial ring over
the integers by another integer will result in a polynomial over the
rationals, not in a rational function over the integers.)

\Declaration{IsPolynomialRing}
\Declaration{IsFiniteFieldPolynomialRing}
\Declaration{IsAbelianNumberFieldPolynomialRing}
\Declaration{IsRationalsPolynomialRing}

\beginexample
gap> IsPolynomialRing(r);
true
gap> IsFiniteFieldPolynomialRing(r);
false
gap> IsRationalsPolynomialRing(r);
true
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Univariate Polynomial Rings}

\Declaration{UnivariatePolynomialRing}
\Declaration{IsUnivariatePolynomialRing}
\beginexample
gap> r:=UnivariatePolynomialRing(Rationals,"x");
PolynomialRing(..., [ x ])
gap> r2:=PolynomialRing(Rationals,["q"]);
PolynomialRing(..., [ q ])
gap> IsUnivariatePolynomialRing(r);
true
gap> IsUnivariatePolynomialRing(r2);
true
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Monomial Orderings}

It is often desirable to consider the monomials within a polynomial to be
arranged with respect to a certain ordering. Such an ordering is called a
*monomial ordering* if it is total, invariant under multiplication with
other monomials and admits no infinite descending chains. For details on
monomial orderings see \cite{coxlittleoshea}.

In {\GAP}, monomial orderings are represented by objects that provide a way
to compare monomials (as polynomials as well as -- for efficiency purposes
within algorithms -- in the internal representation as lists). 

Normally the ordering chosen should be *admissible*, i.e. it
must be compatible with products: If $a\<b$ then $ca\<cb$ for all monomials
$a,b$ and $c$.

\Declaration{IsMonomialOrdering}
\Declaration{LeadingMonomialOfPolynomial}
\beginexample
gap> x:=X(Rationals,"x");;y:=X(Rationals,"y");;z:=X(Rationals,"z");;
gap> lexord:=MonomialLexOrdering();grlexord:=MonomialGrlexOrdering();
MonomialLexOrdering()
MonomialGrlexOrdering()
gap> f:=2*x+3*y+4*z+5*x^2-6*z^2+7*y^3;          
7*y^3+5*x^2-6*z^2+2*x+3*y+4*z
gap> LeadingMonomialOfPolynomial(f,lexord);
x^2
gap> LeadingMonomialOfPolynomial(f,grlexord);
y^3
\endexample

\Declaration{LeadingTermOfPolynomial}
\Declaration{LeadingCoefficientOfPolynomial}
\beginexample
gap> LeadingTermOfPolynomial(f,lexord);
5*x^2
gap> LeadingTermOfPolynomial(f,grlexord);
7*y^3
gap> LeadingCoefficientOfPolynomial(f,lexord);
5
\endexample

Each monomial ordering provides two functions to compare monomials. These
functions work as ``is less than'', i.e. they return `true' if and only if
the left argument is smaller.

\Declaration{MonomialComparisonFunction}
\beginexample
gap> MonomialComparisonFunction(lexord);
function( a, b ) ... end
gap> l:=[f,Derivative(f,x),Derivative(f,y),Derivative(f,z)];;
gap> Sort(l,MonomialComparisonFunction(lexord));l;
[ -12*z+4, 21*y^2+3, 10*x+2, 7*y^3+5*x^2-6*z^2+2*x+3*y+4*z ]
\endexample

\Declaration{MonomialExtrepComparisonFun}

The following monomial orderings are predefined in {\GAP}:

\Declaration{MonomialLexOrdering}

\beginexample
gap> l:=List(Tuples([1..3],3),i->x^(i[1]-1)*y^(i[2]-1)*z^(i[3]-1));
[ 1, z, z^2, y, y*z, y*z^2, y^2, y^2*z, y^2*z^2, x, x*z, x*z^2, x*y, x*y*z, 
  x*y*z^2, x*y^2, x*y^2*z, x*y^2*z^2, x^2, x^2*z, x^2*z^2, x^2*y, x^2*y*z, 
  x^2*y*z^2, x^2*y^2, x^2*y^2*z, x^2*y^2*z^2 ]
gap> Sort(l,MonomialComparisonFunction(MonomialLexOrdering()));l;
[ 1, z, z^2, y, y*z, y*z^2, y^2, y^2*z, y^2*z^2, x, x*z, x*z^2, x*y, x*y*z, 
  x*y*z^2, x*y^2, x*y^2*z, x*y^2*z^2, x^2, x^2*z, x^2*z^2, x^2*y, x^2*y*z, 
  x^2*y*z^2, x^2*y^2, x^2*y^2*z, x^2*y^2*z^2 ]
gap> Sort(l,MonomialComparisonFunction(MonomialLexOrdering([y,z,x])));l;
[ 1, x, x^2, z, x*z, x^2*z, z^2, x*z^2, x^2*z^2, y, x*y, x^2*y, y*z, x*y*z, 
  x^2*y*z, y*z^2, x*y*z^2, x^2*y*z^2, y^2, x*y^2, x^2*y^2, y^2*z, x*y^2*z, 
  x^2*y^2*z, y^2*z^2, x*y^2*z^2, x^2*y^2*z^2 ]
gap> Sort(l,MonomialComparisonFunction(MonomialLexOrdering([z,x,y])));l;
[ 1, y, y^2, x, x*y, x*y^2, x^2, x^2*y, x^2*y^2, z, y*z, y^2*z, x*z, x*y*z, 
  x*y^2*z, x^2*z, x^2*y*z, x^2*y^2*z, z^2, y*z^2, y^2*z^2, x*z^2, x*y*z^2, 
  x*y^2*z^2, x^2*z^2, x^2*y*z^2, x^2*y^2*z^2 ]
\endexample

\Declaration{MonomialGrlexOrdering}
\Declaration{MonomialGrevlexOrdering}

\beginexample
gap> Sort(l,MonomialComparisonFunction(MonomialGrlexOrdering()));l;
[ 1, z, y, x, z^2, y*z, y^2, x*z, x*y, x^2, y*z^2, y^2*z, x*z^2, x*y*z, 
  x*y^2, x^2*z, x^2*y, y^2*z^2, x*y*z^2, x*y^2*z, x^2*z^2, x^2*y*z, x^2*y^2, 
  x*y^2*z^2, x^2*y*z^2, x^2*y^2*z, x^2*y^2*z^2 ]
gap> Sort(l,MonomialComparisonFunction(MonomialGrevlexOrdering()));l;
[ 1, z, y, x, z^2, y*z, x*z, y^2, x*y, x^2, y*z^2, x*z^2, y^2*z, x*y*z, 
  x^2*z, x*y^2, x^2*y, y^2*z^2, x*y*z^2, x^2*z^2, x*y^2*z, x^2*y*z, x^2*y^2, 
  x*y^2*z^2, x^2*y*z^2, x^2*y^2*z, x^2*y^2*z^2 ]
gap> Sort(l,MonomialComparisonFunction(MonomialGrlexOrdering([z,y,x])));l;
[ 1, x, y, z, x^2, x*y, y^2, x*z, y*z, z^2, x^2*y, x*y^2, x^2*z, x*y*z, 
  y^2*z, x*z^2, y*z^2, x^2*y^2, x^2*y*z, x*y^2*z, x^2*z^2, x*y*z^2, y^2*z^2, 
  x^2*y^2*z, x^2*y*z^2, x*y^2*z^2, x^2*y^2*z^2 ]
\endexample

\Declaration{EliminationOrdering}

\Declaration{PolynomialReduction}
\Declaration{PolynomialReducedRemainder}
\Declaration{PolynomialDivisionAlgorithm}
\beginexample
gap> bas:=[x^3*y*z,x*y^2*z,z*y*z^3+x];;
gap> pol:=x^7*z*bas[1]+y^5*bas[3]+x*z;;                                        
gap> PolynomialReduction(pol,bas,MonomialLexOrdering()); 
[ -y*z^5, [ x^7*z, 0, y^5+z ] ]
gap> PolynomialReducedRemainder(pol,bas,MonomialLexOrdering());
-y*z^5
gap> PolynomialDivisionAlgorithm(pol,bas,MonomialLexOrdering());
[ -y*z^5, [ x^7*z, 0, y^5+z ] ]
\endexample

\Declaration{MonomialExtGrlexLess}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Groebner Bases}

A *Groebner Basis* of an ideal $I$i, in a polynomial ring $R$, with
respect to a monomial ordering, is a set of ideal generators <G> such that
the ideal generated by the leading monomials of all polynomials in <G> is
equal to the ideal generated by the leading monomials of all polynomials
in <I>.

For more details on Groebner bases see \cite{coxlittleoshea}.

\Declaration{GroebnerBasis}
\beginexample
gap> l:=[x^2+y^2+z^2-1,x^2+z^2-y,x-y];;
gap> GroebnerBasis(l,MonomialLexOrdering());
[ x^2+y^2+z^2-1, x^2+z^2-y, x-y, -y^2-y+1, -z^2+2*y-1, 1/2*z^4+2*z^2-1/2 ]
gap> GroebnerBasis(l,MonomialLexOrdering([z,x,y]));
[ x^2+y^2+z^2-1, x^2+z^2-y, x-y, -y^2-y+1 ]
gap> GroebnerBasis(l,MonomialGrlexOrdering());
[ x^2+y^2+z^2-1, x^2+z^2-y, x-y, -y^2-y+1, -z^2+2*y-1 ]
\endexample

\Declaration{ReducedGroebnerBasis}
\beginexample
gap> ReducedGroebnerBasis(l,MonomialGrlexOrdering());
[ x-y, z^2-2*y+1, y^2+y-1 ]
gap> ReducedGroebnerBasis(l,MonomialLexOrdering());    
[ z^4+4*z^2-1, -1/2*z^2+y-1/2, -1/4*z^2+x-1/4 ]
gap> ReducedGroebnerBasis(l,MonomialLexOrdering([y,z,x]));
[ 1, x^2+x-1, z^2-x+1/2, -x+y ]
\endexample

\Declaration{StoredGroebnerBasis}

\Declaration{InfoGroebner}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Rational Function Families}

All rational functions defined over a ring lie in the same family, the
rational functions family over this ring.

In {\GAP} therefore the family of a polynomial depends only on the family of
the coefficients, all polynomials whose coefficients lie in the same family
are ``compatible''.

\Declaration{RationalFunctionsFamily}
\Declaration{IsPolynomialFunctionsFamily}
%notest
\beginexample
gap> fam:=RationalFunctionsFamily(FamilyObj(1));
NewFamily( "RationalFunctionsFamily(...)", [ 618, 620 ],
[ 82, 85, 89, 93, 97, 100, 103, 107, 111, 618, 620 ] )
\endexample

\Declaration{CoefficientsFamily}

{\GAP} does *not* embed the base ring in the polynomial ring. While
multiplication and addition of base ring elements to rational functions
return the expected results, polynomials and rational functions are not
equal.
\beginexample
gap> 1=Indeterminate(Rationals)^0;
false
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The Representations of Rational Functions}

{\GAP} uses four representations of rational functions: Rational
functions given by numerator and denominator, polynomials, univariate
rational functions (given by coefficient lists for numerator and denominator
and valuation) and
Laurent polynomials (given by coefficient list and valuation).

These representations do not necessarily reflect mathematical properties:
While an object in the Laurent polynomials representation must be a
Laurent polynomial it might turn out that a rational function given by
numerator and denominator is actually a Laurent polynomial and the property
tests in section~"Properties and Attributes of Rational Functions" will find
this out.

Each representation is associated one or several ``defining attributes''
that give an ``external'' representation
(see~"The Defining Attributes of Rational Functions")
of the representation in the form of lists and are the defining information
that tells a rational function what it is.

{\GAP} also implements methods to compute these attributes for rational
functions in *other* representations, provided it would be possible to
express an *mathematically equal* rational function in the representation
associated with the attribute. (That is one can always get a
numerator/denominator representation of a polynomial while an arbitrary
function of course can compute a polynomial representation only if it is a
polynomial.)

Therefore these attributes can be thought of as ``conceptual''
representations that allow us -- as far as possible --
to consider an object as a rational function, a polynomial or a Laurent
polynomial, regardless of the way it is represented in the computer.

Functions thus usually do not need to care about the representation of
a rational function. Depending on its (known in the context or determined)
properties, they can access the attribute representing the rational function
in the desired way.

Consequentially, methods for rational functions are installed for properties
and not for representations.

When *creating* new rational functions however they must be created in one
of the three representations. In most cases this will be the representation
for which the ``conceptual'' representation in which the calculation was done
is the defining attribute.

Iterated operations (like forming the product over a list) therefore will
tend to stay in the most suitable representation and the calculation of
another conceptual representation (which may be comparatively expensive in
certain circumstances) is not necessary.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The Defining Attributes of Rational Functions}

In general, rational functions are given in terms of monomials. They are
represented by lists, using numbers (see~"Indeterminates") for the
indeterminates.

\FileHeader{ratfun}[4]
\FileHeader{ratfun}[1]

\Declaration{IsRationalFunctionDefaultRep}
\Declaration{ExtRepNumeratorRatFun}
\Declaration{ExtRepDenominatorRatFun}
\Declaration{ZeroCoefficientRatFun}

\Declaration{IsPolynomialDefaultRep}
\Declaration{ExtRepPolynomialRatFun}

\Declaration{IsLaurentPolynomialDefaultRep}
The attributes that give a representation of a a rational function as a Laurent polynomial are
`CoefficientsOfLaurentPolynomial' (see~"CoefficientsOfLaurentPolynomial")
and `IndeterminateNumberOfUnivariateRationalFunction'
(see~"IndeterminateNumberOfUnivariateRationalFunction").

\FileHeader{ratfun}[2]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creation of Rational Functions}

\FileHeader{ratfun}[3]

\Declaration{RationalFunctionByExtRep}
\Declaration{PolynomialByExtRep}
\beginexample
gap> fam:=RationalFunctionsFamily(FamilyObj(1));;
gap> p:=PolynomialByExtRep(fam,[[1,2],1,[2,1,15,7],3]);
3*y*x_15^7+x^2
gap> q:=p/(p+1);
(3*y*x_15^7+x^2)/(3*y*x_15^7+x^2+1)
gap> ExtRepNumeratorRatFun(q);
[ [ 1, 2 ], 1, [ 2, 1, 15, 7 ], 3 ]
gap> ExtRepDenominatorRatFun(q);
[ [  ], 1, [ 1, 2 ], 1, [ 2, 1, 15, 7 ], 3 ]
\endexample
\Declaration{LaurentPolynomialByExtRep}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Arithmetic for External Representations of Polynomials}

The following operations are used internally to perform the arithmetic for
polynomials in their ``external'' representation
(see~"The Defining Attributes of Rational Functions")
as lists.
\Declaration{ZippedSum}
\Declaration{ZippedProduct}
\Declaration{QuotientPolynomialsExtRep}

Functions to perform arithmetic with the coefficient lists of Laurent
polynomials are described in section~"Coefficient List Arithmetic".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Cancellation Tests for Rational Functions}

{\GAP} does not contain a multivariate GCD algorithm. The following
operations are used internally to try to keep the denominators as small as
possible

\Declaration{RationalFunctionByExtRepWithCancellation}
\Declaration{TryGcdCancelExtRepPolynomials}
\Declaration{HeuristicCancelPolynomials}
