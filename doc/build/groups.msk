%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  groups.msk                  GAP documentation            Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
\Chapter{Groups}

This chapter explains how to create groups and defines operations for
groups, that is operations whose definition does not depend on the
representation used.
However methods for these operations in most cases will make use of the
representation.

If not otherwise specified, in all examples in this chapter the group `g'
will be the symmetric group $S_4$ acting on the letters $\{1,\ldots,4\}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group Elements}

Groups in {\GAP} are written multiplicatively.
The elements from which a group can be generated must permit
multiplication and multiplicative inversion
(see~"Useful Categories of Elements").

\beginexample
gap> a:=(1,2,3);;b:=(2,3,4);;
gap> One(a);
()
gap> Inverse(b);
(2,4,3)
gap> a*b;
(1,3)(2,4)
gap> Order(a*b);
2
gap> Order( [ [ 1, 1 ], [ 0, 1 ] ] );
infinity
\endexample

The next example may run into an infinite loop
because the given matrix in fact has infinite order.

%notest
\beginexample
gap> Order( [ [ 1, 1 ], [ 0, 1 ] ] * Indeterminate( Rationals ) );
#I  Order: warning, order of <mat> might be infinite
\endexample

\index{order! of a group}
Since groups are domains, the recommended command to compute the order
of a group is `Size' (see~"Size").
For convenience, group orders can also be computed with `Order'.

The operation `Comm' (see~"Comm") can be used to compute the commutator of
two elements, the operation `LeftQuotient' (see~"LeftQuotient") computes the
product $x^{-1}y$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Groups}

When groups are created from generators,
this means that the generators must be elements that can be multiplied
and inverted (see also~"Constructing Domains").
For creating a free group on a set of symbols, see~"FreeGroup".

\Declaration{Group}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
\endexample

\Declaration{GroupWithGenerators}
\Declaration{GeneratorsOfGroup}
\beginexample
gap> g:=GroupWithGenerators([(1,2,3,4),(1,2)]);
Group([ (1,2,3,4), (1,2) ])
gap> GeneratorsOfGroup(g);
[ (1,2,3,4), (1,2) ]
\endexample
While in this example {\GAP} displays the group via the generating set
stored in the attribute `GeneratorsOfGroup', the methods installed for
`View' (see~"View") will in general display only some information about the
group which may even be just the fact that it is a group.

\Declaration{AsGroup}
\beginexample
gap> AsGroup([(1,2)]);
fail
gap> AsGroup([(),(1,2)]);
Group([ (1,2) ])
\endexample

\Declaration{ConjugateGroup}
\beginexample
gap> ConjugateGroup(g,(1,5));
Group([ (2,3,4,5), (2,5) ])
\endexample

\Declaration{IsGroup}
\beginexample
gap> IsGroup(g);
true
\endexample

\Declaration{InfoGroup}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroups}

For the general concept of parents and subdomains,
see~"Parents" and~"Constructing Subdomains".
More functions that construct certain subgroups can be found
in the sections~"Normal Structure", "Specific and Parametrized Subgroups",
"Sylow Subgroups and Hall Subgroups",
and~"Subgroups characterized by prime powers".

\Declaration{Subgroup}
\beginexample
gap> u:=Subgroup(g,[(1,2,3),(1,2)]);
Group([ (1,2,3), (1,2) ])
\endexample

\Declaration{Index}
\beginexample
gap> Index(g,u);
4
\endexample


\Declaration{IndexInWholeGroup}

\Declaration{AsSubgroup}
\beginexample
gap> v:=AsSubgroup(g,Group((1,2,3),(1,4)));
Group([ (1,2,3), (1,4) ])
gap> Parent(v);
Group([ (1,2,3,4), (1,2) ])
\endexample

\Declaration{IsSubgroup}
\beginexample
gap> IsSubgroup(g,u);
true
gap> v:=Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> u=v;
true
gap> IsSubgroup(g,v);
true
\endexample

\Declaration{IsNormal}
\beginexample
gap> IsNormal(g,u);
false
\endexample

\Declaration{IsCharacteristicSubgroup}
\beginexample
gap> IsCharacteristicSubgroup(g,u);
false
\endexample

\Declaration{ConjugateSubgroup}
\Declaration{ConjugateSubgroups}

\Declaration{IsSubnormal}
\beginexample
gap> IsSubnormal(g,Group((1,2,3)));
false
gap> IsSubnormal(g,Group((1,2)(3,4)));
true
\endexample

\FileHeader{grp}[2]

\Declaration{SubgroupByProperty}
\Declaration{SubgroupShell}
\beginexample
gap> u:=SubgroupByProperty(g,i->3^i=3);
<subgrp of Group([ (1,2,3,4), (1,2) ]) by property>
gap> (1,3) in u; (1,4) in u; (1,5) in u;
false
true
false
gap> GeneratorsOfGroup(u);
[ (1,2), (1,4,2) ]
gap> u:=SubgroupShell(g);
<group>
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Closures of (Sub)groups}

\Declaration{ClosureGroup}
\beginexample
gap> g:=SmallGroup(24,12);;u:=Subgroup(g,[g.3,g.4]);
Group([ f3, f4 ])
gap> ClosureGroup(u,g.2);
Group([ f2, f3, f4 ])
gap> ClosureGroup(u,[g.1,g.2]);
Group([ f1, f2, f3, f4 ])
gap> ClosureGroup(u,Group(g.2*g.1));
Group([ f1*f2^2, f3, f4 ])
\endexample

\Declaration{ClosureGroupAddElm}

\Declaration{ClosureGroupDefault}

\Declaration{ClosureSubgroup}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Expressing Group Elements as Words in Generators}

\index{factorization}
\index{words!in generators}

Using homomorphisms (see chapter~"Group Homomorphisms") is is possible to
express group elements as words in given generators: Create a free group
(see~"FreeGroup") on the correct number of generators and create a
homomorphism from this free group onto the group <G> in whose generators you
want to factorize. Then the preimage of an element of <G> is a word in the
free generators, that will map on this element again.

\Declaration{EpimorphismFromFreeGroup}

The following example shows how to decompose elements of $S_4$ in the
generators `(1,2,3,4)' and `(1,2)':

\beginexample
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
gap> hom:=EpimorphismFromFreeGroup(g:names:=["x","y"]);
[ x, y ] -> [ (1,2,3,4), (1,2) ]
gap> PreImagesRepresentative(hom,(1,4));
y^-1*x^-2*y^-1*x^-1*y^-1*x
\endexample

The following example stems from a real request to the {\GAP} Forum. In
September 2000 a {\GAP} user working with puzzles wanted to express the
permutation `(1,2)' as a word as short as possible in particular generators
of the symmetric group $S_{16}$.

\beginexample
gap> perms := [ (1,2,3,7,11,10,9,5), (2,3,4,8,12,11,10,6),
>   (5,6,7,11,15,14,13,9), (6,7,8,12,16,15,14,10) ];;
gap> puzzle := Group( perms );;Size( puzzle );
20922789888000
gap> hom:=EpimorphismFromFreeGroup(puzzle:names:=["a", "b", "c", "d"]);;
gap> word := PreImagesRepresentative( hom, (1,2) );
a^-1*c*b*c^-1*a*b^-1*a^-2*c^-1*a*b^-1*c*b
gap> Length( word );
13
\endexample

% randomization effect is now gone.

\Declaration{Factorization}

\beginexample
gap> G:=SymmetricGroup( 6 );;
gap> r:=(3,4);; s:=(1,2,3,4,5,6);;
gap> # create a subgroup to force the system to use the generators r and s.
gap> H:= Subgroup(G, [ r, s ] );
Group([ (3,4), (1,2,3,4,5,6) ])
gap> Factorization( H, (1,2,3) );
x2*x1*x2*x1*x2^-2
gap> s*r*s*r*s^-2;
(1,2,3)
gap> MappingGeneratorsImages(EpimorphismFromFreeGroup(H));
[ [ x1, x2 ], [ (3,4), (1,2,3,4,5,6) ] ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Structure Descriptions}

\Declaration{StructureDescription}

\beginexample
gap> l := AllSmallGroups(12);;
gap> List(l,StructureDescription);; l;
[ C3 : C4, C12, A4, D12, C6 x C2 ]
gap> List(AllSmallGroups(40),G->StructureDescription(G:short));
[ "5:8", "40", "5:8", "5:Q8", "4xD10", "D40", "2x(5:4)", "(10x2):2", "20x2",
  "5xD8", "5xQ8", "2x(5:4)", "2^2xD10", "10x2^2" ]
gap> List(AllTransitiveGroups(DegreeAction,6),G->StructureDescription(G:short));
[ "6", "S3", "D12", "A4", "3xS3", "2xA4", "S4", "S4", "S3xS3", "(3^2):4",
  "2xS4", "A5", "(S3xS3):2", "S5", "A6", "S6" ]
gap> StructureDescription(PSL(4,2));
"A8"
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Cosets}

\index{right cosets}

\index{coset}
\Declaration{RightCoset}
\beginexample
gap> u:=Group((1,2,3), (1,2));;
gap> c:=RightCoset(u,(2,3,4));
RightCoset(Group( [ (1,2,3), (1,2) ] ),(2,3,4))
gap> ActingDomain(c);
Group([ (1,2,3), (1,2) ])
gap> Representative(c);
(2,3,4)
gap> Size(c);
6
gap> AsList(c);
[ (2,3,4), (1,4,2), (1,3)(2,4), (2,4), (1,4,2,3), (1,3,4,2) ]
\endexample

\Declaration{RightCosets}
\beginexample
gap> RightCosets(g,u);
[ RightCoset(Group( [ (1,2,3), (1,2) ] ),()), 
  RightCoset(Group( [ (1,2,3), (1,2) ] ),(1,3)(2,4)), 
  RightCoset(Group( [ (1,2,3), (1,2) ] ),(1,4)(2,3)), 
  RightCoset(Group( [ (1,2,3), (1,2) ] ),(1,2)(3,4)) ]
\endexample

\Declaration{CanonicalRightCosetElement}
\beginexample
gap> CanonicalRightCosetElement(u,(2,4,3));
(3,4)
\endexample

\Declaration{IsRightCoset}

\index{left cosets}
{\GAP} does not provide left cosets as a separate data type, but as the left
coset $gU$ consists of exactly the inverses of the elements of the right
coset $Ug^{-1}$ calculations with left cosets can be emulated using right
cosets by inverting the representatives.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Transversals}

\Declaration{RightTransversal}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> u:=Subgroup(g,[(1,2,3),(1,2)]);;
gap> rt:=RightTransversal(g,u);
RightTransversal(Group([ (1,2,3,4), (1,2) ]),Group([ (1,2,3), (1,2) ]))
gap> Length(rt);
4
gap> Position(rt,(1,2,3));
fail
\endexample

Note that the elements of a right transversal are not necessarily
``canonical'' in the sense of `CanonicalRightCosetElement'
(see~"CanonicalRightCosetElement"), but we may compute a list of
canonical coset representatives by calling that function.

\beginexample
gap> List(RightTransversal(g,u),i->CanonicalRightCosetElement(u,i));
[ (), (2,3,4), (1,2,3,4), (3,4) ]
\endexample

The operation `PositionCanonical' is described in
section~"PositionCanonical".

\beginexample
gap> PositionCanonical(rt,(1,2,3));
1
gap> rt[1];
()
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Double Cosets}

\Declaration{DoubleCoset}
\Declaration{RepresentativesContainedRightCosets}
\beginexample
gap> u:=Subgroup(g,[(1,2,3),(1,2)]);;v:=Subgroup(g,[(3,4)]);;
gap> c:=DoubleCoset(u,(2,4),v);
DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(2,4),Group( [ (3,4) ] ))
gap> (1,2,3) in c;
false
gap> (2,3,4) in c;
true
gap> LeftActingGroup(c);
Group([ (1,2,3), (1,2) ])
gap> RightActingGroup(c);
Group([ (3,4) ])
gap> RepresentativesContainedRightCosets(c);
[ (2,3,4) ]
\endexample

\Declaration{DoubleCosets}!{operation}
\beginexample
gap> dc:=DoubleCosets(g,u,v);
[ DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(),Group( [ (3,4) ] )), 
  DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(1,3)(2,4),Group( [ (3,4) ] )), 
  DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(1,4)(2,3),Group( [ (3,4) ] )) ]
gap> List(dc,Representative);
[ (), (1,3)(2,4), (1,4)(2,3) ]
\endexample

\Declaration{IsDoubleCoset}
\Declaration{DoubleCosetRepsAndSizes}
\beginexample
gap> dc:=DoubleCosetRepsAndSizes(g,u,v);
[ [ (), 12 ], [ (1,3)(2,4), 6 ], [ (1,4)(2,3), 6 ] ]
\endexample

\Declaration{InfoCoset}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Conjugacy Classes}

\Declaration{ConjugacyClass}
\Declaration{ConjugacyClasses}[grp]!{attribute}
\beginexample
gap> g:=SymmetricGroup(4);;
gap> cl:=ConjugacyClasses(g);
[ ()^G, (1,2)^G, (1,2)(3,4)^G, (1,2,3)^G, (1,2,3,4)^G ]
gap> Representative(cl[3]);Centralizer(cl[3]);
(1,2)(3,4)
Group([ (1,2), (1,3)(2,4), (3,4) ])
gap> Size(Centralizer(cl[5]));
4
gap> Size(cl[2]);
6
\endexample

In general, you will not need to have to influence the method, but simply
call `ConjugacyClasses' -- GAP will try to select a suitable method on its
own. The method specifications are provided here mainly for expert use. 

\Declaration{ConjugacyClassesByRandomSearch}
\Declaration{ConjugacyClassesByOrbits}

Typically, for small groups (roughly of order up to $10^3$) the computation
of classes as orbits under the action is fastest; memory restrictions (and
the increasing cost of eliminating duplicates) make this less efficient for
larger groups.

Calculation by random search has the smallest memory requirement, but in
generally performs worse, the more classes are there.

The folowing example shows the effect of this for a small group with many
classes:

% this example is time and load-status dependent. No point in testing
\begintt
gap> h:=Group((4,5)(6,7,8),(1,2,3)(5,6,9));;ConjugacyClasses(h:noaction);;time;
110
gap> h:=Group((4,5)(6,7,8),(1,2,3)(5,6,9));;ConjugacyClasses(h:random);;time;
300
gap> h:=Group((4,5)(6,7,8),(1,2,3)(5,6,9));;ConjugacyClasses(h:action);;time;
30
\endtt

\Declaration{NrConjugacyClasses}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> NrConjugacyClasses(g);
5
\endexample

\Declaration{RationalClass}
\Declaration{RationalClasses}
\beginexample
gap> RationalClasses(DerivedSubgroup(g));
[ RationalClass( AlternatingGroup( [ 1 .. 4 ] ), () ), 
  RationalClass( AlternatingGroup( [ 1 .. 4 ] ), (1,2)(3,4) ), 
  RationalClass( AlternatingGroup( [ 1 .. 4 ] ), (1,2,3) ) ]
\endexample
\Declaration{GaloisGroup}[clas]!{of rational class of a group}

\Declaration{IsConjugate}
\beginexample
gap> IsConjugate(g,Group((1,2,3,4),(1,3)),Group((1,3,2,4),(1,2)));
true
\endexample

`RepresentativeAction' (see~"RepresentativeAction") can be used to
obtain conjugating elements.
\beginexample
gap> RepresentativeAction(g,(1,2),(3,4));
(1,3)(2,4)
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Normal Structure}

For the operations `Centralizer' and `Centre', see Chapter~"Magmas".
\index{normalizer}
\Declaration{Normalizer}
\beginexample
gap> Normalizer(g,Subgroup(g,[(1,2,3)]));
Group([ (1,2,3), (2,3) ])
\endexample

\Declaration{Core}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> Core(g,Subgroup(g,[(1,2,3,4)]));
Group(())
\endexample

\Declaration{PCore}
\beginexample
gap> PCore(g,2);
Group([ (1,4)(2,3), (1,3)(2,4) ])
\endexample

\Declaration{NormalClosure}
\beginexample
gap> NormalClosure(g,Subgroup(g,[(1,2,3)]));
Group([ (1,2,3), (1,3,4) ])
\endexample

\Declaration{NormalIntersection}
\beginexample
gap> NormalIntersection(Group((1,2)(3,4),(1,3)(2,4)),Group((1,2,3,4)));
Group([ (1,3)(2,4) ])
\endexample

\Declaration{Complementclasses}
\beginexample
gap> Complementclasses(g,Group((1,2)(3,4),(1,3)(2,4)));
[ Group([ (3,4), (2,4,3) ]) ]
\endexample

\Declaration{InfoComplement}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Specific and Parametrized Subgroups}

The Centre of a group (the subgroup of those elements that commute with all
other elements of the group) can be computed by the operation `Centre'
(see~"Centre").

\Declaration{TrivialSubgroup}
\beginexample
gap> TrivialSubgroup(g);
Group(())
\endexample

\Declaration{CommutatorSubgroup}
\beginexample
gap> CommutatorSubgroup(Group((1,2,3),(1,2)),Group((2,3,4),(3,4)));
Group([ (1,4)(2,3), (1,3,4) ])
gap> Size(last);
12
\endexample

\Declaration{DerivedSubgroup}
\beginexample
gap> DerivedSubgroup(g);
Group([ (1,3,2), (1,4,3) ])
\endexample

\Declaration{CommutatorLength}
\beginexample
gap> CommutatorLength( g );
1
\endexample

\Declaration{FittingSubgroup}
\beginexample
gap> FittingSubgroup(g);
Group([ (1,3)(2,4), (1,4)(2,3) ])
\endexample

\Declaration{FrattiniSubgroup}
\beginexample
gap> FrattiniSubgroup(g);
Group(())
\endexample

\Declaration{PrefrattiniSubgroup}
\beginexample
gap> G := SmallGroup( 60, 7 );
<pc group of size 60 with 4 generators>
gap> P := PrefrattiniSubgroup(G);
Group([ f2 ])
gap> Size(P);
2
gap> IsNilpotent(P);
true
gap> Core(G,P);
Group([  ])
gap> FrattiniSubgroup(G);
Group([  ])
\endexample

\Declaration{PerfectResiduum}
\beginexample
gap> PerfectResiduum(Group((1,2,3,4,5),(1,2)));
Group([ (1,3,2), (2,4,3), (2,3)(4,5) ])
\endexample

\Declaration{RadicalGroup}
\beginexample
gap> RadicalGroup(SL(2,5));
<group of 2x2 matrices of size 2 in characteristic 5>
gap> Size(last);
2
\endexample

\Declaration{Socle}
\beginexample
gap> Socle(g);
Group([ (1,4)(2,3), (1,2)(3,4) ])
\endexample

\Declaration{SupersolvableResiduum}
\beginexample
gap> SupersolvableResiduum(g);
Group([ (1,2)(3,4), (1,4)(2,3) ])
\endexample

\Declaration{PRump}

*@example missing!@*


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sylow Subgroups and Hall Subgroups}

\Declaration{SylowSubgroup}
\beginexample
gap> g:=SymmetricGroup(4);;
gap> SylowSubgroup(g,2);
Group([ (1,2), (3,4), (1,3)(2,4) ])
\endexample

With respect to the following {\GAP} functions,
please note that by theorems of P.~Hall,
a group $G$ is solvable if and only if one of the following conditions holds.
\beginlist%ordered
\item{1.}
    For each prime $p$ dividing the order of $G$,
    there exists a $p$-complement (see~"SylowComplement").
\item{2.}
    For each set $P$ of primes dividing the order of $G$,
    there exists a $P$-Hall subgroup (see~"HallSubgroup").
\item{3.}
    $G$ has a Sylow system (see~"SylowSystem").
\item{4.}
    $G$ has a complement system (see~"ComplementSystem").
\endlist

\Declaration{SylowComplement}
\beginexample
gap> SylowComplement(g,3);
Group([ (3,4), (1,4)(2,3), (1,3)(2,4) ])
\endexample

\Declaration{HallSubgroup}
\beginexample
gap> h:=SmallGroup(60,10);;
gap> u:=HallSubgroup(h,[2,3]);
Group([ f1, f2, f3 ])
gap> Size(u);
12
\endexample

\Declaration{SylowSystem}
\beginexample
gap> h:=SmallGroup(60,10);;
gap> SylowSystem(h);
[ Group([ f1, f2 ]), Group([ f3 ]), Group([ f4 ]) ]
gap> List(last,Size);
[ 4, 3, 5 ]
\endexample

\Declaration{ComplementSystem}
\beginexample
gap> ComplementSystem(h);
[ Group([ f3, f4 ]), Group([ f1, f2, f4 ]), Group([ f1, f2, f3 ]) ]
gap> List(last,Size);
[ 15, 20, 12 ]
\endexample

\Declaration{HallSystem}
\beginexample
gap> HallSystem(h);
[ Group([  ]), Group([ f1, f2 ]), Group([ f1, f2, f3 ]), 
  Group([ f1, f2, f3, f4 ]), Group([ f1, f2, f4 ]), Group([ f3 ]), 
  Group([ f3, f4 ]), Group([ f4 ]) ]
gap> List(last,Size);
[ 1, 4, 12, 60, 20, 3, 15, 5 ]
\endexample

%%  The methods for Sylow subgroups in polycyclic groups and for Hall
%%  Systems are due to Bettina Eick.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroups characterized by prime powers}

\Declaration{Omega}
\beginexample
gap> h:=SmallGroup(16,10);
<pc group of size 16 with 4 generators>
gap> Omega(h,2);
Group([ f4, f2, f3 ])
\endexample

\Declaration{Agemo}
\beginexample
gap> Agemo(h,2);Agemo(h,2,2);
Group([ f4 ])
Group([  ])
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group Properties}

Some properties of groups can be defined not only for groups but also for
other structures.
For example, nilpotency and solvability make sense also for algebras.
Note that these names refer to different definitions for groups and
algebras, contrary to the situation with finiteness or commutativity.
In such cases, the name of the function for groups got a suffix `Group'
to distinguish different meanings for different structures.

\Declaration{IsCyclic}
\Declaration{IsElementaryAbelian}
\Declaration{IsNilpotentGroup}
\Declaration{NilpotencyClassOfGroup}
\Declaration{IsPerfectGroup}
\Declaration{IsSolvableGroup}
\Declaration{IsPolycyclicGroup}
\Declaration{IsSupersolvableGroup}
\Declaration{IsMonomialGroup}

\Declaration{IsSimpleGroup}
\Declaration{IsomorphismTypeInfoFiniteSimpleGroup}
\beginexample
gap> IsomorphismTypeInfoFiniteSimpleGroup(Group((4,5)(6,7),(1,2,4)(3,5,6)));
rec( series := "L", parameter := [ 2, 7 ], 
  name := "A(1,7) = L(2,7) ~ B(1,7) = O(3,7) ~ C(1,7) = S(2,7) ~ 2A(1,7) = U(2\
,7) ~ A(2,2) = L(3,2)" )
\endexample

\Declaration{IsFinitelyGeneratedGroup}
\Declaration{IsSubsetLocallyFiniteGroup}

\atindex{p-group}{@$p$-group}
\Declaration{IsPGroup}
\Declaration{PrimePGroup}
\Declaration{PClassPGroup}
\Declaration{RankPGroup}
\beginexample
gap> h:=Group((1,2,3,4),(1,3));;
gap> PClassPGroup(h);
2
gap> RankPGroup(h);
2
\endexample

Note that the following functions, although they are mathematical
properties, are not properties in the sense of {\GAP} (see~"Attributes" and
"Properties"), as they depend on a parameter.

\Declaration{IsPSolvable}

\Declaration{IsPNilpotent}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Numerical Group Attributes}

\Declaration{AbelianInvariants}[grp]!{for groups}
\beginexample
gap> g:=Group((1,2,3,4),(1,2),(5,6));;
gap> AbelianInvariants(g);
[ 2, 2 ]
\endexample

\Declaration{Exponent}
\beginexample
gap> Exponent(g);
12
\endexample

Again the
following are mathematical attributes, but not {\GAP} `Attributes' as
they are depending on a parameter:

\Declaration{EulerianFunction}
\beginexample
gap> EulerianFunction(g,2);
432
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroup Series}

In group theory many subgroup series are considered,
and {\GAP} provides commands to compute them.
In the following sections, there is always a series
$G = U_1 > U_2 > \cdots > U_m = \langle 1 \rangle$ of subgroups considered.
A series also may stop without reaching $G$ or $\langle1\rangle$.

A series is called *subnormal* if every $U_{i+1}$ is normal in $U_i$.

A series is called *normal* if every $U_i$ is normal in $G$.

A series of normal subgroups is called *central* if $U_i/U_{i+1}$ is
central in $G/U_{i+1}$.

We call a series *refinable* if intermediate subgroups can be added to
the series without destroying the properties of the series.

\FileHeader[1]{grp}

\Declaration{ChiefSeries}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> ChiefSeries(g);
[ Group([ (1,2,3,4), (1,2) ]), Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (1,4)(2,3), (1,3)(2,4) ]), Group(()) ]
\endexample

\Declaration{ChiefSeriesThrough}

\Declaration{ChiefSeriesUnderAction}

\Declaration{SubnormalSeries}
\beginexample
gap> s:=SubnormalSeries(g,Group((1,2)(3,4)));
[ Group([ (1,2,3,4), (1,2) ]), Group([ (1,2)(3,4), (1,4)(2,3) ]), 
  Group([ (1,2)(3,4) ]) ]
\endexample

\Declaration{CompositionSeries}

\Declaration{DisplayCompositionSeries}
\beginexample
gap> CompositionSeries(g);
[ Group([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (1,4)(2,3), (1,3)(2,4) ]), Group([ (1,3)(2,4) ]), Group(()) ]
gap> DisplayCompositionSeries(Group((1,2,3,4,5,6,7),(1,2)));
G (2 gens, size 5040)
 || Z(2)
S (5 gens, size 2520)
 || A(7)
1 (0 gens, size 1)
\endexample

\Declaration{DerivedSeriesOfGroup}
\Declaration{DerivedLength}
\beginexample
gap> List(DerivedSeriesOfGroup(g),Size);
[ 24, 12, 4, 1 ]
gap> DerivedLength(g);
3
\endexample

\Declaration{ElementaryAbelianSeries}
\beginexample
gap> List(ElementaryAbelianSeries(g),Size);
[ 24, 12, 4, 1 ]
\endexample

\Declaration{InvariantElementaryAbelianSeries}
\beginexample
gap> g:=Group((1,2,3,4),(1,3));
Group([ (1,2,3,4), (1,3) ])
gap> hom:=GroupHomomorphismByImages(g,g,GeneratorsOfGroup(g),
> [(1,4,3,2),(1,4)(2,3)]);
[ (1,2,3,4), (1,3) ] -> [ (1,4,3,2), (1,4)(2,3) ]
gap> InvariantElementaryAbelianSeries(g,[hom]);
[ Group([ (1,2,3,4), (1,3) ]), Group([ (1,3)(2,4) ]), Group(()) ]
\endexample

\Declaration{LowerCentralSeriesOfGroup}

\Declaration{UpperCentralSeriesOfGroup}

\Declaration{PCentralSeries}

\Declaration{JenningsSeries}

\Declaration{DimensionsLoewyFactors}

\beginexample
gap> G:= SmallGroup( 3^6, 100 );
<pc group of size 729 with 6 generators>
gap> JenningsSeries( G );
[ <pc group of size 729 with 6 generators>, Group([ f3, f4, f5, f6 ]), 
  Group([ f4, f5, f6 ]), Group([ f5, f6 ]), Group([ f5, f6 ]), 
  Group([ f5, f6 ]), Group([ f6 ]), Group([ f6 ]), Group([ f6 ]), 
  Group([ <identity> of ... ]) ]
gap> DimensionsLoewyFactors(G);
[ 1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19, 20, 22, 23, 25, 26, 27, 27, 
  27, 27, 27, 27, 27, 27, 27, 26, 25, 23, 22, 20, 19, 17, 16, 14, 13, 11, 10, 
  8, 7, 5, 4, 2, 1 ]
\endexample

\Declaration{AscendingChain}

\Declaration{IntermediateGroup}

\Declaration{IntermediateSubgroups}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Factor Groups}

\Declaration{NaturalHomomorphismByNormalSubgroup}
\Declaration{FactorGroup}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;n:=Subgroup(g,[(1,2)(3,4),(1,3)(2,4)]);;
gap> hom:=NaturalHomomorphismByNormalSubgroup(g,n);
[ (1,2,3,4), (1,2) ] -> [ f1*f2, f1 ]
gap> Size(ImagesSource(hom));
6
gap> FactorGroup(g,n);
Group([ f1, f2 ])
\endexample
\Declaration{CommutatorFactorGroup}
\beginexample
gap> CommutatorFactorGroup(g);
Group([ f1 ])
\endexample

\Declaration{MaximalAbelianQuotient}

\Declaration{HasAbelianFactorGroup}
\Declaration{HasElementaryAbelianFactorGroup}
\beginexample
gap> HasAbelianFactorGroup(g,n);
false
gap> HasAbelianFactorGroup(DerivedSubgroup(g),n);
true
\endexample

\Declaration{CentralizerModulo}
\beginexample
gap> CentralizerModulo(g,n,(1,2));
Group([ (3,4), (1,3)(2,4), (1,4)(2,3) ])
\endexample

%%  The code for factor groups is due to Alexander Hulpke and Heiko Thei{\ss}en.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sets of Subgroups}

\Declaration{ConjugacyClassSubgroups}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;IsNaturalSymmetricGroup(g);;
gap> cl:=ConjugacyClassSubgroups(g,Subgroup(g,[(1,2)]));
Group( [ (1,2) ] )^G
gap> Size(cl);
6
gap> ClassElementLattice(cl,4);
Group([ (2,3) ])
\endexample

\Declaration{IsConjugacyClassSubgroupsRep}

\Declaration{ConjugacyClassesSubgroups}
\beginexample
gap> ConjugacyClassesSubgroups(g);
[ Group( () )^G, Group( [ (1,3)(2,4) ] )^G, Group( [ (1,2) ] )^G, 
  Group( [ (2,4,3) ] )^G, Group( [ (1,4)(2,3), (1,3)(2,4) ] )^G, 
  Group( [ (1,2)(3,4), (1,2) ] )^G, Group( [ (1,2)(3,4), (1,4,2,3) ] )^G, 
  Group( [ (3,4), (2,4,3) ] )^G, Group( [ (1,3)(2,4), (1,4)(2,3), (1,2) ] )^G,
  Group( [ (1,3)(2,4), (1,4)(2,3), (2,4,3) ] )^G, 
  Group( [ (1,3)(2,4), (1,4)(2,3), (2,4,3), (1,2) ] )^G ]
\endexample

\Declaration{ConjugacyClassesMaximalSubgroups}
\beginexample
gap> ConjugacyClassesMaximalSubgroups(g);
[ AlternatingGroup( [ 1 .. 4 ] )^G, Group( [ (1,2,3), (1,2) ] )^G, 
  Group( [ (1,2), (3,4), (1,3)(2,4) ] )^G ]
\endexample

\Declaration{MaximalSubgroupClassReps}
\beginexample
gap> MaximalSubgroupClassReps(g);
[ Alt( [ 1 .. 4 ] ), Group([ (1,2,3), (1,2) ]), 
  Group([ (1,2), (3,4), (1,3)(2,4) ]) ]
\endexample

\Declaration{MaximalSubgroups}
\beginexample
gap> MaximalSubgroups(Group((1,2,3),(1,2)));
[ Group([ (1,2,3) ]), Group([ (2,3) ]), Group([ (1,2) ]), Group([ (1,3) ]) ]
\endexample

\Declaration{NormalSubgroups}
\beginexample
gap> g:=SymmetricGroup(4);;NormalSubgroups(g);
[ Group(()), Group([ (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), Sym( [ 1 .. 4 ] ) ]
\endexample
The algorithm used for the computation of normal subgroups of permutation
groups and pc groups is described in \cite{Hulpke98}.

\Declaration{MaximalNormalSubgroups}
\beginexample
gap> MaximalNormalSubgroups( g );
[ Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]) ]
\endexample

\Declaration{MinimalNormalSubgroups}
\beginexample
gap> MinimalNormalSubgroups( g );
[ Group([ (1,4)(2,3), (1,3)(2,4) ]) ]
\endexample

%%  Bettina Eick designed and wrote the code for maximal subgroups of a solvable
%%  group. The code for normal subgroups \cite{Hulpke98} and for subgroups of a
%%  solvable group is due to Alexander Hulpke.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroup Lattice}

The {\GAP} package \package{XGAP} permits a graphical display of the lattice
of subgroups in a nice way.

\Declaration{LatticeSubgroups}
\beginexample
gap> g:=SymmetricGroup(4);;
gap> l:=LatticeSubgroups(g);
<subgroup lattice of Sym( [ 1 .. 4 ] ), 11 classes, 30 subgroups>
gap> ConjugacyClassesSubgroups(l);
[ Group( () )^G, Group( [ (1,3)(2,4) ] )^G, Group( [ (1,2) ] )^G, 
  Group( [ (2,4,3) ] )^G, Group( [ (1,4)(2,3), (1,3)(2,4) ] )^G, 
  Group( [ (1,2)(3,4), (1,2) ] )^G, Group( [ (1,2)(3,4), (1,4,2,3) ] )^G, 
  Group( [ (3,4), (2,4,3) ] )^G, Group( [ (1,3)(2,4), (1,4)(2,3), (1,2) ] )^G,
  Group( [ (1,3)(2,4), (1,4)(2,3), (2,4,3) ] )^G, 
  Group( [ (1,3)(2,4), (1,4)(2,3), (2,4,3), (1,2) ] )^G ]
\endexample
\Declaration{ClassElementLattice}

\Declaration{MaximalSubgroupsLattice}
\beginexample
gap> MaximalSubgroupsLattice(l);
[ [  ], [ [ 1, 1 ] ], [ [ 1, 1 ] ], [ [ 1, 1 ] ], 
  [ [ 2, 1 ], [ 2, 2 ], [ 2, 3 ] ], [ [ 3, 1 ], [ 3, 6 ], [ 2, 3 ] ], 
  [ [ 2, 3 ] ], [ [ 4, 1 ], [ 3, 4 ], [ 3, 5 ], [ 3, 6 ] ], 
  [ [ 7, 1 ], [ 6, 1 ], [ 5, 1 ] ], 
  [ [ 5, 1 ], [ 4, 1 ], [ 4, 2 ], [ 4, 3 ], [ 4, 4 ] ], 
  [ [ 10, 1 ], [ 9, 1 ], [ 9, 2 ], [ 9, 3 ], [ 8, 1 ], [ 8, 2 ], [ 8, 3 ], 
      [ 8, 4 ] ] ]
gap> last[6];
[ [ 3, 1 ], [ 3, 6 ], [ 2, 3 ] ]
gap> u1:=Representative(ConjugacyClassesSubgroups(l)[6]);
Group([ (1,2)(3,4), (1,2) ])
gap> u2:=ClassElementLattice(ConjugacyClassesSubgroups(l)[3],1);;
gap> u3:=ClassElementLattice(ConjugacyClassesSubgroups(l)[3],6);;
gap> u4:=ClassElementLattice(ConjugacyClassesSubgroups(l)[2],3);;
gap> IsSubgroup(u1,u2);IsSubgroup(u1,u3);IsSubgroup(u1,u4);
true
true
true
\endexample

\Declaration{MinimalSupergroupsLattice}
\beginexample
gap> MinimalSupergroupsLattice(l);
[ [ [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ], 
      [ 3, 5 ], [ 3, 6 ], [ 4, 1 ], [ 4, 2 ], [ 4, 3 ], [ 4, 4 ] ], 
  [ [ 5, 1 ], [ 6, 2 ], [ 7, 2 ] ], [ [ 6, 1 ], [ 8, 2 ], [ 8, 4 ] ], 
  [ [ 8, 1 ], [ 10, 1 ] ], [ [ 9, 1 ], [ 9, 2 ], [ 9, 3 ], [ 10, 1 ] ], 
  [ [ 9, 1 ] ], [ [ 9, 1 ] ], [ [ 11, 1 ] ], [ [ 11, 1 ] ], [ [ 11, 1 ] ], 
  [  ] ]
gap> last[3];
[ [ 6, 1 ], [ 8, 2 ], [ 8, 4 ] ]
gap> u5:=ClassElementLattice(ConjugacyClassesSubgroups(l)[8],2);
Group([ (1,3), (1,3,2) ])
gap> u6:=ClassElementLattice(ConjugacyClassesSubgroups(l)[8],4);
Group([ (1,4), (1,4,2) ])
gap> IsSubgroup(u5,u2);
true
gap> IsSubgroup(u6,u2);
true
\endexample

\Declaration{RepresentativesPerfectSubgroups}
\beginexample
gap> m11:=TransitiveGroup(11,6);
M(11)
gap> r:=RepresentativesPerfectSubgroups(m11);
[ Group([ (3,5,8)(4,11,7)(6,9,10), (1,10)(2,9)(3,7)(4,11) ]), 
  Group([ (2,3,5)(4,10,9)(6,7,11), (1,10)(2,9)(3,7)(4,11) ]), 
  Group([ (3,4,8,9)(6,7,11,10), (1,10)(2,9)(3,7)(4,11) ]), 
  Group([ (3,4,10)(5,11,6)(7,9,8), (1,10)(2,9)(3,7)(4,11) ]), M(11), 
  Group(()) ]
gap> List(r,Size);
[ 60, 60, 360, 660, 7920, 1 ]
\endexample

\Declaration{ConjugacyClassesPerfectSubgroups}
\beginexample
gap> ConjugacyClassesPerfectSubgroups(m11);
[ Group( [ ( 3, 5, 8)( 4,11, 7)( 6, 9,10), ( 1,10)( 2, 9)( 3, 7)( 4,11) ] )^G, 
  Group( [ ( 2, 3, 5)( 4,10, 9)( 6, 7,11), ( 1,10)( 2, 9)( 3, 7)( 4,11) ] )^G, 
  Group( [ ( 3, 4, 8, 9)( 6, 7,11,10), ( 1,10)( 2, 9)( 3, 7)( 4,11) ] )^G, 
  Group( [ ( 3, 4,10)( 5,11, 6)( 7, 9, 8), ( 1,10)( 2, 9)( 3, 7)( 4,11) ] )^G, 
  M(11)^G, Group( () )^G ]
\endexample

\Declaration{Zuppos}

\Declaration{InfoLattice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Specific Methods for Subgroup Lattice Computations}

\Declaration{LatticeByCyclicExtension}
\beginexample
gap> g:=WreathProduct(Group((1,2,3),(1,2)),Group((1,2,3,4)));;
gap> l:=LatticeByCyclicExtension(g,function(G)
> return Size(G) in [1,2,3,6];end);
<subgroup lattice of <permutation group of size 5184 with 9 generators>, 
47 classes, 2628 subgroups, restricted under further condition l!.func>
\endexample

The total number of classes in this example is much bigger, as the
following example shows:
\beginexample
gap> LatticeSubgroups(g);
<subgroup lattice of <permutation group of size 5184 with 9 generators>, 
566 classes, 27134 subgroups>
\endexample

\Declaration{InvariantSubgroupsElementaryAbelianGroup}
\beginexample
gap> g:=Group((1,2,3),(4,5,6),(7,8,9));
Group([ (1,2,3), (4,5,6), (7,8,9) ])
gap> hom:=GroupHomomorphismByImages(g,g,[(1,2,3),(4,5,6),(7,8,9)],
> [(7,8,9),(1,2,3),(4,5,6)]);
[ (1,2,3), (4,5,6), (7,8,9) ] -> [ (7,8,9), (1,2,3), (4,5,6) ]
gap> u:=InvariantSubgroupsElementaryAbelianGroup(g,[hom]);
[ Group(()), Group([ (1,2,3)(4,5,6)(7,8,9) ]), 
  Group([ (1,3,2)(7,8,9), (1,3,2)(4,5,6) ]), 
  Group([ (7,8,9), (4,5,6), (1,2,3) ]) ]
\endexample

\Declaration{SubgroupsSolvableGroup}
\beginexample
gap> g:=Group((1,2,3),(1,2),(4,5,6),(4,5),(7,8,9),(7,8));
Group([ (1,2,3), (1,2), (4,5,6), (4,5), (7,8,9), (7,8) ])
gap> hom:=GroupHomomorphismByImages(g,g,
> [(1,2,3),(1,2),(4,5,6),(4,5),(7,8,9),(7,8)],
> [(4,5,6),(4,5),(7,8,9),(7,8),(1,2,3),(1,2)]);
[ (1,2,3), (1,2), (4,5,6), (4,5), (7,8,9), (7,8) ] -> 
[ (4,5,6), (4,5), (7,8,9), (7,8), (1,2,3), (1,2) ]
gap> l:=SubgroupsSolvableGroup(g,rec(actions:=[hom]));;
gap> List(l,Size);
[ 1, 3, 9, 27, 54, 2, 6, 18, 108, 4, 216, 8 ]
gap> Length(ConjugacyClassesSubgroups(g)); # to compare
162
\endexample

\Declaration{SizeConsiderFunction}
\beginexample
gap> l:=SubgroupsSolvableGroup(g,rec(actions:=[hom],
> consider:=SizeConsiderFunction(6)));;
gap> List(l,Size);
[ 1, 3, 9, 27, 54, 6, 18, 108, 216 ]
\endexample
This example shows that in general the `consider' function does not provide
a perfect filter. It is guaranteed that all subgroups fulfilling the
condition are returned, but not all subgroups returned necessarily fulfill
the condition.

\Declaration{ExactSizeConsiderFunction}
\beginexample
gap> l:=SubgroupsSolvableGroup(g,rec(actions:=[hom],
> consider:=ExactSizeConsiderFunction(6)));;
gap> List(l,Size);
[ 1, 3, 9, 27, 54, 6, 108, 216 ]
\endexample
Again, the `consider' function does not provide
a perfect filter. It is guaranteed that all subgroups fulfilling the
condition are returned, but not all subgroups returned necessarily fulfill
the condition.

\Declaration{InfoPcSubgroup}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Special Generating Sets}

\Declaration{GeneratorsSmallest}
\beginexample
gap> g:=SymmetricGroup(4);;
gap> GeneratorsSmallest(g);
[ (3,4), (2,3), (1,2) ]
\endexample
\Declaration{LargestElementGroup}

\Declaration{MinimalGeneratingSet}
\beginexample
gap> MinimalGeneratingSet(g);
[ (2,4,3), (1,4,2,3) ]
\endexample

\Declaration{SmallGeneratingSet}
\beginexample
gap> SmallGeneratingSet(g);
[ (1,2), (1,2,3,4) ]
\endexample

\Declaration{IndependentGeneratorsOfAbelianGroup}
\beginexample
gap> g:=AbelianGroup(IsPermGroup,[15,14,22,78]);;
gap> List(IndependentGeneratorsOfAbelianGroup(g),Order);
[ 2, 2, 2, 3, 3, 5, 7, 11, 13 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{1-Cohomology}

\index{one cohomology}
\index{cohomology}
\index{cocycles}

Let $G$ be a finite group and  $M$ an elementary abelian normal $p$-subgroup
of $G$.  Then the group  of 1-cocycles $Z^1(  G/M, M  )$ is
defined as
$$
Z^1(G/M, M) = \{ \gamma: G/M \rightarrow M \mid \forall g_1, g_2\in G :
                                 \gamma(g_1 M . g_2 M ) 
                                   = \gamma(g_1 M)^{g_2} . \gamma(g_2 M) \}
$$
and is a $GF(p)$-vector space.

The group of 1-coboundaries $B^1( G/M, M )$ is defined as
$$
B^1(G/M, M) = \{ \gamma : G/M \rightarrow M \mid \exists m\in M
                                 \forall g\in G : 
                                  \gamma(gM) = (m^{-1})^g . m \}
$$
It also is a $GF(p)$-vector space.

Let $\alpha$ be the isomorphism of $M$ into a row vector space ${\cal W}$
and $(g_1,\ldots,g_l)$  representatives for  a  generating set  of $G/M$.
Then  there exists a  monomorphism   $\beta$ of $Z^1( G/M, M )$  in   the
$l$-fold direct sum of ${\cal W}$, such that $\beta( \gamma ) = ( \alpha(
\gamma(g_1 M) ),\ldots, \alpha( \gamma(g_l M) ) )$  for  every $\gamma\in
Z^1( G/M, M )$.

\Declaration{OneCocycles}
\Declaration{OneCoboundaries}

The operations `OneCocycles' and `OneCoboundaries' return a record with
(at least) the components:

\beginitems
`generators'&
Is a list of representatives for a generating set of $G/M$. Cocycles are
represented with respect to these generators.

`oneCocycles'&
A space of row vectors over GF($p$), representing $Z^1$. The vectors are
represented in dimension $a\cdot b$ where $a$ is the length of `generators'
and $p^b$ the size of $M$.

`oneCoboundaries'&
A space of row vectors that represents $B^1$.

`cocycleToList'&
is a function to convert a cocycle (a row vector in `oneCocycles') to
a corresponding list of elements of $M$.

`listToCocycle'&
is a function to convert a list of elements of $M$ to a cocycle.

`isSplitExtension'&
indicates whether $G$ splits over $M$.
The following components are only bound if the extension splits. Note that
if $M$ is given by a modulo pcgs all subgroups are given as subgroups of $G$
by generators corresponding to `generators' and thus may not contain the
denominator of the modulo pcgs. In this case taking the closure with this
denominator will give the full preimage of the complement in the factor
group.

`complement'&
One complement to $M$ in $G$.

`cocycleToComplement(<cyc>)'&
is a function that takes a cocycle from `oneCocycles' and returns the
corresponding complement to $M$ in $G$ (with respect to the fixed complement
`complement').

`complementToCocycle(<U>)'&
is a function that takes a complement and returns the corresponding cocycle.

\enditems

If the factor <G>/<M> is given by a (modulo) pcgs <gens> then special
methods are used that compute a presentation for the factor implicitly from
the pcgs.

Note that the groups of 1-cocycles and 1-coboundaries are not `Group's in
the sense of {\GAP} but vector spaces.

\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> n:=Group((1,2)(3,4),(1,3)(2,4));;
gap> oc:=OneCocycles(g,n);
rec( oneCoboundaries := <vector space over GF(2), with 2 generators>, 
  oneCocycles := <vector space over GF(2), with 2 generators>, 
  generators := [ (3,4), (2,4,3) ], isSplitExtension := true, 
  complement := Group([ (3,4), (2,4,3) ]), 
  cocycleToList := function( c ) ... end, 
  listToCocycle := function( L ) ... end, 
  cocycleToComplement := function( c ) ... end, 
  factorGens := [ (3,4), (2,4,3) ], 
  complementToCocycle := function( K ) ... end )
gap> oc.cocycleToList([ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]);
[ (1,2)(3,4), (1,2)(3,4) ]
gap> oc.listToCocycle([(),(1,3)(2,4)]);
[ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ]
gap> oc.cocycleToComplement([ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]);
Group([ (1,2), (1,2,3) ])
gap> oc.cocycleToComplement([ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ]);
Group([ (3,4), (1,3,4) ])
gap> oc.complementToCocycle(Group((1,2,4),(1,4)));
[ 0*Z(2), Z(2)^0, Z(2)^0, Z(2)^0 ]
\endexample

The factor group $H^1(G/M,M)=Z^1(G/M,M)/B^1(G/M,M)$ is called the first
cohomology group. Currently there is no function which explicitly computes
this group. The easiest way to represent it is as a vector space complement to
$B^1$ in $Z^1$.

{}

If the only purpose of the calculation of $H^1$ is the determination of
complements it might be desirable to stop calculations once it is known that
the extension cannot split.  This can be achieved via the more technical
function `OCOneCocycles'.
\Declaration{OCOneCocycles}

\Declaration{ComplementclassesEA}

\Declaration{InfoCoh}

%%  The computation of the 1-Cohomology follows \cite{CNW90} and was implemented
%%  by Frank Celler and Alexander Hulpke.

% \Section{AutomorphisGroups and Testing Isomorphism}
%T Is dealt with in section on group homomorphisms!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Schur Covers and Multipliers}

\atindex{Darstellungsgruppe!see EpimorphismSchurCover}%
{@Darstellungsgruppe!see \noexpand`EpimorphismSchurCover'}

\Declaration{EpimorphismSchurCover}
\Declaration{SchurCover}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> epi:=EpimorphismSchurCover(g);
[ f1, f2, f3 ] -> [ (3,4), (2,4,3), (1,4)(2,3) ]
gap> Size(Source(epi));
48
\endexample

If the group becomes bigger, Schur Cover calculations might become
unfeasible.

There is another operation
which only returns the structure of the Multiplier.
% , and which should work
% for larger groups as well.

\Declaration{AbelianInvariantsMultiplier}
\beginexample
gap> AbelianInvariantsMultiplier(g);
[ 2 ]
\endexample
%beginexample
% gap> AbelianInvariantsMultiplier(g);
% [ 2 ]
% gap> AbelianInvariantsMultiplier(MathieuGroup(22));
% [ 4, 3 ]
%endexample

Note that the following example will take some time.

%notest
\beginexample
gap> AbelianInvariantsMultiplier(PSU(6,2));
[ 2, 2, 3 ]
\endexample

At the moment, this operation will not give any information about how to
extend the multiplier to a Schur Cover.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Tests for the Availability of Methods}

\FileHeader{grp}[3]

\Declaration{CanEasilyTestMembership}
\Declaration{CanComputeSize}
\Declaration{CanComputeSizeAnySubgroup}
\Declaration{CanComputeIndex}
\Declaration{CanComputeIsSubset}
\Declaration{KnowsHowToDecompose}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

