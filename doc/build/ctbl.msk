%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  ctbl.msk                    GAP documentation               Thomas Breuer
%A                                                           Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
%%  The documentation in this chapter corresponds to the declarations in the
%%  library files `ctbl.gd', `ctblauto.gd', `ctblgrp.gd', `ctblothe.gd',
%%  `ctblsolv.gd'.
%%
\Chapter{Character Tables}

\index{tables}

This chapter describes operations for *character tables of finite groups*.

Operations for *characters* (or, more general, *class functions*) are
described in Chapter~"Class Functions".

For a description of the {\GAP} Library of Character Tables,
see the separate manual for the {\GAP} package `ctbllib'.

Several examples in this chapter require the {\GAP} Character Table Library
to be available.
If it is not yet loaded then we load it now.

\beginexample
gap> LoadPackage( "ctbllib" );
true
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Some Remarks about Character Theory in GAP}

\FileHeader[1]{ctbl}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{History of Character Theory Stuff in GAP}

{\GAP} provides functions for dealing with group characters since the version
{\GAP}~3.1, which was released in March 1992.
The reason for adding this branch of mathematics to the topics of {\GAP} was
(apart from the usefulness of character theoretic computations in general)
the insight that {\GAP} provides an ideal environment for developing the
algorithms needed.
In particular, it had been decided at Lehrstuhl D f{\accent127 u}r Mathematik
that the {\sf CAS} system (a standalone Fortran program together with a
database of character tables, see~\cite{NPP84})
should not be developed further and the functionality of {\sf CAS} should be
made available in {\GAP}.
The background was that extending {\sf CAS} (by new Fortran code) had turned
out to be much less flexible than writing analogous {\GAP} library code.

For integrating the existing character theory algorithms,
{\GAP}'s memory management and long integer arithmetic were useful as well as
the list handling --it is an important feature of character theoretic methods
that questions about groups are translated into manipulations of lists;
on the other hand, the datatype of cyclotomics (see Chapter~"Cyclotomics")
was added to the {\GAP} kernel because of the character theory algorithms.
For developing further code, also other areas of {\GAP}'s library became
interesting, such as permutation groups, finite fields, and polynomials.

The development of character theory code for {\GAP} has been supported
by several DFG grants,
in particular the project ``Representation Theory of Finite Groups and Finite
Dimensional Algebras'' (until 1991),
and the Schwerpunkt ``Algorithmische Zahlentheorie und Algebra''
(from 1991 until 1997).
Besides that, several Diploma theses at Lehrstuhl D were concerned with
the development and/or implementation of algorithms dealing with characters
in {\GAP}.

The major contributions can be listed as follows.
\beginlist%unordered
\item{$\bullet$}
    The arithmetic for the cyclotomics data type, following~\cite{Zum89},
    was first implemented by Marco van Meegen; an alternative approach was
    studied in the diploma thesis of Michael Scherner (see~\cite{Scherner92})
    but was not efficient enough;
    later Martin Sch{\accent127 o}nert replaced the implementation
    by a better one.
% and since then, there have been more than 30 local improvements ...

\item{$\bullet$}
    The basic routines for characters and character tables were written
    by Thomas Breuer and G{\accent127 o}tz Pfeiffer.

\item{$\bullet$}
    The lattice related functions, such as `LLL', `OrthogonalEmbeddings',
    and `DnLattice', were implemented by Ansgar Kaup (see~\cite{Kaup92}).

\item{$\bullet$}
    Functions for computing possible class fusions, possible power maps,
    and table automorphisms were written by Thomas Breuer (see~\cite{Bre91}).

\item{$\bullet$}
    Functions for computing possible permutation characters were written by
    Thomas Breuer (see~\cite{Bre91})
    and G{\accent127 o}tz Pfeiffer (see~\cite{Pfe91}).

\item{$\bullet$}
    Functions for computing character tables from groups were written by
    Alexander Hulpke (Dixon-Schneider algorithm, see~\cite{Hulpke93})
    and Hans Ulrich Besche (Baum algorithm and Conlon algorithm,
    see~\cite{Besche92}).

\item{$\bullet$}
    Functions for dealing with Clifford matrices were written by
    Ute Schiffer (see~\cite{Schiffer94}).

\item{$\bullet$}
    Functions for monomiality questions were written by Thomas Breuer and
    Erzs\'ebet Horv\'ath.
\endlist

Since then, the code has been maintained and extended further by
Alexander Hulpke (code related to his implementation of the Dixon-Schneider
algorithm) and Thomas Breuer.

% D. Bauten?

Currently {\GAP} does not provide special functionality for computing
Brauer character tables, but there is an interface to the {\sf MOC} system
(see~\cite{HJLP92}), and the {\GAP} Character Table Library contains many
known Brauer character tables.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Character Tables}

\index{tables}
\index{character tables}
\index{library tables}
\index{character tables!access to}
\index{character tables!calculate}
\index{character tables!of groups}

\FileHeader[10]{ctbl}

\Declaration{CharacterTable}
\Declaration{BrauerTable}
\beginexample
gap> g:= SymmetricGroup( 4 );
Sym( [ 1 .. 4 ] )
gap> tbl:= CharacterTable( g );;  HasIrr( tbl );
false
gap> tblmod2:= CharacterTable( tbl, 2 );
BrauerTable( Sym( [ 1 .. 4 ] ), 2 )
gap> tblmod2 = CharacterTable( tbl, 2 );
true
gap> tblmod2 = BrauerTable( tbl, 2 );
true
gap> tblmod2 = BrauerTable( g, 2 );
true
gap> CharacterTable( "A5" );
CharacterTable( "A5" )
gap> CharacterTable( "Symmetric", 4 );
CharacterTable( "Sym(4)" )
gap> ComputedBrauerTables( tbl );
[ , BrauerTable( Sym( [ 1 .. 4 ] ), 2 ) ]
\endexample

\Declaration{SupportedCharacterTableInfo}
\Declaration{ConvertToCharacterTable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Character Table Categories}

\Declaration{IsNearlyCharacterTable}
\beginexample
gap> g:= SymmetricGroup( 4 );;
gap> tbl:= CharacterTable( g );  modtbl:= tbl mod 2;
CharacterTable( Sym( [ 1 .. 4 ] ) )
BrauerTable( Sym( [ 1 .. 4 ] ), 2 )
gap> IsCharacterTable( tbl );  IsCharacterTable( modtbl );
true
true
gap> IsBrauerTable( modtbl );  IsBrauerTable( tbl );
true
false
gap> IsOrdinaryTable( tbl );  IsOrdinaryTable( modtbl );
true
false
gap> IsCharacterTable( g );  IsCharacterTable( Irr( g ) );
false
false
\endexample

\Declaration{InfoCharacterTable}

\Declaration{NearlyCharacterTablesFamily}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Conventions for Character Tables}

The following few conventions should be noted.
\beginlist%unordered
\item{--}
    The class of the *identity element* is expected to be the first one;
    thus the degree of a character is the character value at position $1$.
\item{--}
    The *trivial character* of a character table need not be the first in
    the list of irreducibles.
\item{--}
    Most functions that take a character table as an argument and work with
    characters expect these characters as an argument, too.
    For some functions, the list of irreducible characters serves as the
    default, i.e, the value of the attribute `Irr' (see~"Irr");
    in these cases, the `Irr' value is automatically computed if it was not
    yet known.
\item{--}
    For a stored class fusion, the image table is denoted by its `Identifier'
    value (see~"Identifier!for character tables");
    each library table has a unique identifier by which it can be accessed
    (see~"ctbllib:Access to Library Character Tables" in the manual for the
    {\GAP} Character Table Library),
    tables constructed from groups get an identifier that is unique in the
    current {\GAP} session.
\endlist


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The Interface between Character Tables and Groups}

\FileHeader[2]{ctbl}

\Declaration{UnderlyingGroup}!{for character tables}
\Declaration{ConjugacyClasses}[ctbl]!{for character tables}
\Declaration{IdentificationOfConjugacyClasses}
\beginexample
gap> g:= SymmetricGroup( 4 );;
gap> repres:= [ (1,2), (1,2,3), (1,2,3,4), (1,2)(3,4), () ];;
gap> ccl:= List( repres, x -> ConjugacyClass( g, x ) );;
gap> SetConjugacyClasses( g, ccl );
gap> tbl:= CharacterTable( g );;   # the table stores already the values
gap> HasConjugacyClasses( tbl );  HasUnderlyingGroup( tbl );
true
true
gap> UnderlyingGroup( tbl ) = g;
true
gap> HasIdentificationOfConjugacyClasses( tbl );
true
gap> IdentificationOfConjugacyClasses( tbl );
[ 5, 1, 2, 3, 4 ]
\endexample

\Declaration{ConnectGroupAndCharacterTable}
\Declaration{CompatibleConjugacyClasses}
\beginexample
gap> g:= AlternatingGroup( 5 );
Alt( [ 1 .. 5 ] )
gap> tbl:= CharacterTable( "A5" );
CharacterTable( "A5" )
gap> HasUnderlyingGroup( tbl );  HasOrdinaryCharacterTable( g );
false
false
gap> CompatibleConjugacyClasses( tbl );   # unique identification
[  ]
gap> ConnectGroupAndCharacterTable( g, tbl );
true
gap> HasConjugacyClasses( tbl );  HasUnderlyingGroup( tbl );
true
true
gap> IdentificationOfConjugacyClasses( tbl );
[ 1, 2, 3, 4, 5 ]
gap> # Here is an example where the identification is not unique.
gap> CompatibleConjugacyClasses( CharacterTable( "J2" ) );
[ [ 17, 18 ], [ 9, 10 ] ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operators for Character Tables}

\FileHeader[3]{ctbl}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes and Properties of Character Tables}

\FileHeader[4]{ctbl}

\Declaration{CharacterDegrees}
\beginexample
gap> CharacterDegrees( SymmetricGroup( 4 ) );
[ [ 1, 2 ], [ 2, 1 ], [ 3, 2 ] ]
gap> CharacterDegrees( SymmetricGroup( 4 ), 2 );
[ [ 1, 1 ], [ 2, 1 ] ]
gap> CharacterDegrees( CharacterTable( "A5" ) );
[ [ 1, 1 ], [ 3, 2 ], [ 4, 1 ], [ 5, 1 ] ]
gap> CharacterDegrees( CharacterTable( "A5" ) mod 2 );
[ [ 1, 1 ], [ 2, 2 ], [ 4, 1 ] ]
\endexample

\Declaration{Irr}

In the following example we temporarily increase the line length limit from
its default value 80 to 85 in order to get a nicer output format.

\beginexample
gap> Irr( SymmetricGroup( 4 ) );
[ Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, -1, 1, 1, -1 ] ), 
  Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 3, -1, -1, 0, 1 ] ), 
  Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 2, 0, 2, -1, 0 ] ), 
  Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 3, 1, -1, 0, -1 ] ), 
  Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, 1, 1, 1, 1 ] ) ]
gap> Irr( SymmetricGroup( 4 ), 2 );
[ Character( BrauerTable( Sym( [ 1 .. 4 ] ), 2 ), [ 1, 1 ] ), 
  Character( BrauerTable( Sym( [ 1 .. 4 ] ), 2 ), [ 2, -1 ] ) ]
gap> SizeScreen([ 85, ]);;
gap> Irr( CharacterTable( "A5" ) );
[ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] ), 
  Character( CharacterTable( "A5" ), [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ) ]
gap> SizeScreen([ 80, ]);;
gap> Irr( CharacterTable( "A5" ) mod 2 );
[ Character( BrauerTable( "A5", 2 ), [ 1, 1, 1, 1 ] ), 
  Character( BrauerTable( "A5", 2 ), [ 2, -1, E(5)+E(5)^4, E(5)^2+E(5)^3 ] ), 
  Character( BrauerTable( "A5", 2 ), [ 2, -1, E(5)^2+E(5)^3, E(5)+E(5)^4 ] ), 
  Character( BrauerTable( "A5", 2 ), [ 4, 1, -1, -1 ] ) ]
\endexample

\Declaration{LinearCharacters}
\beginexample
gap> LinearCharacters( SymmetricGroup( 4 ) );
[ Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, -1, 1, 1, -1 ] ) ]
\endexample

\Declaration{OrdinaryCharacterTable}
\beginexample
gap> OrdinaryCharacterTable( SymmetricGroup( 4 ) );
CharacterTable( Sym( [ 1 .. 4 ] ) )
gap> tbl:= CharacterTable( "A5" );;  modtbl:= tbl mod 2;
BrauerTable( "A5", 2 )
gap> OrdinaryCharacterTable( modtbl ) = tbl;
true
\endexample

\FileHeader[5]{ctbl}
\beginexample
gap> tables:= [ CharacterTable( CyclicGroup( 3 ) ),
>               CharacterTable( SymmetricGroup( 4 ) ),
>               CharacterTable( AlternatingGroup( 5 ) ) ];;
gap> List( tables, AbelianInvariants );
[ [ 3 ], [ 2 ], [  ] ]
gap> List( tables, CommutatorLength );
[ 1, 1, 1 ]
gap> List( tables, Exponent );
[ 3, 12, 30 ]
gap> List( tables, IsAbelian );
[ true, false, false ]
gap> List( tables, IsCyclic );
[ true, false, false ]
gap> List( tables, IsFinite );
[ true, true, true ]
gap> List( tables, IsMonomial );
[ true, true, false ]
gap> List( tables, IsNilpotent );
[ true, false, false ]
gap> List( tables, IsPerfect );
[ false, false, true ]
gap> List( tables, IsSimple );
[ true, false, true ]
gap> List( tables, IsSolvable );
[ true, true, false ]
gap> List( tables, IsSupersolvable );
[ true, false, false ]
gap> List( tables, NrConjugacyClasses );
[ 3, 5, 5 ]
gap> List( tables, Size );
[ 3, 24, 60 ]
\endexample

\FileHeader[6]{ctbl}

\Declaration{OrdersClassRepresentatives}
\Declaration{SizesCentralizers}
\Declaration{SizesConjugacyClasses}
\beginexample
gap> tbl:= CharacterTable( "A5" );;
gap> OrdersClassRepresentatives( tbl );
[ 1, 2, 3, 5, 5 ]
gap> SizesCentralizers( tbl );
[ 60, 4, 3, 5, 5 ]
gap> SizesConjugacyClasses( tbl );
[ 1, 15, 20, 12, 12 ]
\endexample

\FileHeader[7]{ctbl}

\Declaration{AutomorphismsOfTable}
\beginexample
gap> tbl:= CharacterTable( "Dihedral", 8 );;
gap> AutomorphismsOfTable( tbl );
Group([ (4,5) ])
gap> OrdersClassRepresentatives( tbl );
[ 1, 4, 2, 2, 2 ]
gap> SizesConjugacyClasses( tbl );
[ 1, 2, 1, 2, 2 ]
\endexample

\Declaration{UnderlyingCharacteristic}
\beginexample
gap> tbl:= CharacterTable( "A5" );;
gap> UnderlyingCharacteristic( tbl );
0
gap> UnderlyingCharacteristic( tbl mod 17 );
17
\endexample

\Declaration{ClassNames}
\beginexample
gap> tbl:= CharacterTable( "A5" );;
gap> ClassNames( tbl );
[ "1a", "2a", "3a", "5a", "5b" ]
gap> tbl.2a;
2
\endexample

\Declaration{Identifier}!{for character tables}
\beginexample
gap> Identifier( CharacterTable( "A5" ) );
"A5"
gap> tbl:= CharacterTable( Group( () ) );;
gap> Identifier( tbl );  Identifier( tbl mod 2 );
"CT8"
"CT8mod2"
\endexample

\Declaration{InfoText}
\beginexample
gap> Print( InfoText( CharacterTable( "A5" ) ), "\n" );
origin: ATLAS of finite groups, tests: 1.o.r., pow[2,3,5]
\endexample

\Declaration{InverseClasses}
\Declaration{RealClasses}
\beginexample
gap> InverseClasses( CharacterTable( "A5" ) );
[ 1, 2, 3, 4, 5 ]
gap> InverseClasses( CharacterTable( "Cyclic", 3 ) );
[ 1, 3, 2 ]
gap> RealClasses( CharacterTable( "A5" ) );
[ 1, 2, 3, 4, 5 ]
gap> RealClasses( CharacterTable( "Cyclic", 3 ) );
[ 1 ]
\endexample

\Declaration{ClassOrbit}
\Declaration{ClassRoots}
\beginexample
gap> ClassOrbit( CharacterTable( "A5" ), 4 );
[ 4, 5 ]
gap> ClassRoots( CharacterTable( "A5" ) );
[ [ 2, 3, 4, 5 ], [  ], [  ], [  ], [  ] ]
gap> ClassRoots( CharacterTable( "Cyclic", 6 ) );
[ [ 3, 4, 5 ], [  ], [ 2 ], [ 2, 6 ], [ 6 ], [  ] ]
\endexample

\FileHeader[8]{ctbl}

\Declaration{ClassPositionsOfNormalSubgroups}
\Declaration{ClassPositionsOfAgemo}
\Declaration{ClassPositionsOfCentre}[ctbl]!{for character tables}
\Declaration{ClassPositionsOfDirectProductDecompositions}
\Declaration{ClassPositionsOfDerivedSubgroup}
\Declaration{ClassPositionsOfElementaryAbelianSeries}
\Declaration{ClassPositionsOfFittingSubgroup}
\Declaration{ClassPositionsOfLowerCentralSeries}
\Declaration{ClassPositionsOfUpperCentralSeries}
\Declaration{ClassPositionsOfSupersolvableResiduum}
\Declaration{ClassPositionsOfNormalClosure}
\beginexample
gap> tbla5:= CharacterTable( "A5" );;
gap> tbls4:= CharacterTable( "Symmetric", 4 );;
gap> tbld8:= CharacterTable( "Dihedral", 8 );;
gap> ClassPositionsOfNormalSubgroups( tbls4 );
[ [ 1 ], [ 1, 3 ], [ 1, 3, 4 ], [ 1 .. 5 ] ]
gap> ClassPositionsOfAgemo( tbls4, 2 );
[ 1, 3, 4 ]
gap> ClassPositionsOfCentre( tbld8 );
[ 1, 3 ]
gap> ClassPositionsOfDerivedSubgroup( tbld8 );
[ 1, 3 ]
gap> ClassPositionsOfElementaryAbelianSeries( tbls4 );
[ [ 1 .. 5 ], [ 1, 3, 4 ], [ 1, 3 ], [ 1 ] ]
gap> ClassPositionsOfElementaryAbelianSeries( tbla5 );
fail
gap> ClassPositionsOfFittingSubgroup( tbls4 );
[ 1, 3 ]
gap> ClassPositionsOfLowerCentralSeries( tbls4 );
[ [ 1 .. 5 ], [ 1, 3, 4 ] ]
gap> ClassPositionsOfLowerCentralSeries( tbld8 );
[ [ 1 .. 5 ], [ 1, 3 ], [ 1 ] ]
gap> ClassPositionsOfUpperCentralSeries( tbls4 );
[ [ 1 ] ]
gap> ClassPositionsOfUpperCentralSeries( tbld8 );
[ [ 1, 3 ], [ 1, 2, 3, 4, 5 ] ]
gap> ClassPositionsOfSupersolvableResiduum( tbls4 );
[ 1, 3 ]
gap> ClassPositionsOfNormalClosure( tbls4, [ 1, 4 ] );
[ 1, 3, 4 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations Concerning Blocks}

\Declaration{PrimeBlocks}
\beginexample
gap> tbl:= CharacterTable( "L3(2)" );;
gap> pbl:= PrimeBlocks( tbl, 2 );
rec( block := [ 1, 1, 1, 1, 1, 2 ], defect := [ 3, 0 ], 
  height := [ 0, 0, 0, 1, 0, 0 ], relevant := [ 3, 5 ], 
  centralcharacter := [ [ ,, 56,, 24 ], [ ,, -7,, 3 ] ] )
\endexample

\Declaration{SameBlock}
\beginexample
gap> omega:= List( Irr( tbl ), CentralCharacter );;
gap> SameBlock( 2, omega[1], omega[2], pbl.relevant );
true
gap> SameBlock( 2, omega[1], omega[6], pbl.relevant );
false
\endexample

\Declaration{BlocksInfo}
\beginexample
gap> BlocksInfo( CharacterTable( "L3(2)" ) mod 2 );
[ rec( defect := 3, ordchars := [ 1, 2, 3, 4, 5 ], modchars := [ 1, 2, 3 ], 
      decinv := [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], 
      basicset := [ 1, 2, 3 ] ), 
  rec( defect := 0, ordchars := [ 6 ], modchars := [ 4 ], decinv := [ [ 1 ] ],
      basicset := [ 6 ] ) ]
\endexample

\Declaration{DecompositionMatrix}
\beginexample
gap> modtbl:= CharacterTable( "L3(2)" ) mod 2;
BrauerTable( "L3(2)", 2 )
gap> DecompositionMatrix( modtbl );
[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 1, 0 ], 
  [ 1, 1, 1, 0 ], [ 0, 0, 0, 1 ] ]
gap> DecompositionMatrix( modtbl, 1 );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 1 ] ]
gap> DecompositionMatrix( modtbl, 2 );
[ [ 1 ] ]
\endexample

\Declaration{LaTeXStringDecompositionMatrix}
\beginexample
gap> modtbl:= CharacterTable( "L3(2)" ) mod 2;;
gap> Print( LaTeXStringDecompositionMatrix( modtbl, 1 ) );
\[
\begin{array}{r||rrr} \hline
 & {\tt Y}_{1}
 & {\tt Y}_{2}
 & {\tt Y}_{3}
 \rule[-7pt]{0pt}{20pt} \\ \hline
{\tt X}_{1} & 1 & . & . \rule[0pt]{0pt}{13pt} \\
{\tt X}_{2} & . & 1 & . \\
{\tt X}_{3} & . & . & 1 \\
{\tt X}_{4} & . & 1 & 1 \\
{\tt X}_{5} & 1 & 1 & 1 \rule[-7pt]{0pt}{5pt} \\
\hline
\end{array}
\]
gap> options:= rec( phi:= "\\varphi", chi:= "\\chi" );;
gap> Print( LaTeXStringDecompositionMatrix( modtbl, 1, options ) );
\[
\begin{array}{r||rrr} \hline
 & \varphi_{1}
 & \varphi_{2}
 & \varphi_{3}
 \rule[-7pt]{0pt}{20pt} \\ \hline
\chi_{1} & 1 & . & . \rule[0pt]{0pt}{13pt} \\
\chi_{2} & . & 1 & . \\
\chi_{3} & . & . & 1 \\
\chi_{4} & . & 1 & 1 \\
\chi_{5} & 1 & 1 & 1 \rule[-7pt]{0pt}{5pt} \\
\hline
\end{array}
\]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Other Operations for Character Tables}

\FileHeader[9]{ctbl}

\Declaration{IsPSolvableCharacterTable}
\beginexample
gap> tbl:= CharacterTable( "Sz(8)" );;
gap> IsPSolvableCharacterTable( tbl, 2 );
false
gap> IsPSolvableCharacterTable( tbl, 3 );
true
\endexample

\Declaration{IsClassFusionOfNormalSubgroup}
\beginexample
gap> tblc2:= CharacterTable( "Cyclic", 2 );;
gap> tbld8:= CharacterTable( "Dihedral", 8 );;
gap> fus:= PossibleClassFusions( tblc2, tbld8 );
[ [ 1, 3 ], [ 1, 4 ], [ 1, 5 ] ]
gap> List( fus, map -> IsClassFusionOfNormalSubgroup( tblc2, map, tbld8 ) );
[ true, false, false ]
\endexample

\Declaration{Indicator}
\beginexample
gap> tbl:= CharacterTable( "L3(2)" );;
gap> Indicator( tbl, 2 );
[ 1, 0, 0, 1, 1, 1 ]
\endexample

\Declaration{NrPolyhedralSubgroups}
\beginexample
gap> NrPolyhedralSubgroups( tbl, 2, 2, 4 );
rec( number := 21, type := "D8" )
\endexample

\Declaration{ClassMultiplicationCoefficient}[ctbl]!{for character tables}
\Declaration{ClassStructureCharTable}
\Declaration{MatClassMultCoeffsCharTable}
\beginexample
gap> tbl:= CharacterTable( "L3(2)" );;
gap> ClassMultiplicationCoefficient( tbl, 2, 2, 4 );
4
gap> ClassStructureCharTable( tbl, [ 2, 2, 4 ] );
168
gap> ClassStructureCharTable( tbl, [ 2, 2, 2, 4 ] );
1848
gap> MatClassMultCoeffsCharTable( tbl, 2 );
[ [ 0, 1, 0, 0, 0, 0 ], [ 21, 4, 3, 4, 0, 0 ], [ 0, 8, 6, 8, 7, 7 ], 
  [ 0, 8, 6, 1, 7, 7 ], [ 0, 0, 3, 4, 0, 7 ], [ 0, 0, 3, 4, 7, 0 ] ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Printing Character Tables}

\FileHeader[11]{ctbl}

\Declaration{DisplayOptions}
\beginexample
gap> tbl:= CharacterTable( "A5" );;
gap> Display( tbl );
A5

     2  2  2  .  .  .
     3  1  .  1  .  .
     5  1  .  .  1  1

       1a 2a 3a 5a 5b
    2P 1a 1a 3a 5b 5a
    3P 1a 2a 1a 5b 5a
    5P 1a 2a 3a 1a 1a

X.1     1  1  1  1  1
X.2     3 -1  .  A *A
X.3     3 -1  . *A  A
X.4     4  .  1 -1 -1
X.5     5  1 -1  .  .

A = -E(5)-E(5)^4
  = (1-ER(5))/2 = -b5
gap> CharacterTableDisplayDefaults.User:= rec(
>        powermap:= "ATLAS", centralizers:= "ATLAS", chars:= false );;
gap> Display( CharacterTable( "A5" ) );
A5

    60  4  3  5  5

 p      A  A  A  A
 p'     A  A  A  A
    1A 2A 3A 5A B*

gap> options:= rec( chars:= 4, classes:= [ tbl.3a .. tbl.5a ],
>                   centralizers:= false, indicator:= true,
>                   powermap:= [ 2 ] );;
gap> Display( tbl, options );
A5

          3a 5a
       2P 3a 5b
       2
X.4    +   1 -1
gap> SetDisplayOptions( tbl, options );  Display( tbl );
A5

          3a 5a
       2P 3a 5b
       2
X.4    +   1 -1
gap> Unbind( CharacterTableDisplayDefaults.User );
\endexample

\Declaration{PrintCharacterTable}
\beginexample
gap> PrintCharacterTable( CharacterTable( "Cyclic", 2 ), "tbl" );
tbl:= function()
local tbl;
tbl:=rec();
tbl.Irr:=
[ [ 1, 1 ], [ 1, -1 ] ];
tbl.NrConjugacyClasses:=
2;
tbl.Size:=
2;
tbl.OrdersClassRepresentatives:=
[ 1, 2 ];
tbl.SizesCentralizers:=
[ 2, 2 ];
tbl.UnderlyingCharacteristic:=
0;
tbl.ClassParameters:=
[ [ 1, 0 ], [ 1, 1 ] ];
tbl.CharacterParameters:=
[ [ 1, 0 ], [ 1, 1 ] ];
tbl.Identifier:=
"C2";
tbl.InfoText:=
"computed using generic character table for cyclic groups";
tbl.ComputedPowerMaps:=
[ , [ 1, 1 ] ];
ConvertToLibraryCharacterTableNC(tbl);
return tbl;
end;
tbl:= tbl();
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Computing the Irreducible Characters of a Group}

Several algorithms are available for computing the irreducible characters of
a finite group $G$.
The default method for arbitrary finite groups is to use the Dixon-Schneider
algorithm (see~"IrrDixonSchneider").
For supersolvable groups, Conlon's algorithm can be used (see~"IrrConlon").
For abelian-by-supersolvable groups, the Baum-Clausen algorithm for computing
the irreducible representations (see~"IrreducibleRepresentations")
can be used to compute the irreducible characters (see~"IrrBaumClausen").

These functions are installed in methods for `Irr' (see~"Irr"),
but explicitly calling one of them will *not* set the `Irr' value of $G$.

\Declaration{IrrDixonSchneider}
\Declaration{IrrConlon}
\Declaration{IrrBaumClausen}

In the following example we temporarily increase the line length limit from
its default value 80 to 87 in order to get a nicer output format.

\beginexample
gap> g:= SL(2,3);;
gap> SizeScreen([ 87, ]);;
gap> irr1:= IrrDixonSchneider( g );
[ Character( CharacterTable( SL(2,3) ), [ 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 1, E(3)^2, E(3), 1, E(3), E(3)^2, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 1, E(3), E(3)^2, 1, E(3)^2, E(3), 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 2, 1, 1, -2, -1, -1, 0 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 2, E(3)^2, E(3), -2, -E(3), -E(3)^2, 0 ] ),
  Character( CharacterTable( SL(2,3) ), [ 2, E(3), E(3)^2, -2, -E(3)^2, -E(3), 0 ] ),
  Character( CharacterTable( SL(2,3) ), [ 3, 0, 0, 3, 0, 0, -1 ] ) ]
gap> irr2:= IrrConlon( g );
[ Character( CharacterTable( SL(2,3) ), [ 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 1, E(3), E(3)^2, 1, E(3)^2, E(3), 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 1, E(3)^2, E(3), 1, E(3), E(3)^2, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 3, 0, 0, 3, 0, 0, -1 ] ) ]
gap> irr3:= IrrBaumClausen( g );
[ Character( CharacterTable( SL(2,3) ), [ 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 1, E(3), E(3)^2, 1, E(3)^2, E(3), 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 1, E(3)^2, E(3), 1, E(3), E(3)^2, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 3, 0, 0, 3, 0, 0, -1 ] ) ]
gap> SizeScreen([ 80, ]);;
gap> chi:= irr2[4];;  HasTestMonomial( chi );
true
\endexample

\Declaration{IrreducibleRepresentations}
\beginexample
gap> g:= AlternatingGroup( 4 );;
gap> repr:= IrreducibleRepresentations( g );
[ Pcgs([ (2,4,3), (1,3)(2,4), (1,2)(3,4) ]) -> 
    [ [ [ 1 ] ], [ [ 1 ] ], [ [ 1 ] ] ], 
  Pcgs([ (2,4,3), (1,3)(2,4), (1,2)(3,4) ]) -> 
    [ [ [ E(3) ] ], [ [ 1 ] ], [ [ 1 ] ] ], 
  Pcgs([ (2,4,3), (1,3)(2,4), (1,2)(3,4) ]) -> 
    [ [ [ E(3)^2 ] ], [ [ 1 ] ], [ [ 1 ] ] ], 
  Pcgs([ (2,4,3), (1,3)(2,4), (1,2)(3,4) ]) -> 
    [ [ [ 0, 0, 1 ], [ 1, 0, 0 ], [ 0, 1, 0 ] ], 
      [ [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, -1 ] ], 
      [ [ 1, 0, 0 ], [ 0, -1, 0 ], [ 0, 0, -1 ] ] ] ]
gap> ForAll( repr, IsGroupHomomorphism );
true
gap> Length( repr );
4
gap> gens:= GeneratorsOfGroup( g );
[ (1,2,3), (2,3,4) ]
gap> List( gens, x -> x^repr[1] );
[ [ [ 1 ] ], [ [ 1 ] ] ]
gap>  List( gens, x -> x^repr[4] );
[ [ [ 0, 0, -1 ], [ 1, 0, 0 ], [ 0, -1, 0 ] ], 
  [ [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ] ] ]
\endexample

\Declaration{IrreducibleRepresentationsDixon}
\beginexample
gap> a5:= AlternatingGroup( 5 );
Alt( [ 1 .. 5 ] )
gap> char:= First( Irr( a5 ), x -> x[1] = 4 );
Character( CharacterTable( Alt( [ 1 .. 5 ] ) ), [ 4, 0, 1, -1, -1 ] )
gap> hom:=IrreducibleRepresentationsDixon( a5, char );;
gap> Order( a5.1*a5.2 ) = Order( Image( hom, a5.1 )*Image( hom, a5.2 ) );
true
gap> reps:= List( ConjugacyClasses( a5 ), Representative );;
gap> List( reps, g -> TraceMat( Image( hom, g ) ) );
[ 4, 0, 1, -1, -1 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Representations given by modules}

\Declaration{IrreducibleModules}
\Declaration{AbsoluteIrreducibleModules}
\Declaration{RegularModule}

(Extensions by modules can be formed by the command `Extensions', see
"Extensions".)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The Dixon-Schneider Algorithm}

\atindex{Dixon-Schneider algorithm}{@Dixon-Schneider algorithm}

\FileHeader[1]{ctblgrp}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Advanced Methods for Dixon-Schneider Calculations}

\index{irreducible characters!computation}

The computation of irreducible characters of very large groups may take quite
some time.
On the other hand, for the expert only a few irreducible characters may be
needed,
since the other ones can be computed using character theoretic methods
such as tensoring, induction, and restriction.
Thus {\GAP} provides also step-by-step routines for doing the calculations.
These routines allow one to compute some characters and to stop before all
are calculated.
Note that there is no ``safety net'':
The routines (being somehow internal) do no error checking,
and assume the information given is correct.

When the info level of `InfoCharacterTable' if positive,
information about the progress of splitting is printed.
(The default value is zero.)

\Declaration{DixonRecord}
\Declaration{DixonInit}
\Declaration{DixontinI}
\Declaration{DixonSplit}
\Declaration{BestSplittingMatrix}
\Declaration{DxIncludeIrreducibles}
\Declaration{SplitCharacters}
\Declaration{IsDxLargeGroup}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Components of a Dixon Record}

The ``Dixon record'' <D> returned by `DixonInit' (see~"DixonInit")
stores all the information that is used by the Dixon-Schneider routines
while computing the irreducible characters of a group.
Some entries, however, may be useful to know about when using the algorithm
interactively (see~"An Example of Advanced Dixon-Schneider Calculations").
\beginitems
`group':&
the group $G$ of which the character table is to be computed,

`conjugacyClasses':&
classes of $G$ (all characters stored in the Dixon record correspond to this
arrangement of classes),

`irreducibles':&
the already known irreducible characters
(given as lists of their values on the conjugacy classes),

`characterTable':&
the `CharacterTable' value of $G$ (whose characters are not yet known),

`ClassElement( <D>, <el> )':&
a function that returns the number of the class of $G$ that contains the
element <el>.
\enditems


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{An Example of Advanced Dixon-Schneider Calculations}

First, we set the appropriate info level higher
\beginexample
gap> SetInfoLevel( InfoCharacterTable, 1 );
\endexample
for printout of some internal results.
We now define our group, which is isomorphic to ${\rm PSL}_4(3)$.
\beginexample
gap> g:= PrimitiveGroup(40,5);
PSL(4,3)
gap> Size(g);
6065280
gap> d:= DixonInit( g );;
#I  29 classes
#I  choosing prime 51481
gap> c:= d.characterTable;;
\endexample
After the initialisation, one structure matrix is evaluated,
yielding smaller spaces and several irreducible characters.
\beginexample
gap> DixonSplit( d );
#I  Matrix 7,Representative of Order 3,Centralizer: 5832
#I  Dimensions: [ 1, 1, 2, 12, 1, 4, 1, 2, 1, 2, 1 ]
#I  Two-dim space split
#I  Two-dim space split
#I  Two-dim space split
7
\endexample
In this case spaces of the listed dimensions are a result of the
splitting process.
The three two dimensional spaces are split successfully by combinatoric
means.

We obtain several irreducible characters by tensor products and notify them
to the Dixon record.
\beginexample
gap> asp:= AntiSymmetricParts( c, d.irreducibles, 2 );;
gap> ro:= ReducedOrdinary( c, d.irreducibles, asp );;
gap> Length( ro.irreducibles );
3
gap> DxIncludeIrreducibles( d, ro.irreducibles );
\endexample
The tensor products of the nonlinear characters among each other are reduced
with the irreducible characters.
The result is split according to the spaces found, which yields characters
of smaller norms, but no new irreducibles.
\beginexample
gap> nlc:= Filtered( d.irreducibles, i -> i[1] > 1 );;
gap> t:= Tensored( nlc, nlc );;
gap> ro:= ReducedOrdinary( c, d.irreducibles, t );;  ro.irreducibles;
[  ]
gap> List( ro.remainders, i -> ScalarProduct( c, i, i) );
[ 2, 2, 4, 4, 4, 4, 13, 13, 18, 18, 19, 21, 21, 36, 36, 29, 34, 34, 42, 34, 
  48, 54, 62, 68, 68, 78, 84, 84, 90, 88, 159, 169, 169, 172, 172, 266, 271, 
  271, 268, 274, 274, 280, 328, 373, 373, 456, 532, 576, 679, 683, 683, 754, 
  768, 768, 890, 912, 962, 1453, 1453, 1601, 1601, 1728, 1739, 1739, 1802, 
  2058, 2379, 2414, 2543, 2744, 2744, 2920, 3078, 3078, 4275, 4275, 4494, 
  4760, 5112, 5115, 5115, 5414, 6080, 6318, 7100, 7369, 7369, 7798, 8644, 
  10392, 12373, 12922, 14122, 14122, 18948, 21886, 24641, 24641, 25056, 
  38942, 44950, 78778 ]
gap> t:= SplitCharacters( d, ro.remainders );;
gap> List( t, i -> ScalarProduct( c, i, i ) );
[ 2, 2, 4, 2, 2, 4, 4, 6, 3, 5, 5, 9, 9, 4, 12, 13, 18, 18, 20, 18, 20, 26, 
  24, 32, 32, 16, 42, 59, 69, 69, 72, 72, 36, 72, 122, 127, 127, 64, 100, 
  144, 196, 274, 274, 280, 328, 373, 373, 456, 532, 576, 679, 683, 683, 754, 
  768, 768, 890, 912, 962, 1453, 1453, 1601, 1601, 1728, 1739, 1739, 1802, 
  2058, 2379, 2414, 2543, 2744, 2744, 2920, 3078, 3078, 4275, 4275, 4494, 
  4760, 5112, 5115, 5115, 5414, 6080, 6318, 7100, 7369, 7369, 7798, 8644, 
  10392, 12373, 12922, 14122, 14122, 18948, 21886, 24641, 24641, 25056, 
  38942, 44950, 78778 ]
\endexample
Finally we calculate the characters induced from all cyclic subgroups and
obtain the missing irreducibles by applying the LLL-algorithm to them.
\beginexample
gap> ic:= InducedCyclic( c, "all" );;
gap> ro:= ReducedOrdinary( c, d.irreducibles, ic );;
gap> Length( ro.irreducibles );
0
gap> l:= LLL( c, ro.remainders );;
gap> Length( l.irreducibles );
13
\endexample
The LLL returns class function objects (see Chapter~"Class Functions"),
and the Dixon record works with character values lists.
So we convert them to a list of values
before feeding them in the machinery of the Dixon-algorithm.
\beginexample
gap> l.irreducibles[1];
Character( CharacterTable( PSL(4, 3) ), [ 640, 0, 0, 0, 0, -8, -8, 0, 0, 0, 
  0, -8, 0, 0, 0, 0, 0, 0, E(13)^7+E(13)^8+E(13)^11, E(13)+E(13)^3+E(13)^9, 
  E(13)^2+E(13)^5+E(13)^6, E(13)^4+E(13)^10+E(13)^12, 0, 0, 0, 1, 0, 1, 1 ] )
gap> l:=List(l.irreducibles,ValuesOfClassFunction);;
gap> DxIncludeIrreducibles( d, l );
gap> Length( d.irreducibles );
29
gap> Length( d.classes );
29
\endexample
It turns out we have found all irreducible characters.
As the last step, we obtain the irreducible characters and tell them to the
group.
This makes them available also to the character table.
\beginexample
gap> irrs:= DixontinI( d );;
#I  Total:1 matrices,[ 7 ]
gap> SetIrr(g,irrs);
gap> Length(Irr(c));
29
gap> SetInfoLevel( InfoCharacterTable, 0 );
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Constructing Character Tables from Others}

\FileHeader[12]{ctbl}

\Declaration{CharacterTableDirectProduct}
\beginexample
gap> c2:= CharacterTable( "Cyclic", 2 );;
gap> s3:= CharacterTable( "Symmetric", 3 );;
gap> Display( CharacterTableDirectProduct( c2, s3 ) );
C2xSym(3)

     2  2  2  1  2  2  1
     3  1  .  1  1  .  1

       1a 2a 3a 2b 2c 6a
    2P 1a 1a 3a 1a 1a 3a
    3P 1a 2a 1a 2b 2c 2b

X.1     1 -1  1  1 -1  1
X.2     2  . -1  2  . -1
X.3     1  1  1  1  1  1
X.4     1 -1  1 -1  1 -1
X.5     2  . -1 -2  .  1
X.6     1  1  1 -1 -1 -1
\endexample

\Declaration{FactorsOfDirectProduct}

\Declaration{CharacterTableFactorGroup}
\beginexample
gap> s4:= CharacterTable( "Symmetric", 4 );;
gap> ClassPositionsOfNormalSubgroups( s4 );
[ [ 1 ], [ 1, 3 ], [ 1, 3, 4 ], [ 1 .. 5 ] ]
gap> f:= CharacterTableFactorGroup( s4, [ 3 ] );
CharacterTable( "Sym(4)/[ 1, 3 ]" )
gap> Display( f );
Sym(4)/[ 1, 3 ]

     2  1  1  .
     3  1  .  1

       1a 2a 3a
    2P 1a 1a 3a
    3P 1a 2a 1a

X.1     1 -1  1
X.2     2  . -1
X.3     1  1  1
\endexample

\Declaration{CharacterTableIsoclinic}
\beginexample
gap> d8:= CharacterTable( "Dihedral", 8 );;
gap> nsg:= ClassPositionsOfNormalSubgroups( d8 );
[ [ 1 ], [ 1, 3 ], [ 1 .. 3 ], [ 1, 3, 4 ], [ 1, 3 .. 5 ], [ 1 .. 5 ] ]
gap> q8:= CharacterTableIsoclinic( d8, nsg[3] );;
gap> Display( q8 );
Isoclinic(Dihedral(8))

     2  3  2  3  2  2

       1a 4a 2a 4b 4c
    2P 1a 2a 1a 2a 2a

X.1     1  1  1  1  1
X.2     1  1  1 -1 -1
X.3     1 -1  1  1 -1
X.4     1 -1  1 -1  1
X.5     2  . -2  .  .
\endexample

\Declaration{SourceOfIsoclinicTable}
\beginexample
gap> SourceOfIsoclinicTable( q8 );
[ CharacterTable( "Dihedral(8)" ), [ 1, 2, 3 ], 3 ]
\endexample

%Declaration{CharacterTableOfNormalSubgroup}

\Declaration{CharacterTableWreathSymmetric}
\beginexample
gap> c3:= CharacterTable( "Cyclic", 3 );;
gap> wr:= CharacterTableWreathSymmetric( c3, 2 );;
gap> Display( wr );
C3wrS2

     2  1   .   .   1  .   1  1   1   1
     3  2   2   2   2  2   2  1   1   1

       1a  3a  3b  3c 3d  3e 2a  6a  6b
    2P 1a  3b  3a  3e 3d  3c 1a  3c  3e
    3P 1a  1a  1a  1a 1a  1a 2a  2a  2a

X.1     1   1   1   1  1   1 -1  -1  -1
X.2     2   A  /A   B -1  /B  .   .   .
X.3     2  /A   A  /B -1   B  .   .   .
X.4     1 -/A  -A  -A  1 -/A -1  /A   A
X.5     2  -1  -1   2 -1   2  .   .   .
X.6     1  -A -/A -/A  1  -A -1   A  /A
X.7     1   1   1   1  1   1  1   1   1
X.8     1 -/A  -A  -A  1 -/A  1 -/A  -A
X.9     1  -A -/A -/A  1  -A  1  -A -/A

A = -E(3)^2
  = (1+ER(-3))/2 = 1+b3
B = 2*E(3)
  = -1+ER(-3) = 2b3
gap> CharacterParameters( wr )[1];
[ [ 1, 1 ], [  ], [  ] ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sorted Character Tables}

\Declaration{CharacterTableWithSortedCharacters}
\Declaration{SortedCharacters}
\Declaration{CharacterTableWithSortedClasses}
\Declaration{SortedCharacterTable}
\Declaration{ClassPermutation}

\beginexample
gap> tbl:= CharacterTable( "Symmetric", 4 );
CharacterTable( "Sym(4)" )
gap> Display( tbl );
Sym(4)

     2  3  2  3  .  2
     3  1  .  .  1  .

       1a 2a 2b 3a 4a
    2P 1a 1a 1a 3a 2b
    3P 1a 2a 2b 1a 4a

X.1     1 -1  1  1 -1
X.2     3 -1 -1  .  1
X.3     2  .  2 -1  .
X.4     3  1 -1  . -1
X.5     1  1  1  1  1
\endexample

\beginexample
gap> srt1:= CharacterTableWithSortedCharacters( tbl );
CharacterTable( "Sym(4)" )
gap> List( Irr( srt1 ), Degree );
[ 1, 1, 2, 3, 3 ]
gap> srt2:= CharacterTableWithSortedClasses( tbl );
CharacterTable( "Sym(4)" )
gap> SizesCentralizers( tbl );
[ 24, 4, 8, 3, 4 ]
gap> SizesCentralizers( srt2 );
[ 24, 8, 4, 3, 4 ]
gap> nsg:= ClassPositionsOfNormalSubgroups( tbl );
[ [ 1 ], [ 1, 3 ], [ 1, 3, 4 ], [ 1 .. 5 ] ]
gap> srt3:= SortedCharacterTable( tbl, nsg );
CharacterTable( "Sym(4)" )
gap> nsg:= ClassPositionsOfNormalSubgroups( srt3 );
[ [ 1 ], [ 1, 2 ], [ 1 .. 3 ], [ 1 .. 5 ] ]
gap> Display( srt3 );
Sym(4)

     2  3  3  .  2  2
     3  1  .  1  .  .

       1a 2a 3a 2b 4a
    2P 1a 1a 3a 1a 2a
    3P 1a 2a 1a 2b 4a

X.1     1  1  1  1  1
X.2     1  1  1 -1 -1
X.3     2  2 -1  .  .
X.4     3 -1  . -1  1
X.5     3 -1  .  1 -1
\endexample

\beginexample
gap> ClassPermutation( srt3 );
(2,4,3)
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Automorphisms and Equivalence of Character Tables}

\Declaration{MatrixAutomorphisms}
\Declaration{TableAutomorphisms}
\beginexample
gap> tbld8:= CharacterTable( "Dihedral", 8 );;
gap> irrd8:= Irr( tbld8 );
[ Character( CharacterTable( "Dihedral(8)" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "Dihedral(8)" ), [ 1, 1, 1, -1, -1 ] ), 
  Character( CharacterTable( "Dihedral(8)" ), [ 1, -1, 1, 1, -1 ] ), 
  Character( CharacterTable( "Dihedral(8)" ), [ 1, -1, 1, -1, 1 ] ), 
  Character( CharacterTable( "Dihedral(8)" ), [ 2, 0, -2, 0, 0 ] ) ]
gap> orders:= OrdersClassRepresentatives( tbld8 );
[ 1, 4, 2, 2, 2 ]
gap> MatrixAutomorphisms( irrd8 );
Group([ (4,5), (2,4) ])
gap> MatrixAutomorphisms( irrd8, [ orders ], Group( () ) );
Group([ (4,5) ])
gap> TableAutomorphisms( tbld8, irrd8 );
Group([ (4,5) ])
\endexample

\Declaration{TransformingPermutations}
\Declaration{TransformingPermutationsCharacterTables}
\beginexample
gap> tblq8:= CharacterTable( "Quaternionic", 8 );;
gap> irrq8:= Irr( tblq8 );
[ Character( CharacterTable( "Q8" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "Q8" ), [ 1, 1, 1, -1, -1 ] ), 
  Character( CharacterTable( "Q8" ), [ 1, -1, 1, 1, -1 ] ), 
  Character( CharacterTable( "Q8" ), [ 1, -1, 1, -1, 1 ] ), 
  Character( CharacterTable( "Q8" ), [ 2, 0, -2, 0, 0 ] ) ]
gap> OrdersClassRepresentatives( tblq8 );
[ 1, 4, 2, 4, 4 ]
gap> TransformingPermutations( irrd8, irrq8 );
rec( columns := (), rows := (), group := Group([ (4,5), (2,4) ]) )
gap> TransformingPermutationsCharacterTables( tbld8, tblq8 );
fail
gap> tbld6:= CharacterTable( "Dihedral", 6 );;
gap> tbls3:= CharacterTable( "Symmetric", 3 );;
gap> TransformingPermutationsCharacterTables( tbld6, tbls3 );
rec( columns := (2,3), rows := (1,3,2), group := Group(()) )
\endexample

\Declaration{FamiliesOfRows}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Storing Normal Subgroup Information}

\Declaration{NormalSubgroupClassesInfo}
\Declaration{ClassPositionsOfNormalSubgroup}
\Declaration{NormalSubgroupClasses}
\Declaration{FactorGroupNormalSubgroupClasses}
\beginexample
gap> g:= SymmetricGroup( 4 );
Sym( [ 1 .. 4 ] )
gap> SetName( g, "S4" );
gap> tbl:= CharacterTable( g );
CharacterTable( S4 )
gap> irr:= Irr( g );
[ Character( CharacterTable( S4 ), [ 1, -1, 1, 1, -1 ] ), 
  Character( CharacterTable( S4 ), [ 3, -1, -1, 0, 1 ] ), 
  Character( CharacterTable( S4 ), [ 2, 0, 2, -1, 0 ] ), 
  Character( CharacterTable( S4 ), [ 3, 1, -1, 0, -1 ] ), 
  Character( CharacterTable( S4 ), [ 1, 1, 1, 1, 1 ] ) ]
gap> kernel:= KernelOfCharacter( irr[3] );
Group([ (1,2)(3,4), (1,4)(2,3) ])
gap> HasNormalSubgroupClassesInfo( tbl );
true
gap> NormalSubgroupClassesInfo( tbl );
rec( nsg := [ Group([ (1,2)(3,4), (1,4)(2,3) ]) ], nsgclasses := [ [ 1, 3 ] ],
  nsgfactors := [  ] )
gap> ClassPositionsOfNormalSubgroup( tbl, kernel );
[ 1, 3 ]
gap> FactorGroupNormalSubgroupClasses( tbl, [ 1, 3 ] );
Group([ f1, f2 ])
gap> NormalSubgroupClassesInfo( tbl );
rec( nsg := [ Group([ (1,2)(3,4), (1,4)(2,3) ]) ], nsgclasses := [ [ 1, 3 ] ],
  nsgfactors := [ Group([ f1, f2 ]) ] )
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

