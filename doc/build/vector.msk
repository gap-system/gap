%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  vector.msk                  GAP documentation            Martin Schoenert
%A                                                           Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%%
\Chapter{Row Vectors}

Row vectors are dense homogeneous lists of field elements.

\Declaration{IsRowVector}
\beginexample
gap> IsVector([1,2,3]);
true
\endexample

Because row vectos are just a special case of lists, all operations and
functions for lists are applicable to matrices also (see chapter
"Lists"). This especially includes accessing elements of a row vector (see
"List Elements"), changing elements of a row vector (see "List Assignment"),
and comparing row vectors (see "Comparisons of Lists").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for row vectors}

\>`<vec1> + <vec2>'{vector!addition}

returns the sum of the two
vectors <vec1> and <vec2>, which must have the same length and be defined
over a common field. The sum is a new vector where each entry is the sum of
the corresponding entries of the vectors. As an exception it is also
possible to add an integer vector to a finite field vector, in which case
the integers are interpreted as `<scalar> \*\ One(<GF>)'.

\>`<scalar> + <vec>'{scalar!addition}
\>`<vec> + <scalar>'{scalar!addition}

returns a new vector
where each entry is the sum of the scalar and the corresponding entry of
the vector. The elements of <vec> must lie in a common field with <scalar>.
As an exception it is also possible to add an integer scalar
to a finite field vector, in which case the integer is interpreted as
`<scalar> \* One(<GF>)'.

\beginexample
gap> [ 1, 2, 3 ] + [ 1/2, 1/3, 1/4 ];
[ 3/2, 7/3, 13/4 ]
gap>  [ 1/2, 3/2, 1/2 ] + 1/2;
[ 1, 2, 1 ]
\endexample

\>`<vec1> - <vec2>'{vector!subtraction}
\>`<scalar> - <vec>'{scalar!subtraction}
\>`<vec> - <scalar>'{scalar!subtraction}

The difference operator `-' returns the componentwise difference of its
two operands and is defined subject to the same restrictions as `+'.

\beginexample
gap> [ 1, 2, 3 ] - [ 1/2, 1/3, 1/4 ];
[ 1/2, 5/3, 11/4 ]
gap> [ 1/2, 3/2, 1/2 ] - 1/2;
[ 0, 1, 0 ]
\endexample

`<vec1> * <vec2>'

returns the standard scalar product of <vec1> and <vec2>, which must have
the same length and be defined over the same field.
The product is the sum of the products of the
corresponding entries of the vectors. As an exception it is also
possible to multiply an integer vector to a finite field vector, in which
case the integers are interpreted as `<scalar> * One(<GF>)'.

\>`<scalar> * <vec>'{scalar!multiplication}
\>`<vec> * <scalar>'{scalar!multiplication}

returns the scalar product of <scalar> and <vector>. 
The elements of <vec> must lie in a common field with <scalar>.
The product is a new
vector where each entry is the product of the scalar and the
corresponding entry of the vector. As an exception it is also possible
to multiply an integer scalar to a finite field vector, in which case the
integer is interpreted as `<scalar> * One(<GF>)'.

\beginexample
gap> [ 1, 2, 3 ] * [ 1/2, 1/3, 1/4 ];
23/12
gap> [ 1/2, 3/2, 1/2 ] * 2;
[ 1, 3, 1 ]
\endexample

All arithmetic operations always return *immutable* vectors.

Further operations with vectors as operands are defined by the matrix
operations (see "Operations for Matrices").

\beginexample
gap> NormedRowVector([5,2,3]);
[ 1, 2/5, 3/5 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{More about Row Vectors}

In  the  first section of this  chapter  we defined  a  vector  as a list
without  holes   whose  elements  all come  from  a   common field.  This
representation is quite nice to  use.  However, suppose that {\GAP} would
have to check that a list is a  vector every time  this vector appears as
operand in a addition or multiplication.  This would be quite wasteful.

To avoid this a list that is a vector may, but need not, have an internal
flag set that  tells the operations that  this  list is  indeed a vector.
Then this operations do not  have to check  this operand and can  perform
the operation  right away.  This section  tells you when a vector obtains
this flag, so  you can write your  functions in such  a way that you make
best use of this feature.

The results of  vector  operations, i.e., binary operations  that involve
vectors, are known by construction to be  vectors, and thus have the flag
set upon creation.

If the operand of one of the binary operation is a list that does not yet
have the   flag set, those operations will   check  that this  operand is
indeed a vector and set the flag if it is.  If it is not a vector and not
a matrix an error is signalled.

If the argument to `IsVector' is a list that does not  yet have this flag
set, `IsVector' will  test if all elements come  from a common field.  If
they do, `IsVector'  will set the flag.   Thus on the one hand `IsVector'
is a test whether the argument is a vector.  On the other hand `IsVector'
can be used as a hint to {\GAP} that a certain list is indeed a vector.

If you  change  a vector, that does   have this flag set,  by assignment,
`Add', or  `Append', the vectors will loose  its flag, even if the change
is such that the resulting list is still a vector.  However if the vector
is a vector over a finite  field and you assign an  element from the same
finite field  the vector will keep its  flag.  Note that changing  a list
that is not a vector will never set the  flag, even if the resulting list
is  a vector.  Such a vector  will obtain the flag  only if it appears as
operand in a binary operation, or is passed to `IsVector'.

Vectors over  finite fields  have  one additional feature.   If  they are
known  to be  vectors, not only do  they have  the flag set, but also are
they represented differently.  This representation is much  more compact.
Instead of storing every element separately and storing for every element
separately in which field it lies, the field is only  stored once.   This
representation takes up to 10 times less memory.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Row Vectors over finite fields}

{\GAP} uses a compact format to store row vectors over GF(2).
\beginexample
gap> v:=[Z(2),0*Z(2)]; 
<a GF2 vector of length 2>
gap> v*Z(2);
<an immutable GF2 vector of length 2>
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Coefficient list arithmetic}

A list of ring elements can be interpreted as a row vector or coefficients
of a polynomial. There are a couple of functions that implement arithmetic
operations based on these interpretations.

\Declaration{ValuePol}
\beginexample
gap> ValuePol([1,2,3],4);
57
\endexample

\Declaration{ProductPol}
\beginexample
gap> ProductPol([1,2,3],[4,5,6]);
[ 4, 13, 28, 27, 18 ]
\endexample

\FileHeader{listcoef}[2]

\Declaration{AddCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;AddCoeffs(l,m);
4
gap> l;
[ 6, 8, 10, 4 ]
\endexample

\Declaration{CoeffsMod}
\beginexample
gap> l:=[1,2,3,4];;CoeffsMod(l,2);
[ 1, 0, 1 ]
\endexample

\Declaration{MultCoeffs}
\beginexample
gap> a:=[];;l:=[1,2,3,4];;m:=[5,6,7];;
gap> MultCoeffs(a,l,4,m,3);
6
gap> a;
[ 5, 16, 34, 52, 45, 28 ]
\endexample

\Declaration{PowerModCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;PowerModCoeffs(l,5,m); 
[ -839462813696/678223072849, -7807439437824/678223072849, 0 ]
\endexample

\Declaration{ProductCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;ProductCoeffs(l,m);   
[ 5, 16, 34, 52, 45, 28 ]
\endexample

\Declaration{ReduceCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;ReduceCoeffs(l,m); 
2
gap> l;
[ 64/49, -24/49, 0, 0 ]
\endexample

\Declaration{ReduceCoeffsMod}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;ReduceCoeffsMod(l,m,3);
1
gap> l;
[ 1, 0, 0, 0 ]
\endexample

\Declaration{RemoveOuterCoeffs}
\beginexample
gap> l:=[1,1,2,1,2,1,1,2,1];;RemoveOuterCoeffs(l,1);
2
gap> l;
[ 2, 1, 2, 1, 1, 2 ]
\endexample

\Declaration{ShiftedCoeffs}
\beginexample
gap> l:=[1,2,3];;ShiftedCoeffs(l,2);ShiftedCoeffs(l,-2);    
[ 0, 0, 1, 2, 3 ]
[ 3 ]
\endexample

\Declaration{ShrinkCoeffs}
\beginexample
gap> l:=[1,0,0];;ShrinkCoeffs(l);l;
1
[ 1 ]
\endexample



\Declaration{AddRowVector}
\Declaration{MultRowVector}
\Declaration{LeftShiftRowVector}
\Declaration{RightShiftRowVector}
\Declaration{ShrinkRowVector}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Functions for coding theory}

\FileHeader{listcoef}[2]

\Declaration{WeightVecFFE}
\Declaration{DistanceVecFFE}
\Declaration{DistancesDistributionVecFFEsVecFFE}
\Declaration{DistancesDistributionMatFFEVecFFE}
\Declaration{AClosestVectorCombinationsMatFFEVecFFE}
\Declaration{CosetLeadersMatFFE}
