%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  vector.msk                  GAP documentation            Martin Schoenert
%A                                                           Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%%
\Chapter{Row Vectors}

Just as in mathematics, a vector in {\GAP} is any object which
supports appropriate addition and scalar multiplication operations
(see "Vector Spaces"). As in mathematics, an especially important
class of vectors are those represented by a list of coefficients with
respect to some basis. These correspond roughly to the {\GAP} concept
of *row vectors*.

\Declaration{IsRowVector}
\beginexample
gap> IsRowVector([1,2,3]);
true
\endexample

Because row vectors are just a special case of lists, all operations
and functions for lists are applicable to row vectors as well (see
chapter "Lists"). This especially includes accessing elements of a row
vector (see "List Elements"), changing elements of a mutable row
vector (see "List Assignment"), and comparing row vectors (see
"Comparisons of Lists").

Note that, unless your algorithms specifically require you to be able
to change entries of your vectors, it is generally better and faster
to work with immutable row vectors. See section "Mutability and
Copyability" for more details.

%%  The basic design of the row vector support in {\GAP} 4 is due to
%%  Martin Sch{\"o}nert. Frank Celler added the special support for
%%  vectors over the field of two elements; Steve Linton added special
%%  support for vectors over fields of sizes between 3 and 256; and Werner
%%  Nickel added special methods for vectors over large finite fields.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operators for Row Vectors}

The rules for arithmetic operations between row vectors, are in fact
the same as those for the arithmetic of lists, given in part in
section "Arithmetic for Lists", here we reiterate and complete that definition,
 in the language of vectors.

\>`<vec1> + <vec2>'{vector!addition} O

returns the sum of the two vectors <vec1> and <vec2>, which must have the
same length and be defined over a common field. The sum is a new vector
where each entry is the sum of the corresponding entries of the vectors. As
an exception it is also possible to add an integer vector to a vector over
the finite field <F>, in which case the integers are interpreted as
`<scalar> \*\ One(<F>)'.

\>`<scalar> + <vec>'{scalar!addition} O
\>`<vec> + <scalar>'{scalar!addition} O

returns a new vector where each entry is the sum of the scalar and the
corresponding entry of the vector. The elements of <vec> must lie in a
common field with <scalar>.  As an exception it is also possible to add an
integer scalar to a vector over the finite field <F>, in which case the
integer is interpreted as `<scalar> \* One(<F>)'.

\beginexample
gap> [ 1, 2, 3 ] + [ 1/2, 1/3, 1/4 ];
[ 3/2, 7/3, 13/4 ]
gap>  [ 1/2, 3/2, 1/2 ] + 1/2;
[ 1, 2, 1 ]
\endexample

\>`<vec1> - <vec2>'{vector!subtraction} O
\>`<scalar> - <vec>'{scalar!subtraction} O
\>`<vec> - <scalar>'{scalar!subtraction} O

The difference operator `-' returns the componentwise difference of its
two operands and is defined subject to the same restrictions as `+'.

\beginexample
gap> [ 1, 2, 3 ] - [ 1/2, 1/3, 1/4 ];
[ 1/2, 5/3, 11/4 ]
gap> [ 1/2, 3/2, 1/2 ] - 1/2;
[ 0, 1, 0 ]
\endexample

\>`<vec1> * <vec2>'{scalar product} O

returns the standard scalar product of <vec1> and <vec2>, which must
both have the same length and take their entries from the same
field. As remarked above, the system only provides a general method
for the case where the vectors lie in `IsRingElementList'.  The
product is the sum of the products of the corresponding entries of the
vectors. As an exception it is also possible to multiply an integer
vector to a finite field vector, in which case the integers are
interpreted as `<scalar> * One(<GF>)'.

\>`<scalar> * <vec>'{scalar!multiplication} O
\>`<vec> * <scalar>'{scalar!multiplication} O

returns the product of <scalar> and <vector>. 
The elements of <vec> must lie in a common field with <scalar>.
The product is a new
vector where each entry is the product of the scalar and the
corresponding entry of the vector. As an exception it is also possible
to multiply an integer scalar to a finite field vector, in which case the
integer is interpreted as `<scalar> * One(<GF>)'.

\beginexample
gap> [ 1, 2, 3 ] * [ 1/2, 1/3, 1/4 ];
23/12
gap> [ 1/2, 3/2, 1/2 ] * 2;
[ 1, 3, 1 ]
\endexample

For the mutability of results of arithmetic operations,
see~"Mutability and Copyability".

Further operations with vectors as operands are defined by the matrix
operations (see~"Operators for Matrices").

\Declaration{NormedRowVector}
\beginexample
gap> NormedRowVector([5,2,3]);
[ 1, 2/5, 3/5 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Row Vectors over Finite Fields}

{\GAP} can use compact formats to store row vectors over fields of
order at most 256, based on those used by the Meat-Axe
\cite{Rin93}. This format also permits extremely efficient vector
arithmetic. On the other hand element access and assignment is
significantly slower than for plain lists.

The function `ConvertToVectorRep' is used to convert a list into a
compressed vector, or to rewrite a compressed vector ove another
field. Note that this function is *much* faster when it is given a
field (or field size) as an argument, rather than having to scan the
vector and try to decide the field. Supplying the field can also
avoid errors and/or loss of performance, when one vector from some
collection happens to have all of its entries over a smaller field
than the \"natural\" field of the problem.

\Declaration{ConvertToVectorRep}

In this example, we first creat a row vector and then ask {\GAP} to
rewrite it, first over GF(2) and then over GF(4).

\beginexample
gap> v := [Z(2)^0,Z(2),Z(2),0*Z(2)];
[ Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2) ]
gap> RepresentationsOfObject(v);
[ "IS_PLIST_REP", "IsInternalRep" ]
gap> ConvertToVectorRep(v);
2
gap> v;
<a GF2 vector of length 4>
gap> ConvertToVectorRep(v,4);
4
gap> v;
[ Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2) ]
gap> RepresentationsOfObject(v);
[ "IsDataObjectRep", "Is8BitVectorRep" ]
\endexample


A vector in the special representation over $GF(2)$ is always viewed
as `\<a GF2 vector of length ...>'. Over fields of orders 3 to 256, a
vector of length 10 or less is viewed as the list of its coefficients, 
but a longer one is abbreviated.


\Declaration{NumberFFVector}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Coefficient List Arithmetic}

\FileHeader{listcoef}[1]
\Declaration{AddRowVector}

\Declaration{AddCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;AddCoeffs(l,m);
4
gap> l;
[ 6, 8, 10, 4 ]
\endexample

\Declaration{MultRowVector}

\Declaration{CoeffsMod}
\beginexample
gap> l:=[1,2,3,4];;CoeffsMod(l,2);
[ 1, 0, 1 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Shifting and Trimming Coefficient Lists}

\FileHeader{listcoef}[3]
\Declaration{LeftShiftRowVector}
\Declaration{RightShiftRowVector}
\Declaration{ShrinkRowVector}

\Declaration{RemoveOuterCoeffs}
\beginexample
gap> l:=[1,1,2,1,2,1,1,2,1];;RemoveOuterCoeffs(l,1);
2
gap> l;
[ 2, 1, 2, 1, 1, 2 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Functions for Coding Theory}

\FileHeader{listcoef}[4]

\Declaration{WeightVecFFE}
\Declaration{DistanceVecFFE}
\Declaration{DistancesDistributionVecFFEsVecFFE}
\Declaration{DistancesDistributionMatFFEVecFFE}
\Declaration{AClosestVectorCombinationsMatFFEVecFFE}
\Declaration{CosetLeadersMatFFE}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Vectors as coefficients of polynomials}


A list of ring elements can be interpreted as a row vector or the list of
coefficients of a polynomial. There are a couple of functions that implement
arithmetic operations based on these interpretations. {\GAP} contains proper
support for polynomials (see~"Polynomials and Rational Functions"), the
operations described in this section are on a lower level.

\FileHeader{listcoef}[2]

\Declaration{ValuePol}
\beginexample
gap> ValuePol([1,2,3],4);
57
\endexample

%\ Declaration{ProductPol}
%\ beginexample
%gap> ProductPol([1,2,3],[4,5,6]);
%[ 4, 13, 28, 27, 18 ]
%\ endexample

%\ Declaration{MultCoeffs}
%\ beginexample
%gap> a:=[];;l:=[1,2,3,4];;m:=[5,6,7];;
%gap> MultCoeffs(a,l,4,m,3);
%6
%gap> a;
%[ 5, 16, 34, 52, 45, 28 ]
%\ endexample

\Declaration{ProductCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;ProductCoeffs(l,m);   
[ 5, 16, 34, 52, 45, 28 ]
\endexample

\Declaration{ReduceCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;ReduceCoeffs(l,m); 
2
gap> l;
[ 64/49, -24/49, 0, 0 ]
\endexample

\Declaration{ReduceCoeffsMod}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;ReduceCoeffsMod(l,m,3);
1
gap> l;
[ 1, 0, 0, 0 ]
\endexample

\Declaration{PowerModCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;PowerModCoeffs(l,5,m); 
[ -839462813696/678223072849, -7807439437824/678223072849, 0 ]
\endexample

\Declaration{ShiftedCoeffs}
\beginexample
gap> l:=[1,2,3];;ShiftedCoeffs(l,2);ShiftedCoeffs(l,-2);    
[ 0, 0, 1, 2, 3 ]
[ 3 ]
\endexample

\Declaration{ShrinkCoeffs}
\beginexample
gap> l:=[1,0,0];;ShrinkCoeffs(l);l;
1
[ 1 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

