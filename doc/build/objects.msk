%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  objects.msk              GAP manual                     Thomas Breuer
%W                                                       Martin Schoenert
%%
%H  @(#)$Id$
%%

%T modify and use the text in `object.gd' for the discussion of
%T mutability and copyability
%T (in particular for `IsMutable' and `IsCopyable').

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Objects and Elements}

An *object* is anything in {\GAP} that can be assigned to a variable,
so nearly everything in {\GAP} is an object.

Different objects can be regarded as equal with respect to the equivalence
relation `{`='}',
in this case we say that the objects describe the same *element*.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Objects}

Nearly all things one deals with in {\GAP} are *objects*.
For example, an integer is an object, as is a list of integers, a matrix,
a permutation, a function, a list of functions, a record, a group,
a coset or a conjugacy class in a group.

Examples of things that are not objects are
comments which are only lexical constructs,
`while' loops which are only syntactical constructs,
and expressions, such as `1 + 1';
but note that the value of an expression, in this case the integer `2',
is an object.

Objects can be assigned to variables,
and everything that can be assigned to a variable is an object.
Analogously, objects can be used as arguments of functions, and can be 
returned by functions.

\Declaration{IsObject}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Elements as equivalence classes}

\index{elements!definition}
The equality operation ``{`='}'' defines an equivalence relation on all
{\GAP} objects.
The equivalence classes are called *elements*.

There are basically three reasons to regard different objects as
equal.  Firstly the same information may be stored in different
places.  Secondly the same information may be stored in different
ways; for example, a polynomial can be stored sparsely or densely.
Thirdly different information may be equal modulo a mathematical
equivalence relation.  For example, in a finitely presented group with
the relation $a^2 = 1$ the different objects $a$ and $a^3$ describe
the same element.

As an example of all three reasons, consider the possibility of storing
an integer in several places of the memory,
of representing it as a fraction with denominator 1,
or of representing it as a fraction with any denominator, and numerator
a suitable multiple of the denominator. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sets}

In {\GAP} there is no category whose definition corresponds to the
mathematical property of being a set, however 
in the manual we will often refer to an object as a *set* 
in order to convey the fact that mathematically, we are thinking of
it as a set. In particular, two sets $A$ and $B$ are equal if and only if,
$x \in A \iff x \in B$.  

There are two types of object in {\GAP} which exhibit this kind of behaviour
with respect to equality, namely domains (see Section~"Domains") and lists 
whose elements are strictly sorted see `IsSSortedList' 
(see "IsSSortedList"). In general, *set* in this manual
will mean an object of one of these types.

More precisely: two domains can be compared with ``{`='}'',
the answer being `true' if and only if the sets of elements
are equal (regardless of any additional structure) and;
a domain and a list can be compared with ``{`='}'',
the answer being `true' if and only if the list is equal to
the strictly sorted list of elements of the domain.

A discussion about sorted lists and sets can be found
in the Reference Manual section ``Sorted Lists and Sets'' 
"Sorted Lists and Sets".




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Domains}

An especially important class of objects in {\GAP} are those whose
underlying mathematical abstraction is that of a  structured set, for
example a group, a conjugacy class, or a vector space.  Such objects
are called *domains*.  The equality relation between domains is always 
equality *as sets*, so that two domains are equal if and only if they
contain the same elements.

Domains play a central role in {\GAP}.  In a sense, the only reason
that {\GAP} supports objects such as integers and permutations is the
wish to form domains of them and compute the properties of those domains.

Domains are described in Chapter~"Domains and their Elements".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Identical Objects}

Two objects that are equal *as objects* (that is they actually refer
to the same area of computer memory) and not only w.r.t. the equality
relation `{`='}' are called *identical*.  Identical objects do of
course describe the same element.

\Declaration{IsIdenticalObj}

If two copies of a simple constant object (see section "Mutability and
Copyability") are created, it is not defined whether {\GAP} will
actually store two equal but non-identical objects, or just a single
object. For mutable objects, however, it is important to know whether
two value refer to identical or non-identical objects, and the
documentation of operations that return mutable values should make
clear whether the values returned are new, or may be identical to
values stored elsewhere.

\beginexample
gap> IsIdenticalObj( 10^6, 10^6);
true
gap> IsIdenticalObj( 10^12, 10^12);
false
gap> IsIdenticalObj( true, true);
true
\endexample

Generally, one may compute with objects but think of the results in
terms of the underlying elements because one is not interested in
locations in memory, data formats or information beyond underlying
equivalence relations. But there are cases where it is important to
distinguish the relations identity and equality.  This is best
illustrated with an example.  (The reader who is not familiar with
lists in {\GAP}, in particular element access and assignment, is
referred to Chapter~"Lists".)
\beginexample
gap> l1:= [ 1, 2, 3 ];; l2:= [ 1, 2, 3 ];;
gap> l1 = l2;
true
gap> IsIdenticalObj( l1, l2 );
false
gap> l1[3]:= 4;; l1; l2;
[ 1, 2, 4 ]
[ 1, 2, 3 ]
gap> l1 = l2;
false
\endexample
The two lists `l1' and `l2' are equal but not identical.
Thus a change in `l1' does not affect `l2'.
\beginexample
gap> l1:= [ 1, 2, 3 ];; l2:= l1;;
gap> l1 = l2;
true
gap> IsIdenticalObj( l1, l2 );
true
gap> l1[3]:= 4;; l1; l2;
[ 1, 2, 4 ]
[ 1, 2, 4 ]
gap> l1 = l2;
true
\endexample
Here, `l1' and `l2' are identical objects,
so changing `l1' means a change to `l2' as well.

The library also provides:

\Declaration{IsNotIdenticalObj}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Mutability and Copyability}

An object in {\GAP} is said to be *immutable* if its mathematical value
(as defined by $=$) does not change under any operation.
More explicitly, suppose $a$ is immutable and $O$ is some operation on $a$,
then if $a = b$ evaluates to `true' before executing $O(a)$,
$a = b$ also evaluates to `true' afterwards. 
(Examples for operations $O$ that change mutable objects are `Add' and
`Unbind' which are used to change list objects, see Chapter~"Lists".)
An immutable object *may* change, for example to store
new information, or to adopt a more efficient representation,
but this does not affect its behaviour under $=$.

There are two points here to note. Firstly, ``operation'' above 
refers to the functions and methods which can legitimately be
applied to the object, and not the `!.' operation whereby 
virtually any aspect of any {\GAP} level object may be changed.
The second point which follows from this, is that when 
implementing new types of objects, it is the programmer's
responsibility to ensure that the functions and methods they write
never change immutable objects mathematically.

In fact, most objects with which one deals in {\GAP} are immutable. 
For instance, the permutation `(1,2)' will never become a
different permutation or a non-permutation (although a variable which
previously had `(1,2)' stored in it may subsequently have some other
value). 

For many purposes, however, *mutable* objects are useful.  These
objects may be changed to represent different mathematical objects during 
their life. For example, mutable lists can be changed by assigning values to
positions or by unbinding values at certain positions.  Similarly, one
can assign values to components of a mutable record, or unbind them.

\Declaration{IsCopyable}

Objects for which only an immutable form exists in {\GAP} are called
*constants*.
Examples of constants are integers, permutations, and domains.
Called with a constant as argument,
`Immutable' and `ShallowCopy' return this argument.

\Declaration{IsMutable}

In many situations, however, one wants to ensure that objects are
*immutable*. For example, take the identity of a matrix group.  Since
this matrix may be referred to as the identity of the group in several
places, it would be fatal to modify its entries, or add or unbind
rows. We can obtain an immutable copy of an object with:

\Declaration{Immutable}

\>MakeImmutable( <obj> ) F

One can turn the (mutable or immutable) object <obj> into an immutable
one with `MakeImmutable'; note that this also makes all subobjects of
<obj> immutable, so one should call `MakeImmutable' only if <obj> and
its mutable subobjects are newly created.  If one is not sure about
this, `Immutable' should be used.

Note that it is *not* possible to turn an immutable object into a
mutable one;
only mutable copies can be made (see~"Duplication of Objects").

Using `Immutable', it is possible to store an immutable identity
matrix or an immutable list of generators, and to pass around
references to this immutable object safely.  Only when a mutable
copy is really needed does the actual object have to be duplicated.
Compared to the situation without immutable objects, much unnecessary
copying is avoided this way.  Another advantage of immutability is
that lists of immutable objects may remember whether they are sorted
(see~"Sorted Lists and Sets"), which is not possible for lists of
mutable objects.

Since the operation `Immutable' must work for any object in {\GAP}, it 
follows that an immutable form of every object must be possible, even
if it is not sensible, and user-defined objects must allow for the
possibility of becoming immutable without notice. 

Another interesting example of mutable (and thus copyable) objects is
provided by *iterators*, see~"Iterators".
(Of course an immutable form of an iterator is not very useful,
but clearly `Immutable' will yield such an object.)
Every call of `NextIterator' changes a mutable iterator until it is
exhausted, and this is the only way to change an iterator.
`ShallowCopy' for an iterator <iter> is defined so as to return a
mutable iterator that has no mutable data in common with <iter>,
and that behaves equally to <iter> w.r.t.~`IsDoneIterator' and (if <iter>
is mutable) `NextIterator'.
Note that this meaning of the ``shallow copy'' of an iterator
that is returned by `ShallowCopy' is not as obvious as for lists and records,
and must be explicitly defined.

Many operations return immutable results, among those in particular
attributes (see~"Attributes").  Examples of attributes are `Size',
`Zero', `AdditiveInverse', `One', and `Inverse'.  Arithmetic
operations, such as the binary infix operations `+', `-', `*', `/',
`^', `mod', the unary `-', and operations such as `Comm' and
`LeftQuotient', return *mutable* results, *except* if all arguments
are immutable.  So the product of two matrices or of a vector and a
matrix is immutable if and only if the two matrices or both the vector
and the matrix are immutable (see also~"Arithmetic for Lists"). There
is one exception to this rule, which arises where the result is less
deeply nested that at least one of the argument, where mutable
arguments may sometimes lead to an immutable result. For instance, a
mutable matrix with immutable rows, multiplied by an immutable vector
gives an immutable vector result. The exact rules are given 
in~"Arithmetic for Lists".


It should be noted that
`0 \* <obj>' is equivalent to `ZeroSM( <obj> )',
`-<obj>' is equivalent to `AdditiveInverseSM( <obj> )',
`<obj>^0' is equivalent to `OneSM( <obj>)',
and `<obj>^-1' is equivalent to `InverseSM( <obj> )'.
The ``SM'' stands for ``same mutability'', and indicates that the result is
mutable if and only if the argument is mutable.

The operations `ZeroOp', `AdditiveInverseOp', `OneOp', and `InverseOp'
return *mutable* results whenever a mutable version of the result exists,
contrary to the attributes `Zero', `AdditiveInverse', `One', and `Inverse'.

If one introduces new arithmetic objects then one need not install
methods for the attributes `One', `Zero', etc.
The methods for the associated operations `OneOp' and `ZeroOp'
will be called, and then the results made immutable. 

All methods installed for the arithmetic operations must obey the rule
about the mutability of the result.  This means that one may try to
avoid the perhaps expensive creation of a new object if both operands
are immutable, and of course no problems of this kind arise at all in
the (usual) case that the objects in question do not admit a mutable form,
i.e., that these objects are not copyable.

In a few, relatively low-level algorithms, one wishes to treat a
matrix partly as a data structure, and manipulate and change its
entries.  For this, the matrix needs to be mutable, and the rule that
attribute values are immutable is an obstacle.  For these situations,
a number of additional operations are provided, for example
`TransposedMatMutable' constructs a mutable matrix (contrary to the
attribute `TransposedMat'), while `TriangulizeMat' modifies a mutable
matrix (in place) into upper triangular form.

Note that being immutable does not forbid an object to store
knowledge.  For example, if it is found out that an immutable list is
strictly sorted then the list may store this information.  More
precisely, an immutable object may change in any way, provided that it
continues to represent the same mathematical object.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Duplication of Objects}

\index{Copy}
\index{copy!an object}\index{clone!an object}
\Declaration{ShallowCopy}

\Declaration{StructuralCopy}
\beginexample
gap> obj:= [ [ 0, 1 ] ];;
gap> obj[2]:= obj[1];;
gap> obj[3]:= Immutable( obj[1] );;
gap> scp:= StructuralCopy( obj );;
gap> scp = obj; IsIdenticalObj( scp, obj );
true
false
gap> IsIdenticalObj( scp[1], obj[1] );
false
gap> IsIdenticalObj( scp[3], obj[3] );
true
gap> IsIdenticalObj( scp[1], scp[2] );
true
\endexample

That both `ShallowCopy' and `StructuralCopy' return the argument <obj>
itself if it is not copyable is consistent with this definition,
since there is no way to change <obj> by modifying the result of any of
the two functions,
because in fact there is no way to change this result at all.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Other Operations Applicable to any Object}

There are a number of general operations which can be applied, in
principle, to any object in {\GAP}. Some of these are documented
elsewhere -- see "String", "PrintObj" and
"Display". Others are mainly somewhat technical.

\>SetName( <obj>, <name> ) F

for a suitable object <obj> sets that object to have  name  <name>  (a
string).

\Declaration{Name}

\beginexample
gap> R := PolynomialRing(Integers,2);
Integers[x_1,x_2]
gap> SetName(R,"Z[x,y]");
gap> R;
Z[x,y]
gap> Name(R);
"Z[x,y]"
\endexample

\Declaration{IsInternallyConsistent}

\>MemoryUsage( <obj> ) O

returns the amount of memory in bytes used by the object <obj> and its
subobjects. Note that in general, objects can reference each other
in very difficult ways such that determining the memory usage is
a recursive procedure. In particular, computing the memory usage
of a complicated structure itself uses some additional memory,
which is however no longer used after completion of this operation.
This procedure descents into lists and records, positional and
component objects, however it does not take into account the type
and family objects! For functions, it only takes the memory usage
of the function body, not of the local context the function was
created in, although the function keeps a reference to that as well!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E
