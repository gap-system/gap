%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  alglie.msk                  GAP documentation             Willem de Graaf
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%%
\Chapter{Lie Algebras}

\FileHeader[1]{alglie}

%%  The algorithms for Lie algebras are due to Willem de Graaf.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Lie objects}

\FileHeader[1]{liefam}

\Declaration{LieObject}

\beginexample
gap> m:= [ [ 1, 0 ], [ 0, 1 ] ];;
gap> lo:= LieObject( m ); 
LieObject( [ [ 1, 0 ], [ 0, 1 ] ] )
gap> m*m; 
[ [ 1, 0 ], [ 0, 1 ] ]
gap> lo*lo;
LieObject( [ [ 0, 0 ], [ 0, 0 ] ] )
\endexample

\Declaration{IsLieObject}

\beginexample
gap> m:= [ [ 1, 0 ], [ 0, 1 ] ];;
gap> lo:= LieObject( m ); 
LieObject( [ [ 1, 0 ], [ 0, 1 ] ] )
gap> IsLieObject( m );
false
gap> IsLieObject( lo );
true
\endexample

\Declaration{LieFamily}

\Declaration{UnderlyingFamily}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Constructing Lie algebras}

In this section we describe functions that create Lie algebras. Creating
and working with subalgebras goes exactly in the same way as for general
algebras; so for that we refer to Chapter "ref:algebras".

\Declaration{LieAlgebraByStructureConstants}

\beginexample
gap> T:= EmptySCTable( 2, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [ 1/2, 1 ] );        
gap> L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 2 over Rationals>
\endexample

\Declaration{LieAlgebra}

\beginexample
gap> A:= FullMatrixAlgebra( GF( 7 ), 4 );;
gap> L:= LieAlgebra( A );
<Lie algebra of dimension 16 over GF(7)>
gap> mats:= [  [[ 1, 0 ], [ 0, -1 ]], [[ 0, 1 ], [ 0, 0 ]], [[ 0, 0 ], [ 1, 0]] ];;
gap> L:= LieAlgebra( Rationals, mats );
<Lie algebra over Rationals, with 3 generators>
\endexample

\Declaration{FreeLieAlgebra}

\beginexample
gap> L:= FreeLieAlgebra( Rationals, "x", "y", "z" );
<Lie algebra over Rationals, with 3 generators>
gap> g:= GeneratorsOfAlgebra( L );; x:= g[1];; y:=g[2];; z:= g[3];;
gap> z*(y*(x*(z*y)));
(-1)*((x*(y*z))*(y*z))+(-1)*((x*((y*z)*z))*y)+(-1)*(((x*z)*(y*z))*y)
\endexample

\Declaration{FullMatrixLieAlgebra}

\beginexample
gap> FullMatrixLieAlgebra( GF(9), 10 );
<Lie algebra over GF(3^2), with 19 generators>
\endexample

\Declaration{RightDerivations}

\beginexample
gap> A:= OctaveAlgebra( Rationals );
<algebra of dimension 8 over Rationals>
gap> L:= Derivations( Basis( A ) );
<Lie algebra of dimension 14 over Rationals>
\endexample

\Declaration{SimpleLieAlgebra}

\beginexample
gap> SimpleLieAlgebra( "E", 6, Rationals );
<Lie algebra of dimension 78 over Rationals>
gap> SimpleLieAlgebra( "A", 6, GF(5) );    
<Lie algebra of dimension 48 over GF(5)>
gap> SimpleLieAlgebra( "W", [1,2], GF(5) );
<Lie algebra of dimension 250 over GF(5)>
gap> SimpleLieAlgebra( "H", [1,2], GF(5) );
<Lie algebra of dimension 123 over GF(5)>
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Distinguished Subalgebras}

Here we describe functions that calculate well-known subalgebras
and ideals of a Lie algebra (such as the centre, the centralizer of a
subalgebra, etc.).

\Declaration{LieCentre}

\beginexample
gap> L:= FullMatrixLieAlgebra( GF(3), 3 );
<Lie algebra over GF(3), with 5 generators>
gap> LieCentre( L );
<two-sided ideal in <Lie algebra of dimension 9 over GF(3)>, (dimension 1)>
\endexample


\Declaration{LieCentralizer}

\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );
<Lie algebra of dimension 14 over Rationals>
gap> b:= BasisVectors( Basis( L ) );;
gap> LieCentralizer( L, Subalgebra( L, [ b[1], b[2] ] ) );
<Lie algebra of dimension 1 over Rationals>
\endexample



\Declaration{LieNormalizer}

\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );             
<Lie algebra of dimension 14 over Rationals>
gap> b:= BasisVectors( Basis( L ) );;
gap> LieNormalizer( L, Subalgebra( L, [ b[1], b[2] ] ) );      
<Lie algebra of dimension 8 over Rationals>
\endexample

\Declaration{LieDerivedSubalgebra}

\beginexample
gap>  L:= FullMatrixLieAlgebra( GF( 3 ), 3 );
<Lie algebra over GF(3), with 5 generators>
gap> LieDerivedSubalgebra( L );
<Lie algebra of dimension 8 over GF(3)>
\endexample


\Declaration{LieNilRadical}

In the following two examples we temporarily increase the line length limit
from its default value 80 to 81 in order to make the long output expressions
fit each into one line.

\beginexample
gap> mats:= [ [[1,0],[0,0]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap> L:= LieAlgebra( Rationals, mats );;
gap> SizeScreen([ 81, ]);;
gap> LieNilRadical( L );
<two-sided ideal in <Lie algebra of dimension 3 over Rationals>, (dimension 2)>
gap> SizeScreen([ 80, ]);;
\endexample



\Declaration{LieSolvableRadical}

\beginexample
gap> L:= FullMatrixLieAlgebra( Rationals, 3 );;
gap> SizeScreen([ 81, ]);;
gap> LieSolvableRadical( L ); 
<two-sided ideal in <Lie algebra of dimension 9 over Rationals>, (dimension 1)>
gap> SizeScreen([ 80, ]);;
\endexample


\Declaration{CartanSubalgebra}

\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> CartanSubalgebra( L );
<Lie algebra of dimension 2 over Rationals>
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Series of Ideals}


\Declaration{LieDerivedSeries} 

\beginexample
gap> mats:= [ [[1,0],[0,0]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap> L:= LieAlgebra( Rationals, mats );;
gap> LieDerivedSeries( L );
[ <Lie algebra of dimension 3 over Rationals>, 
  <Lie algebra of dimension 1 over Rationals>, 
  <Lie algebra of dimension 0 over Rationals> ]
\endexample

\Declaration{LieLowerCentralSeries}

\beginexample
gap> mats:= [  [[ 1, 0 ], [ 0, 0 ]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap> L:=LieAlgebra( Rationals, mats );;
gap> LieLowerCentralSeries( L );
[ <Lie algebra of dimension 3 over Rationals>, 
  <Lie algebra of dimension 1 over Rationals> ]
\endexample


\Declaration{LieUpperCentralSeries}

\beginexample
gap> mats:= [  [[ 1, 0 ], [ 0, 0 ]], [[0,1],[0,0]], [[0,0],[0,1]] ];;
gap> L:=LieAlgebra( Rationals, mats );;
gap> LieUpperCentralSeries( L );
[ <two-sided ideal in <Lie algebra of dimension 3 over Rationals>, 
      (dimension 1)>, <Lie algebra over Rationals, with 0 generators> ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Properties of a Lie Algebra}


\Declaration{IsLieAbelian}

\beginexample
gap>  T:= EmptySCTable( 5, 0, "antisymmetric" );;
gap>  L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 5 over Rationals>
gap> IsLieAbelian( L );
true
\endexample



\Declaration{IsLieNilpotent}

\beginexample
gap> T:= EmptySCTable( 5, 0, "antisymmetric" );;
gap> L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 5 over Rationals>
gap> IsLieNilpotent( L );                                
true
\endexample



\Declaration{IsLieSolvable}

\beginexample
gap> T:= EmptySCTable( 5, 0, "antisymmetric" );;
gap> L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 5 over Rationals>
gap> IsLieSolvable( L );
true
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Direct Sum Decompositions}

In this section we describe two functions that calculate a direct sum
decomposition of a Lie algebra; the so-called Levi decomposition
and the decomposition into a direct sum of ideals. 

\Declaration{LeviMalcevDecomposition}!{for Lie algebras}

\beginexample
gap> L:= FullMatrixLieAlgebra( Rationals, 5 );; 
gap> LeviMalcevDecomposition( L );
[ <Lie algebra of dimension 24 over Rationals>, 
  <two-sided ideal in <Lie algebra of dimension 25 over Rationals>, 
      (dimension 1)> ]
\endexample


\Declaration{DirectSumDecomposition}!{for Lie algebras}

\beginexample
gap> L:= FullMatrixLieAlgebra( Rationals, 5 );; 
gap> DirectSumDecomposition( L );
[ <two-sided ideal in 
      <two-sided ideal in <Lie algebra of dimension 25 over Rationals>, 
          (dimension 1)>, (dimension 1)>, 
  <two-sided ideal in <two-sided ideal in 
          <Lie algebra of dimension 25 over Rationals>, (dimension 24)>, 
      (dimension 24)> ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\Section{Semisimple Lie Algebras and Root Systems}

This section contains some functions for dealing with
semisimple Lie algebras and their root systems.

\Declaration{SemiSimpleType}

\beginexample
gap> L:= SimpleLieAlgebra( "E", 8, Rationals );;
gap> b:= BasisVectors( Basis( L ) );;
gap> K:= LieCentralizer( L, Subalgebra( L, [ b[61]+b[79]+b[101]+b[102] ] ) );
<Lie algebra of dimension 102 over Rationals>
gap> lev:= LeviMalcevDecomposition(K);; 
gap> SemiSimpleType( lev[1] );
"B3 A1"
\endexample

\Declaration{ChevalleyBasis}

\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );
<Lie algebra of dimension 14 over Rationals>
gap> ChevalleyBasis( L );
[ [ v.1, v.2, v.3, v.4, v.5, v.6 ], [ v.7, v.8, v.9, v.10, v.11, v.12 ], 
  [ v.13, v.14 ] ]
\endexample


\Declaration{IsRootSystem}
\Declaration{IsRootSystemFromLieAlgebra}
\Declaration{RootSystem}

\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );
<Lie algebra of dimension 14 over Rationals>
gap> R:= RootSystem( L );
<root system of rank 2>
gap> IsRootSystem( R );
true
gap> IsRootSystemFromLieAlgebra( R );
true
\endexample

\Declaration{UnderlyingLieAlgebra}


\Declaration{PositiveRoots}
\Declaration{NegativeRoots}
\Declaration{PositiveRootVectors}
\Declaration{NegativeRootVectors}
\Declaration{SimpleSystem}
\Declaration{CartanMatrix}
\Declaration{BilinearFormMat}
\Declaration{CanonicalGenerators}

\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> R:= RootSystem( L );;
gap> UnderlyingLieAlgebra( R );
<Lie algebra of dimension 14 over Rationals>
gap> PositiveRoots( R );
[ [ 2, -1 ], [ -3, 2 ], [ -1, 1 ], [ 1, 0 ], [ 3, -1 ], [ 0, 1 ] ]
gap> x:= PositiveRootVectors( R );
[ v.1, v.2, v.3, v.4, v.5, v.6 ]
gap> g:=CanonicalGenerators( R );
[ [ v.1, v.2 ], [ v.7, v.8 ], [ v.13, v.14 ] ]
gap> g[3][1]*x[1];
(2)*v.1
gap> g[3][2]*x[1];
(-1)*v.1   # i.e., x[1] is the root vector belonging to the root [ 2, -1 ]
gap> BilinearFormMat( R );
[ [ 1/12, -1/8 ], [ -1/8, 1/4 ] ]
\endexample

The next few sections deal with the Weyl group of a root system. 
A Weyl group is represented by its action on the weight lattice. 
A *weight* is by definition a linear function $\lambda : H\to F$
(where $F$ is the ground field), such that the values $\lambda(h_i)$ are
all integers (where the $h_i$ are the Cartan elements of the 
`CanonicalGenerators'). On the other hand each weight is determined by
these values. Therefore we represent a weight by a vector of integers;
the $i$-th entry of this vector is the value $\lambda(h_i)$.
Now the elements of the Weyl group are represented by matrices, and
if `g' is an element of a Weyl group and `w' a weight, then `w*g'
gives the result of applying `g' to `w'.  Another way of applying the
$i$-th simple reflection to a weight is by using the function
`ApplySimpleReflection' (see below).

A Weyl group is generated by the simple reflections. So 
`GeneratorsOfGroup( W )' for a Weyl group `W' gives a list of matrices
and the $i$-th entry of this list is the simple reflection corresponding
to the $i$-th simple root of the corresponding root system.


\Declaration{IsWeylGroup}
\Declaration{SparseCartanMatrix}
\Declaration{WeylGroup}

\beginexample
gap> L:= SimpleLieAlgebra( "F", 4, Rationals );;
gap> R:= RootSystem( L );;
gap> W:= WeylGroup( R );
<matrix group with 4 generators>
gap> IsWeylGroup( W );
true
gap> SparseCartanMatrix( W );
[ [ [ 1, 2 ], [ 3, -1 ] ], [ [ 2, 2 ], [ 4, -1 ] ], 
  [ [ 1, -1 ], [ 3, 2 ], [ 4, -1 ] ], [ [ 2, -1 ], [ 3, -2 ], [ 4, 2 ] ] ]
gap> g:= GeneratorsOfGroup( W );;
gap> [ 1, 1, 1, 1 ]*g[2];
[ 1, -1, 1, 2 ]
\endexample

\Declaration{ApplySimpleReflection}

\beginexample
gap> L:= SimpleLieAlgebra( "F", 4, Rationals );;
gap> W:= WeylGroup( RootSystem( L ) );;
gap> C:= SparseCartanMatrix( W );;
gap> w:= [ 1, 1, 1, 1 ];;
gap> ApplySimpleReflection( C, 2, w );             
gap> w;
[ 1, -1, 1, 2 ]
\endexample

\Declaration{LongestWeylWordPerm}

\beginexample
gap> L:= SimpleLieAlgebra( "E", 6, Rationals );;
gap> W:= WeylGroup( RootSystem( L ) );;
gap> LongestWeylWordPerm( W );
(1,6)(3,5)
\endexample

\Declaration{ConjugateDominantWeight}

\beginexample
gap> L:= SimpleLieAlgebra( "E", 6, Rationals );;
gap> W:= WeylGroup( RootSystem( L ) );;
gap> C:= SparseCartanMatrix( W );;
gap> w:= [ 1, -1, 2, -2, 3, -3 ];;
gap> ConjugateDominantWeight( W, w );
[ 2, 1, 0, 0, 0, 0 ]
gap> c:= ConjugateDominantWeightWithWord( W, w );
[ [ 2, 1, 0, 0, 0, 0 ], [ 2, 4, 2, 3, 6, 5, 4, 2, 3, 1 ] ]
gap> for i in [1..Length(c[2])] do
> ApplySimpleReflection( C, c[2][i], w );
> od;
gap> w;
[ 2, 1, 0, 0, 0, 0 ]
\endexample


\Declaration{WeylOrbitIterator}

\beginexample
gap> L:= SimpleLieAlgebra( "E", 6, Rationals );;
gap> W:= WeylGroup( RootSystem( L ) );;
gap> orb:= WeylOrbitIterator( W, [ 1, 1, 1, 1, 1, 1 ] );
<iterator>
gap> NextIterator( orb );
[ 1, 1, 1, 1, 1, 1 ]
gap> NextIterator( orb );
[ -1, -1, -1, -1, -1, -1 ]
gap> orb:= WeylOrbitIterator( W, [ 1, 1, 1, 1, 1, 1 ] );
<iterator>
gap> k:= 0;
0
gap> while not IsDoneIterator( orb ) do
> w:= NextIterator( orb ); k:= k+1;
> od;
gap> k;
51840    # i.e., the size of the Weyl group of E6.
\endexample



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Restricted Lie algebras}

A Lie algebra $L$ over a field of characteristic $p>0$ is called
restricted if there is a map $x\mapsto x^p$ from $L$ into $L$ 
(called a $p$-map) such that
${\rm ad} x^p=({\rm ad} x)^p$, $(\alpha x)^p=\alpha^p x^p$ and
$(x+y)^p=x^p+y^p+\sum_{i=1}^{p-1} s_i(x,y)$, where $s_i: L\times L\to L$
are certain Lie polynomials in two variables. Using these relations
we can calculate $y^p$ for all $y\in L$, once we know $x^p$ for $x$ in a
basis of $L$. Therefore a $p$-map is represented in \GAP~ by a list 
containing the images of the basis vectors of a basis $B$ of $L$. For this
reason this list is an attribute of the basis $B$. 

\Declaration{IsRestrictedLieAlgebra}

\beginexample
gap> L:= SimpleLieAlgebra( "W", [2], GF(5));
<Lie algebra of dimension 25 over GF(5)>
gap> IsRestrictedLieAlgebra( L );
false
gap> L:= SimpleLieAlgebra( "W", [1], GF(5));
<Lie algebra of dimension 5 over GF(5)>
gap> IsRestrictedLieAlgebra( L );           
true
\endexample

\Declaration{PthPowerImages}

\beginexample
gap> L:= SimpleLieAlgebra( "W", [1], GF(11) );
<Lie algebra of dimension 11 over GF(11)>
gap> B:= Basis( L );
CanonicalBasis( <Lie algebra of dimension 11 over GF(11)> )
gap> PthPowerImages( B );           
[ 0*v.1, v.2, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1 ]
\endexample

\Declaration{PthPowerImage}

\beginexample
gap> L:= SimpleLieAlgebra( "W", [1], GF(11) );;
gap> B:= Basis( L );;
gap> x:= B[1]+B[11];
v.1+v.11
gap> PthPowerImage( B, x );         
v.1+v.11
\endexample

\Declaration{JenningsLieAlgebra}
\Declaration{PCentralLieAlgebra}

\beginexample
gap> G:= SmallGroup( 3^6, 123 );
<pc group of size 729 with 6 generators>
gap> L:= JenningsLieAlgebra( G );
<Lie algebra of dimension 6 over GF(3)>
gap> HasPthPowerImages( Basis( L ) );
true
gap> PthPowerImages( Basis( L ) );
[ v.6, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1 ]
gap> g:= Grading( L );
rec( min_degree := 1, max_degree := 3, source := Integers, 
  hom_components := function( d ) ... end )
gap> List( [1,2,3], g.hom_components );  
[ <vector space over GF(3), with 3 generators>, 
  <vector space over GF(3), with 2 generators>, 
  <vector space over GF(3), with 1 generators> ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The Adjoint Representation}

In this section we show functions for calculating with the adjoint
representation of a Lie algebra (and the corresponding trace form,
called the Killing form) (see also "ref:adjointbasis" and 
"ref:indicesofadjointbasis").

\Declaration{AdjointMatrix}

\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> AdjointMatrix( Basis( L ), Basis( L )[1] );
[ [ 0, 0, -2 ], [ 0, 0, 0 ], [ 0, 1, 0 ] ]
\endexample


\Declaration{AdjointAssociativeAlgebra}

\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> AdjointAssociativeAlgebra( L, L );
<algebra of dimension 9 over Rationals>
gap> AdjointAssociativeAlgebra( L, CartanSubalgebra( L ) );
<algebra of dimension 3 over Rationals>
\endexample


\Declaration{KillingMatrix}

\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> KillingMatrix( Basis( L ) );
[ [ 0, 4, 0 ], [ 4, 0, 0 ], [ 0, 0, 8 ] ]
\endexample

\Declaration{KappaPerp}

\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> b:= BasisVectors( Basis( L ) );;
gap> V:= VectorSpace( Rationals, [b[1],b[2]] );;
gap> KappaPerp( L, V );
<vector space of dimension 1 over Rationals>
\endexample


\Declaration{IsNilpotentElement}

\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> IsNilpotentElement( L, Basis( L )[1] );
true
\endexample

\Declaration{NonNilpotentElement}

\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> NonNilpotentElement( L );  
v.13
gap> IsNilpotentElement( L, last );
false
\endexample


\Declaration{FindSl2}

\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> b:= BasisVectors( Basis( L ) );;
gap> IsNilpotentElement( L, b[1] );
true
gap> FindSl2( L, b[1] );
<Lie algebra of dimension 3 over Rationals>
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Universal Enveloping Algebras}

\Declaration{UniversalEnvelopingAlgebra}

\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> UL:= UniversalEnvelopingAlgebra( L );
<algebra-with-one of dimension infinity over Rationals>
gap> g:= GeneratorsOfAlgebraWithOne( UL );
[ [(1)*x.1], [(1)*x.2], [(1)*x.3] ]
gap> g[3]^2*g[2]^2*g[1]^2;
[(-4)*x.1*x.2*x.3^3+(1)*x.1^2*x.2^2*x.3^2+(2)*x.3^3+(2)*x.3^4]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Finitely Presented Lie Algebras}

Finitely presented Lie algebras can be constructed from free Lie algebras
by using the `/' constructor, i.e., `FL/[r1...rk]' is the quotient of
the free Lie algebra `FL' by the ideal generated by the elements
`r1...rk' of `FL'. If the finitely presented Lie algebra `K' happens to be
finite dimensional then an isomorphic structure constants Lie algebra
can be constructed by `NiceAlgebraMonomorphism(K)', which returns a surjective
homomorphism. The structure constants Lie algebra can then be accessed by 
calling `Range' for this map. Also limited computations with elements of the 
finitely presented Lie algebra are possible.

\beginexample
gap> L:= FreeLieAlgebra( Rationals, "s", "t" );
<Lie algebra over Rationals, with 2 generators>
gap> gL:= GeneratorsOfAlgebra( L );; s:= gL[1];; t:= gL[2];;
gap> K:= L/[ s*(s*t), t*(t*(s*t)), s*(t*(s*t))-t*(s*t) ];
<Lie algebra over Rationals, with 2 generators>
gap> h:= NiceAlgebraMonomorphism( K );
[ [(1)*s], [(1)*t] ] -> [ v.1, v.2 ]
gap> U:= Range( h );
<Lie algebra of dimension 3 over Rationals>
gap> IsLieNilpotent( U );
true
gap> gK:= GeneratorsOfAlgebra( K );
[ [(1)*s], [(1)*t] ]
gap> gK[1]*(gK[2]*gK[1]) = Zero( K );
true
\endexample

\Declaration{FpLieAlgebraByCartanMatrix}


\beginexample
gap> C:= [ [ 2, -1 ], [ -3, 2 ] ];; 
gap> K:= FpLieAlgebraByCartanMatrix( C );
<Lie algebra over Rationals, with 6 generators>
gap> h:= NiceAlgebraMonomorphism( K );
[ [(1)*x1], [(1)*x2], [(1)*x3], [(1)*x4], [(1)*x5], [(1)*x6] ] -> 
[ v.1, v.2, v.3, v.4, v.5, v.6 ]
gap> SemiSimpleType( Range( h ) );
"G2"
\endexample

\Declaration{NilpotentQuotientOfFpLieAlgebra}

\beginexample
gap> L:= FreeLieAlgebra( Rationals, "x", "y" );;
gap> g:= GeneratorsOfAlgebra(L);; x:= g[1]; y:= g[2];
(1)*x
(1)*y
gap> rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ]; 
[ (-1)*(x*(x*(x*y)))+(6)*((x*y)*y), 
  (-3)*(x*(x*(x*(x*(x*y)))))+(20)*(x*(x*((x*y)*y)))+(-20)*((x*(x*y))*(x*y)) ]
gap> K:= L/rr;
<Lie algebra over Rationals, with 2 generators>
gap> h:=NilpotentQuotientOfFpLieAlgebra(K, 50, [1,2] );
[ [(1)*x], [(1)*y] ] -> [ v.1, v.2 ]
gap> L:= Range( h );
<Lie algebra of dimension 50 over Rationals>
gap> Grading( L );
rec( min_degree := 1, max_degree := 50, source := Integers, 
  hom_components := function( d ) ... end )
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Modules over Lie Algebras and Their Cohomology}

Representatios of Lie algebras are dealt with in the same way as 
representations of ordinary algebras (see "Representations of Algebras").
In this section we mainly deal with modules over general Lie algebras
and their cohomology. The next section is devoted to modules over
semisimple Lie algebras.

\Declaration{FaithfulModule}!{for Lie algebras}

\beginexample
gap> T:= EmptySCTable( 3, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [ 1, 3 ]);
gap> L:= LieAlgebraByStructureConstants( Rationals, T );
<Lie algebra of dimension 3 over Rationals>
gap> V:= FaithfulModule( L );
<3-dimensional left-module over <Lie algebra of dimension 3 over Rationals>>
gap> vv:= BasisVectors( Basis( V ) );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
gap> x:= Basis( L )[3];
v.3
gap> List( vv, v -> x^v );
[ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 0, 0, 0 ] ]
\endexample

\FileHeader[1]{lierep}

\Declaration{IsCochain}

\Declaration{Cochain}

\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> V:= AdjointModule( L );
<3-dimensional left-module over <Lie algebra of dimension 3 over Rationals>>
gap> c1:= Cochain( V, 2, [ [ [ [ 1, 3 ], -1 ] ], [ ], [ [ [ 2, 3 ], 1/2 ] ] ]);
<2-cochain>
gap> ExtRepOfObj( c1 );
[ [ [ [ 1, 3 ], -1 ] ], [  ], [ [ [ 2, 3 ], 1/2 ] ] ]
gap> c2:= Cochain( V, 0, Basis( V )[1] );
<0-cochain>
gap> ExtRepOfObj( c2 );
v.1
gap> IsCochain( c2 );
true
\endexample

\Declaration{CochainSpace}

\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> V:= AdjointModule( L );;
gap> C:=CochainSpace( V, 2 );          
<vector space of dimension 9 over Rationals>
gap> BasisVectors( Basis( C ) );
[ <2-cochain>, <2-cochain>, <2-cochain>, <2-cochain>, <2-cochain>, 
  <2-cochain>, <2-cochain>, <2-cochain>, <2-cochain> ]
gap> ExtRepOfObj( last[1] );
[ [ [ [ 1, 2 ], 1 ] ], [  ], [  ] ]
\endexample

\Declaration{ValueCochain}

\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> V:= AdjointModule( L );;
gap> C:= CochainSpace( V, 2 );;
gap> c:= Basis( C )[1];             
<2-cochain>
gap>  ValueCochain( c, Basis(L)[2], Basis(L)[1] );
(-1)*v.1
\endexample

\Declaration{LieCoboundaryOperator}

\beginexample
gap> L:= SimpleLieAlgebra( "A", 1, Rationals );;
gap> V:= AdjointModule( L );;
gap> C:= CochainSpace( V, 2 );;
gap> c:= Basis( C )[1];;             
gap> c1:= LieCoboundaryOperator( c );
<3-cochain>
gap> c2:= LieCoboundaryOperator( c1 );
<4-cochain>
\endexample

\Declaration{Cocycles}

\Declaration{Coboundaries}

\beginexample
gap> T:= EmptySCTable( 3, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [ 1, 3 ] );
gap> L:= LieAlgebraByStructureConstants( Rationals, T );;
gap> V:= FaithfulModule( L );
<3-dimensional left-module over <Lie algebra of dimension 3 over Rationals>>
gap> Cocycles( V, 2 );
<vector space of dimension 7 over Rationals>
gap> Coboundaries( V, 2 );
<vector space over Rationals, with 9 generators>
gap> Dimension( last );
5
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Modules over Semisimple Lie Algebras}

This section contains functions for calculating information on
representations of semisimple Lie algebras. First we have some functions
for calculating some combinatorial data (set of dominant weights, 
the dominant character, the decomposition of a tensor product, the dimension
of a highest-weight module). Then 
there is a function for creating an admissible lattice in the universal
enveloping algebra of a semisimple Lie algebra. Finally we have a function
for constructing a highest-weight module over a semisimple Lie algebra.

\Declaration{DominantWeights}
\Declaration{DominantCharacter}
\Declaration{DecomposeTensorProduct}
\Declaration{DimensionOfHighestWeightModule}

\beginexample
gap> L:= SimpleLieAlgebra( "F", 4, Rationals );;
gap> R:= RootSystem( L );;
gap> DominantWeights( R, [ 1, 1, 0, 0 ] );
[ [ [ 1, 1, 0, 0 ], [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], 
      [ 1, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ 0, 3, 4, 8, 11, 19 ] ]
gap> DominantCharacter( L, [ 1, 1, 0, 0 ] );
[ [ [ 1, 1, 0, 0 ], [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], 
      [ 1, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ 1, 1, 4, 6, 14, 21 ] ]
gap> DecomposeTensorProduct( L, [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ] );
[ [ [ 1, 0, 1, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 0, 1 ], [ 0, 1, 0, 0 ], 
      [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 1, 1, 0, 0 ] ], 
  [ 1, 1, 1, 1, 1, 1, 1 ] ]
gap> DimensionOfHighestWeightModule( L, [ 1, 2, 3, 4 ] );
79316832731136
\endexample

\FileHeader[2]{lierep}

\Declaration{IsUEALatticeElement}
\Declaration{LatticeGeneratorsInUEA}
\Declaration{ObjByExtRep}
 
  An UEALattice element is represented by a list of the form

      [ m1, c1, m2, c2,.....]

  where the c1,c2 etc. are coefficients, and the m1, m2 etc. monomials.
  A monomial is a list of the form [ ind1, e1, ind2, e2, ....]
  where ind1, ind2 are indices, and e1, e2 etc. are exponents. Let
  N be the number of positive roots of the underlying Lie algebra. The
  indices lie between 1 and $\dim L$. If an index lies between 1 and N,
  then it represents a negative root vector (corresponding to the root
  `NegativeRoots( R )[ind]', where R is the root system of L). This leads
  to a factor `yind1^(e1)' in the printed form of the monomial (which equals
  z^e1/e1!, where z is a basis element of L). If an index
  lies between N+1 and 2N, then it represents a positive root vector.
  Finally, if ind lies between 2N+1 and 2N+rank, then it represents
  an element of the Cartan subalgebra. This is printed as ( h_1/ e_1 ),
  meaning h_1 choose e_1 (h_1,...,h_rank are the canonical Cartan
  generators).

  The zero element is represented by the empty list, the identity
  element by the list [ [  ], 1 ].

\beginexample
gap> L:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> g:=LatticeGeneratorsInUEA( L );
[ y1, y2, y3, y4, y5, y6, x1, x2, x3, x4, x5, x6, ( h13/1 ), ( h14/1 ) ]
gap> IsUEALatticeElement( g[1] );
true
gap> g[1]^3;
6*y1^(3)
gap> q:= g[7]*g[1]^2;
-2*y1+2*y1*( h13/1 )+2*y1^(2)*x1
gap> ExtRepOfObj( q );
[ [ 1, 1 ], -2, [ 1, 1, 13, 1 ], 2, [ 1, 2, 7, 1 ], 2 ]
\endexample

\Declaration{IsWeightRepElement}
\Declaration{HighestWeightModule}

Note that for the following examples of this chapter we increase the line
length limit from its default value 80 to 81 in order to make some long
output expressions fit into the lines.

\beginexample
gap> SizeScreen([ 81, ]);;
gap> K1:= SimpleLieAlgebra( "G", 2, Rationals );;
gap> K2:= SimpleLieAlgebra( "B", 2, Rationals );;
gap> L:= DirectSumOfAlgebras( K1, K2 );
<Lie algebra of dimension 24 over Rationals>
gap> V:= HighestWeightModule( L, [ 0, 1, 1, 1 ] );
<224-dimensional left-module over <Lie algebra of dimension 24 over Rationals>>
gap> vv:= GeneratorsOfLeftModule( V );;
gap> vv[100];                 
y5*y7*y10*v0
gap> e:= ExtRepOfObj( vv[100] );
y5*y7*y10*v0
gap> ExtRepOfObj( e );
[ [ 100, y5*y7*y10, [ -3, 2, -1, 1 ] ], 1 ]
gap> Basis(L)[17]^vv[100];
-1*y5*y7*y8*v0-1*y5*y9*v0
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Tensor Products and Exterior and Symmetric Powers}

\Declaration{TensorProductOfAlgebraModules}

\beginexample
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [ 1, 0 ] );;          
gap> W:= TensorProductOfAlgebraModules( [ V, V, V ] );
<343-dimensional left-module over <Lie algebra of dimension 14 over Rationals>>
gap> w:= Basis(W)[1];
1*(1*v0<x>1*v0<x>1*v0)
gap> Basis(L)[1]^w;
<0-tensor>
gap> Basis(L)[7]^w;
1*(1*v0<x>1*v0<x>y1*v0)+1*(1*v0<x>y1*v0<x>1*v0)+1*(y1*v0<x>1*v0<x>1*v0)
\endexample

\Declaration{ExteriorPowerOfAlgebraModule}

\beginexample
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [ 1, 0 ] );;
gap> W:= ExteriorPowerOfAlgebraModule( V, 3 );
<35-dimensional left-module over <Lie algebra of dimension 14 over Rationals>>
gap> w:= Basis(W)[1];
1*(1*v0/\y1*v0/\y3*v0)
gap> Basis(L)[10]^w;
1*(1*v0/\y1*v0/\y6*v0)+1*(1*v0/\y3*v0/\y5*v0)+1*(y1*v0/\y3*v0/\y4*v0)
\endexample

\Declaration{SymmetricPowerOfAlgebraModule}

\beginexample
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [ 1, 0 ] );;
gap> W:= SymmetricPowerOfAlgebraModule( V, 3 );
<84-dimensional left-module over <Lie algebra of dimension 14 over Rationals>>
gap> w:= Basis(W)[1];
1*(1*v0.1*v0.1*v0)
gap> Basis(L)[2]^w;
<0-symmetric element>
gap> Basis(L)[7]^w;
3*(1*v0.1*v0.y1*v0)
\endexample

\Declaration{DirectSumOfAlgebraModules}!{for Lie algebras}

\beginexample
gap> L:= SimpleLieAlgebra( "C", 3, Rationals );;
gap> V:= HighestWeightModule( L, [ 1, 1, 0 ] );
<64-dimensional left-module over <Lie algebra of dimension 21 over Rationals>>
gap> W:= HighestWeightModule( L, [ 0, 0, 2 ] );
<84-dimensional left-module over <Lie algebra of dimension 21 over Rationals>>
gap> U:= DirectSumOfAlgebraModules( V, W );
<148-dimensional left-module over <Lie algebra of dimension 21 over Rationals>>
gap> SizeScreen([ 80, ]);;
\endexample
