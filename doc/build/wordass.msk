%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  wordass.msk                 GAP documentation            Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%%
\Chapter{Associative Words}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Categories of Associative Words}

\FileHeader{wordass}[1]

\Declaration{IsAssocWord}

Different alphabets correspond to different families of associative words.
There is no relation whatsoever between words in different families.

\beginexample
gap> f:= FreeGroup( "a", "b", "c" );
<free group on the generators [ a, b, c ]>
gap> gens:= GeneratorsOfGroup(f);
[ a, b, c ]
gap> w:= gens[1]*gens[2]/gens[3]*gens[2]*gens[1]/gens[1]*gens[3]/gens[2];
a*b*c^-1*b*c*b^-1
gap> w^-1;
b*c^-1*b^-1*c*b^-1*a^-1
\endexample

Words are displayed as products of letters.
The letters are usually printed like `f1', `f2', $\ldots$,
but it is possible to give user defined names to them,
which can be arbitrary strings.
These names do not necessarily identify a unique letter (generator),
it is possible to have several letters --even in the same family--
that are displayed in the same way.
Note also that
*there is no relation between the names of letters and variable names*.
In the example above, we might have typed

\beginexample
gap> a:= f.1;; b:= f.2;; c:= f.3;;
\endexample

(*Interactively*, the function `AssignGeneratorVariables'
(see~"AssignGeneratorVariables") provides a shorthand for this.)
This allows us to define `w' more conveniently:

\beginexample
gap> w := a*b/c*b*a/a*c/b;
a*b*c^-1*b*c*b^-1
\endexample

Using homomorphisms it is possible to express elements of a group as words
in terms of generators,
see~"Expressing group elements as words in generators".


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Free Groups, Monoids and Semigroups}

Usually a family of associative words will be generated by constructing
the free object generated by them.

\Declaration{FreeGroup}
\Declaration{IsFreeGroup}

Also see Chapter~"Finitely Presented Groups".

\Declaration{FreeMonoid}!{with example}

Also see Chapter~"Monoids".

\Declaration{FreeSemigroup}

Also see Chapter~"Semigroups" and~"FreeSemigroup!with examples".

Each free object defines a unique alphabet (and a unique family of words).
Its generators are the letters of this alphabet,
thus words of length one.

\beginexample
gap> FreeGroup( 5 );
<free group on the generators [ f1, f2, f3, f4, f5 ]>
gap> FreeGroup( "a", "b" );
<free group on the generators [ a, b ]>
gap> FreeGroup( infinity );
<free group with infinity generators>
gap> FreeSemigroup( "x", "y" );
<free semigroup on the generators [ x, y ]>
gap> FreeMonoid( 7 );
<free monoid on the generators [ m1, m2, m3, m4, m5, m6, m7 ]>
\endexample

Remember that names are just a help for printing and do not necessarily
distinguish letters.
It is possible to create arbitrarily weird situations by choosing strange
names for the letters.
\beginexample
gap> f:= FreeGroup( "x", "x" );  gens:= GeneratorsOfGroup( f );;
<free group on the generators [ x, x ]>
gap> gens[1] = gens[2];
false
gap> f:= FreeGroup( "f1*f2", "f2^-1", "Group( [ f1, f2 ] )" );
<free group on the generators [ f1*f2, f2^-1, Group( [ f1, f2 ] ) ]>
gap> gens:= GeneratorsOfGroup( f );;
gap> gens[1]*gens[2];
f1*f2*f2^-1
gap> gens[1]/gens[3];
f1*f2*Group( [ f1, f2 ] )^-1
gap> gens[3]/gens[1]/gens[2];
Group( [ f1, f2 ] )*f1*f2^-1*f2^-1^-1
\endexample

\Declaration{AssignGeneratorVariables}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comparison of Associative Words}

\FileHeader{wordass}[2]

\Declaration{IsShortLexLessThanOrEqual}
\Declaration{IsBasicWreathLessThanOrEqual}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Associative Words}

\index{product!of words}
\index{quotient!of words}
\index{power!of words}
\index{conjugate!of a word}
\indextt{Comm!for words}
\indextt{LeftQuotient!for words}

\FileHeader{wordass}[3]

\FileHeader{wordass}[4]

\index{length!of a word}
\Declaration{Length}[wordass]!{of an associative word}

\beginexample
gap> f := FreeGroup("a","b");; gens := GeneratorsOfGroup(f);;
gap> a := gens[1];; b := gens[2];;w := a^5*b*a^2*b^-4*a;;
gap>  w; Length( w );  Length( a^17 );  Length( w^0 );
a^5*b*a^2*b^-4*a
13
17
0
\endexample

\Declaration{ExponentSumWord}
\beginexample
gap> w;  ExponentSumWord( w, a );  ExponentSumWord( w, b );
a^5*b*a^2*b^-4*a
8
-3
gap> ExponentSumWord( (a*b*a^-1)^3, a );  ExponentSumWord( w, b^-1 );
0
3
\endexample

\Declaration{Subword}
\beginexample
gap> w;  Subword( w, 3, 7 );
a^5*b*a^2*b^-4*a
a^3*b*a
\endexample

\Declaration{PositionWord}
\beginexample
gap> w;  PositionWord( w, a/b, 1 );
a^5*b*a^2*b^-4*a
8
gap> Subword( w, 8, 9 );
a*b^-1
gap> PositionWord( w, a^2, 1 );
1
gap> PositionWord( w, a^2, 2 );
2
gap> PositionWord( w, a^2, 6 );
7
gap> PositionWord( w, a^2, 8 );
fail
\endexample

\Declaration{SubstitutedWord}
\beginexample
gap> w;  SubstitutedWord( w, 3, 7, a^19 );
a^5*b*a^2*b^-4*a
a^22*b^-4*a
gap> SubstitutedWord( w, a, 6, b^7 );
a^5*b^8*a*b^-4*a
gap> SubstitutedWord( w, a*b, 6, b^7 );
fail
\endexample

\Declaration{EliminatedWord}
\beginexample
gap> w;  EliminatedWord( w, a, a^2 );  EliminatedWord( w, a, b^-1 );
a^5*b*a^2*b^-4*a
a^10*b*a^4*b^-4*a^2
b^-11
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Associative Words by their Syllables}

\FileHeader{wordass}[5]

\Declaration{NumberSyllables}
\Declaration{ExponentSyllable}
\Declaration{GeneratorSyllable}
\Declaration{SubSyllables}
\beginexample
gap> w;  NumberSyllables( w );
a^5*b*a^2*b^-4*a
5
gap> ExponentSyllable( w, 3 );
2
gap> GeneratorSyllable( w, 3 );
1
gap> SubSyllables( w, 2, 3 );
b*a^2
\endexample

\FileHeader{wordass}[4]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Representations for Associative Words}

{\GAP} provides two different internal kinds of representations of
associative words.  The first one are ``syllable representations'' in which
words are stored in syllable (i.e. generator,exponent) form. (Older versions
of {\GAP} only used this representation.) The second kind are ``letter
representations'' in which each letter in a word is represented by its index
number. Negative numbers are used for inverses. Unless the syllable
representation is specified explicitly when creating the free group/monoid
or semigroup, a letter representation is used by default.

Depending on the task in mind, either of these two representations will
perform better in time or in memeory use and algorithms that are syllable or
letter absed (for example `GeneratorSyllable' and `Subword') perform
substantially better in the corresponding representation.
For example when creating pc groups (see~"Pc groups"), it is advantageous to
use a syllable representation while calculations in free groups usually
benefit from using a letter representation.

\Declaration{IsLetterAssocWordRep}

\Declaration{IsLetterWordsFamily}

Internally, there are letter representations that use integers (4 Byte) to
represent a generator and letter representations that use single bytes to
represent a character. The latter are more memory efficient, but can only be
used if there are less than 128 generators (in which case they are used by
default).

\Declaration{IsBLetterAssocWordRep}
\Declaration{IsBLetterWordsFamily}

\Declaration{IsSyllableAssocWordRep}
\Declaration{IsSyllableWordsFamily}

There are also different versions of syllable representations, which
compress a generator exponent pair in 8,16 or 32 bits or use a pair of
integers. Internal mechanisms try to make this as memory efficient as
possible.
\Declaration{Is8BitsFamily}

Regardless of the internal representation used, it is possible to convert a
word in a list of numbers in letter or syllable representation and vice
versa:

\Declaration{LetterRepAssocWord}
\Declaration{AssocWordByLetterRep}
\beginexample
gap> w:=AssocWordByLetterRep( FamilyObj(a), [-1,2,1,-2,-2,-2,1,1,1,1]);
a^-1*b*a*b^-3*a^4
gap> LetterRepAssocWord( w^2 );
[ -1, 2, 1, -2, -2, -2, 1, 1, 1, 2, 1, -2, -2, -2, 1, 1, 1, 1 ]
\endexample

The external representation (see section~"The External Representation for
Associative Words") can be used if a syllable representation is needed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The External Representation for Associative Words}

\FileHeader{wordass}[6]
\beginexample
gap> w:= ObjByExtRep( FamilyObj(a), [1,5,2,-7,1,3,2,4,1,-2] );
a^5*b^-7*a^3*b^4*a^-2
gap> ExtRepOfObj( w^2 );
[ 1, 5, 2, -7, 1, 3, 2, 4, 1, 3, 2, -7, 1, 3, 2, 4, 1, -2 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Straight Line Programs}

\FileHeader[1]{straight}

\Declaration{IsStraightLineProgram}
\Declaration{StraightLineProgram}
\Declaration{LinesOfStraightLineProgram}
\Declaration{NrInputsOfStraightLineProgram}
\Declaration{ResultOfStraightLineProgram}
\Declaration{StringOfResultOfStraightLineProgram}

\beginexample
gap> prg:= StraightLineProgram( [ [ 1, 2, 2, 3 ], [ 3, -1 ] ], 2 );;
gap> StringOfResultOfStraightLineProgram( prg, [ "a", "b" ] );
"(a^2b^3)^-1"
gap> StringOfResultOfStraightLineProgram( prg, [ "a", "b" ], "LaTeX" );
"(a^{2}b^{3})^{-1}"
\endexample

\Declaration{CompositionOfStraightLinePrograms}
\beginexample
gap> prg1:= StraightLineProgram( "a^2b", [ "a","b" ] );;
gap> prg2:= StraightLineProgram( "c^5", [ "c" ] );;
gap> comp:= CompositionOfStraightLinePrograms( prg2, prg1 );
<straight line program>
gap> StringOfResultOfStraightLineProgram( comp, [ "a", "b" ] );
"(a^2b)^5"
gap> prg:= StraightLineProgram( [ [2,3], [ [3,1,1,4], [1,2,3,1] ] ], 2 );;
gap> StringOfResultOfStraightLineProgram( prg, [ "a", "b" ] );
"[ b^3a^4, a^2b^3 ]"
gap> comp:= CompositionOfStraightLinePrograms( prg, prg );
<straight line program>
gap> StringOfResultOfStraightLineProgram( comp, [ "a", "b" ] );
"[ (a^2b^3)^3(b^3a^4)^4, (b^3a^4)^2(a^2b^3)^3 ]"
\endexample

\Declaration{IntegratedStraightLineProgram}
\beginexample
gap> f:= FreeGroup( "x", "y" );;  gens:= GeneratorsOfGroup( f );;
gap> prg1:= StraightLineProgram( [ [ [ 1, 2 ], 1 ], [ 1, 2, 2, -1 ] ], 2 );;
gap> prg2:= StraightLineProgram( [ [ [ 2, 2 ], 3 ], [ 1, 3, 3, 2 ] ], 2 );;
gap> prg3:= StraightLineProgram( [ [ 2, 2 ], [ 1, 3, 3, 2 ] ], 2 );;
gap> prg:= IntegratedStraightLineProgram( [ prg1, prg2, prg3 ] );;
gap> ResultOfStraightLineProgram( prg, gens );
[ x^4*y^-1, x^3*y^4, x^3*y^4 ]
gap> prg:= IntegratedStraightLineProgram( [ prg2, prg3, prg1 ] );;
gap> ResultOfStraightLineProgram( prg, gens );
[ x^3*y^4, x^3*y^4, x^4*y^-1 ]
gap> prg:= IntegratedStraightLineProgram( [ prg3, prg1, prg2 ] );;
gap> ResultOfStraightLineProgram( prg, gens );
[ x^3*y^4, x^4*y^-1, x^3*y^4 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Straight Line Program Elements}

\FileHeader[2]{straight}

\Declaration{IsStraightLineProgElm}
\Declaration{StraightLineProgElm}
\Declaration{StraightLineProgGens}
\Declaration{EvalStraightLineProgElm}
\Declaration{StretchImportantSLPElement}

% no manual check -- the Random is just too bothersome.
\begintt
gap> gens:=StraightLineProgGens([(1,2,3,4),(1,2)]);
[ <[ [ 2, 1 ] ]||(1,2,3,4)>, <[ [ 1, 1 ] ]||(1,2)> ]
gap> g:=Group(gens);;
gap> (gens[1]^3)^gens[2];
<[ [ 1, -1, 2, 3, 1, 1 ] ]||(1,2,4,3)>
gap> Size(g);
24
gap> Random(g);
<[ [ 1, -1, 2, -1, 1, 1, 2, -1, 1, -1, 2, 1, 1, 1, 2, 1, 1, -1, 2, 2, 1, 1 ], 
   [ 3, -2, 2, -2, 1, -1, 2, -2, 1, 1, 2, -1, 3, -2, 1, -1, 2, -2, 1, 1 ] ]
  || (1,4,3,2)>
\endtt

See also Section~"Working with large degree permutation groups".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

