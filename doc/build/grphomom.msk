%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  grphomom.msk                GAP documentation            Alexander Hulpke
%%
%A  @(#)$Id: grphomom.msk,v 1.47 2006/01/10 23:26:49 gap Exp $
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
\Chapter{Group Homomorphisms}

A group homomorphism is a mapping from one group to another that respects
multiplication and inverses. They are implemented as a special class of
mappings, so in particular all operations for mappings, such as `Image',
`PreImage', `PreImagesRepresentative',
`KernelOfMultiplicativeGeneralMapping', `Source', `Range', `IsInjective' and
`IsSurjective'  (see chapter~"Mappings", in particular section~"Mappings
that Respect Multiplication") are applicable to them.

Homomorphisms can be used to transfer calculations into isomorphic groups in
another representation, for which better algorithms are available.
Section~"Nice Monomorphisms" explains a technique how to enforce this
automatically.

Homomorphisms are also used to represent group automorphisms, and section
"Group Automorphisms" explains explains {\GAP\pif}s facilities to work
with automorphism groups.

The penultimate section of this chapter, "Searching for Homomorphisms", explains
how to make {\GAP} to search for all homomorphisms between two groups which
fulfill certain specifications.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Group Homomorphisms}

The most important way of creating group homomorphisms is to give images for
a set of group generators and to extend it to the group generated by them
by the homomorphism property.

\Declaration{GroupHomomorphismByImages}
\Declaration{GroupHomomorphismByImagesNC}
\beginexample
gap> gens:=[(1,2,3,4),(1,2)];
[ (1,2,3,4), (1,2) ]
gap> g:=Group(gens);
Group([ (1,2,3,4), (1,2) ])
gap> h:=Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> hom:=GroupHomomorphismByImages(g,h,gens,[(1,2),(1,3)]);
[ (1,2,3,4), (1,2) ] -> [ (1,2), (1,3) ]
gap> Image(hom,(1,4));
(2,3)
gap> map:=GroupHomomorphismByImages(g,h,gens,[(1,2,3),(1,2)]);
fail
\endexample

\Declaration{GroupGeneralMappingByImages}
\beginexample
gap> map:=GroupGeneralMappingByImages(g,h,gens,[(1,2,3),(1,2)]);
[ (1,2,3,4), (1,2) ] -> [ (1,2,3), (1,2) ]
gap> IsMapping(map);
false
\endexample

*A second* way to create homomorphisms is to give functions that compute image
and preimage. (A similar case are homomorphisms that are induced by
conjugation. Special constructors for such mappings are described in
section~"Group Automorphisms").

\Declaration{GroupHomomorphismByFunction}
\beginexample
gap> hom:=GroupHomomorphismByFunction(g,h,
> function(x) if SignPerm(x)=-1 then return (1,2); else return ();fi;end);
MappingByFunction( Group([ (1,2,3,4), (1,2) ]), Group([ (1,2,3), (1,2) 
 ]), function( x ) ... end )
gap> ImagesSource(hom);
Group([ (1,2), (1,2) ])
gap> Image(hom,(1,2,3,4));
(1,2)
\endexample

*The third* class are epimorphisms from a group onto its factor
group. Such homomorphisms can be constructed by
`NaturalHomomorphismByNormalSubgroup'
(see~"NaturalHomomorphismByNormalSubgroup").

*The fourth* class is homomorphisms in a permutation group that are induced by
an action on a set. Such homomorphisms are described in the context of group
actions, see chapter~"Group Actions" and in particular
section~"ActionHomomorphism".

\Declaration{AsGroupGeneralMappingByImages}
\beginexample
gap> AsGroupGeneralMappingByImages(hom);
[ (1,2,3,4), (1,2) ] -> [ (1,2), (1,2) ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Group Homomorphisms}
\index{kernel!group homomorphism}

Group homomorphisms are mappings, so all the operations and properties for
mappings described in chapter~"Mappings" are applicable to them. (However
often much better methods, than for general mappings are available.)

Group homomorphisms will map groups to groups by just mapping the set of
generators.

`KernelOfMultiplicativeGeneralMapping' can be used to compute the kernel
of a group homomorphism.

\beginexample
gap> hom:=GroupHomomorphismByImages(g,h,gens,[(1,2),(1,3)]);;
gap> Kernel(hom);
Group([ (1,4)(2,3), (1,2)(3,4) ])
\endexample

Homomorphisms can map between groups in different representations and are
also used to get isomorphic groups in a different representation.

\beginexample
gap> m1:=[[0,-1],[1,0]];;m2:=[[0,-1],[1,1]];;
gap> sl2z:=Group(m1,m2);; # SL(2,Integers) as matrix group
gap> F:=FreeGroup(2);;
gap> psl2z:=F/[F.1^2,F.2^3]; #PSL(2,Z) as FP group
<fp group on the generators [ f1, f2 ]>
gap> phom:=GroupHomomorphismByImagesNC(sl2z,psl2z,[m1,m2],
> GeneratorsOfGroup(psl2z)); # the non NC-version would be expensive
[ [ [ 0, -1 ], [ 1, 0 ] ], [ [ 0, -1 ], [ 1, 1 ] ] ] -> [ f1, f2 ]
gap> Kernel(phom); # the diagonal matrices
Group([ [ [ -1, 0 ], [ 0, -1 ] ], [ [ -1, 0 ], [ 0, -1 ] ] ])
gap> p1:=(1,2)(3,4);;p2:=(2,4,5);;a5:=Group(p1,p2);;
gap> ahom:=GroupHomomorphismByImages(psl2z,a5,
> GeneratorsOfGroup(psl2z),[p1,p2]); # here homomorphism test is cheap.
[ f1, f2 ] -> [ (1,2)(3,4), (2,4,5) ]
gap> u:=PreImage(ahom,Group((1,2,3),(1,2)(4,5)));
Group(<fp, no generators known>)
gap> Index(psl2z,u);
10
gap> isofp:=IsomorphismFpGroup(u);; Image(isofp);
<fp group of size infinity on the generators [ F1, F2, F3, F4 ]>
gap> RelatorsOfFpGroup(Image(isofp));
[ F1^2, F4^2, F3^3 ]
gap> up:=PreImage(phom,u);;
gap> List(GeneratorsOfGroup(up),TraceMat);
[ -2, -2, 0, -4, 1, 0 ]
\endexample

\index{Inverse!group homomorphism}

For an automorphism <aut>, `Inverse' returns the inverse automorphism
$<aut>^{-1}$. However if <hom> is a bijective homomorphism between
different groups, or if <hom> is injective and considered to be a bijection
to its image, the operation `InverseGeneralMapping' should be used instead.
(See~"Inverse" for a further discussion of this problem.)

\beginexample
gap> iso:=IsomorphismPcGroup(g);
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]) -> [ f1, f2, f3, f4 ]
gap> Inverse(iso);
#I  The mapping must be bijective and have source=range
#I  You might want to use `InverseGeneralMapping'
fail
gap> InverseGeneralMapping(iso);
[ f1, f2, f3, f4 ] -> Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Efficiency of Homomorphisms}

{\GAP} permits to create homomorphisms between arbitrary groups.  This
section considers the efficiency of the implementation and shows ways how to
choose suitable representations. For permutation groups (see~"Permutation
Groups") or Pc groups (see~"Pc Groups") this is normally nothing to worry
about, unless the groups get extremely large. For other groups however
certain calculations might be expensive and some precaution might be needed
to avoid unnecessarily expensive calculations.

In short, it is always worth to tell a mapping that it is a homomorphism
(this can be done by `SetIsMapping') (or to create it directly with
`GroupHomomorphismByImagesNC').

The basic operations required are to compute image and preimage of elements
and to test whether a mapping is a homomorphism. Their cost
will differ depending on the type of the mapping.
\bigskip

*Mappings given on generators (`GroupHomomorphismByImages',
`GroupGeneralMappingByImages')*

Computing images requires to express an element of the source as word in the
generators. If it cannot be done effectively (this is determined by
`KnowsHowToDecompose', see~"KnowsHowToDecompose" which returns `true' for
example for arbitrary permutation groups, for Pc groups or for finitely
presented groups with the images of the free generators) the span of the
generators has to be computed elementwise which can be very expensive and
memory consuming.

Computing preimages adheres to the same rules with swapped r\^oles of
generators and their images.

The test whether a mapping is a homomorphism requires
the computation of a presentation for the source and evaluation of its
relators in the images of its generators. For larger groups this can be
expensive and `GroupHomomorphismByImagesNC' should be used if the mapping is
known to be a homomorphism.
\bigskip

*Action homomorphisms (`ActionHomomorphism')*

The calculation of images is determined by the acting function used and
-- for large domains -- is often dominated by the search for the position of
an image in a list of the domain elements. This can be improved by sorting
this list if an efficient method for `\<'  to compare elements of the domain
is available.

Once the images of a generating set are computed, computing preimages (which is
done via the `AsGroupGeneralMappingByImages') and computing the kernel
bahaves the same as for a `GroupHomomorphismByImages' in a permutation
group.

{\GAP} will always assume that the acting function provided implements a proper
group action and thus that the mapping is indeed a homomorphism.
\bigskip

*Mappings given by functions (`GroupHomomorphismByFunction',
`GroupGeneralMappingByFunctions')*

Computing images is wholly determined by the function that performs the
image calculation. If no function to compute preimages is given, computing
preimages requires mapping every element of the source to find an element
that maps to the requested image. This is time and memory consuming.

Testing whether a `GroupGeneralMappingByFunctions' is a homomorphism would
require mapping all products of elements and thus should be avoided.
\bigskip

*Other operations*

To compute the kernel of a homomorphism (unless the mapping is known to be
injective) requires the capability to compute a
presentation of the image and to evaluate the relators of this presentation
in preimages of the presentations generators.

The calculation of the `Image' (respectively `ImagesSource') requires to map
a generating set of the source, testing surjectivity is a comparison for
equality with the range.

Testing injectivity is a test for triviality of the kernel.

The comparison of mappings is based on a lexicographic comparison of a
sorted element list of the source. For groups this can be simplified:

\Declaration{ImagesSmallestGenerators}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Homomorphism for very large groups}

Some homomorphisms (notably particular actions) transfer known information
about the source group (such as a stabilizer chain) to the image group if
this is substantially cheaper than to compute the information in the image
group anew. In most cases this is no problem and in fact speeds up further
calculations notably.

For a huge source group, however this can be time consuming or take a large
amount of extra memory for storage. In this case it can be helpful to avoid
as much automatism as possible.

The following list of tricks might be useful in such a case. (However you
will lose much automatic deduction. So please restrict the use of these to
cases where the standard approach does not work.)
\beginitems
-&
Compute only images (or the `PreImageRepresentative') of group elements. Do
not compute the images of (sub)groups or the full preimage of a subgroup.

-&
Create action homomorphisms as ``surjective'' (see `ActionHomomorphism')
(otherwise the range is set to be the full symmetric group)
However do not compute  Range or Image, but only the images of a
generator set.

-&
If you suspect an action homomorphism to do too much internally, replace the
action function with a function that does the same; i.e. replace `OnPoints'
by
\begintt
function(p,g) return p^g;end;
\endtt
The action will be the same, but as the action function is not `OnPoints',
the extra processing for special cases is not triggered.
\enditems

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Nice Monomorphisms}

{\GAP} contains very efficient algorithms for some special representations
of groups (for example pc groups or permutation groups) while for other
representations only slow generic methods are available. In this case it
can be worthwhile to do all calculations rather in an isomorphic image of
the group, which is in a ``better'' representation. The way to achieve this
in {\GAP} is via *nice monomorphisms*.

For this mechanism to work, of course there must be effective methods to
evaluate the `NiceMonomorphism' on elements and to take preimages under it.
As by definition no good algorithms exist for the source group,
normally this can only be achieved by using an `ActionHomomorphism' or a
`GroupHomomorphismByFunction' (see also
section~"Efficiency of Homomorphisms").

\Declaration{IsHandledByNiceMonomorphism}
\Declaration{NiceMonomorphism}
\Declaration{NiceObject}

A typical example are finite matrix groups, which use a faithful action on
vectors to translate all calculations in a permutation group.
\beginexample
gap> gl:=GL(3,2);
SL(3,2)
gap> IsHandledByNiceMonomorphism(gl);
true
gap> NiceObject(gl);
Group([ (5,7)(6,8), (2,3,5)(4,7,6) ])
gap> Image(NiceMonomorphism(gl),Z(2)*[[1,0,0],[0,1,1],[1,0,1]]);
(2,6)(3,4,7,8)
\endexample

\Declaration{IsCanonicalNiceMonomorphism}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group Automorphisms}

Group automorphisms are bijective homomorphism from a group onto itself.
An important subclass are automorphisms which are induced by conjugation of
the group itself or a supergroup.

\Declaration{ConjugatorIsomorphism}
\Declaration{ConjugatorAutomorphism}
\Declaration{InnerAutomorphism}
\Declaration{IsConjugatorIsomorphism}
\Declaration{ConjugatorOfConjugatorIsomorphism}

\beginexample
gap> hgens:=[(1,2,3),(1,2,4)];;h:=Group(hgens);;
gap> hom:=GroupHomomorphismByImages(h,h,hgens,[(1,2,3),(2,3,4)]);;
gap> IsInnerAutomorphism(hom);
true
gap> ConjugatorOfConjugatorIsomorphism(hom);
(1,2,3)
gap> hom:=GroupHomomorphismByImages(h,h,hgens,[(1,3,2),(1,4,2)]);
[ (1,2,3), (1,2,4) ] -> [ (1,3,2), (1,4,2) ]
gap> IsInnerAutomorphism(hom);
false
gap> IsConjugatorAutomorphism(hom);
true
gap> ConjugatorOfConjugatorIsomorphism(hom);
(1,2)
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Groups of Automorphisms}

Group automorphism can be multiplied and inverted and thus it is possible
to form groups of automorphisms.

\Declaration{AutomorphismGroup}

Note that current methods for the calculation of the automorphism group of a
group $G$ require $G$ to be a permutation group or a pc group to be
efficient. For groups in other representations the calculation is likely
very slow.

\Declaration{IsGroupOfAutomorphisms}
\Declaration{AutomorphismDomain}
\Declaration{IsAutomorphismGroup}

\beginexample
gap> g:=Group((1,2,3,4),(1,3));
Group([ (1,2,3,4), (1,3) ])
gap> au:=AutomorphismGroup(g);
<group of size 8 with 3 generators>
gap> GeneratorsOfGroup(au);
[ ^(1,2,3,4), ^(1,3), [ (1,2,3,4), (2,4) ] -> [ (1,2,3,4), (1,2)(3,4) ] ]
gap> NiceObject(au);
Group([ (1,4)(2,6), (2,6)(3,5), (1,2,4,6) ])
\endexample

\Declaration{InnerAutomorphismsAutomorphismGroup}
\beginexample
gap> InnerAutomorphismsAutomorphismGroup(au);
<group with 2 generators>
\endexample

\Declaration{InducedAutomorphism}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
gap> n:=Subgroup(g,[(1,2)(3,4),(1,3)(2,4)]);
Group([ (1,2)(3,4), (1,3)(2,4) ])
gap> epi:=NaturalHomomorphismByNormalSubgroup(g,n);
[ (1,2,3,4), (1,2) ] -> [ f1*f2, f1 ]
gap> aut:=InnerAutomorphism(g,(1,2,3));
^(1,2,3)
gap> InducedAutomorphism(epi,aut);
^f2
\endexample

%%  The code for automorphism groups was designed and implemented by Bettina
%%  Eick and Alexander Hulpke.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Calculating with Group Automorphisms}

Usually the best way to calculate in a group of automorphisms is to go
translate all calculations to an isomorphic group in a representation, for
which better algorithms are available, say a permutation group. This
translation can be done automatically using a `NiceMonomorphism'
(see~"NiceMonomorphism".)

Once a group knows to be a group of automorphisms (this can be achieved
by testing or setting the property `IsGroupOfAutomorphisms'
(see~"IsGroupOfAutomorphisms"),
{\GAP} will try itself to find such a nice monomorphism once calculations in
the automorphism group are done.

Note that nice homomorphisms inherit down to subgroups, but cannot
necessarily be extended from a subgroup to the whole group. Thus when
working with a group of automorphisms, it can be beneficial to 
enforce calculation of the nice monomorphism for the whole
group (for example by explicitly calling `Random(G)' and ignoring
the result -- it will be stored internally) at the start of the calculation.
Otherwise {\GAP} might first calculate a nice monomorphism for the subgroup,
only to be forced to calculate a new nice monomorphism for the whole group
later on.

\Declaration{AssignNiceMonomorphismAutomorphismGroup}

If a good domain for a faithful permutation action is known already, a
homomorphism for the action on it can be created using
`NiceMonomorphismAutomGroup'. It might be stored by `SetNiceMonomorphism'
(see "NiceMonomorphism").

\Declaration{NiceMonomorphismAutomGroup}

Another nice way of representing automorphisms as permutations has been
described in \cite{Sims97}. It it not yet available in {\GAP}, a description
however can be found in section~"ext:Stabilizer Chains for Automorphisms Acting
on Enumerators" of ``Extending {\GAP}''.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Searching for Homomorphisms}

\index{homomorphisms!find all}

\Declaration{IsomorphismGroups}
\index{isomorphisms!find all}
\beginexample
gap> g:=Group((1,2,3,4),(1,3));;
gap> h:=Group((1,4,6,7)(2,3,5,8), (1,5)(2,6)(3,4)(7,8));;
gap> IsomorphismGroups(g,h);
[ (1,2,3,4), (1,3) ] -> [ (1,4,6,7)(2,3,5,8), (1,2)(3,7)(4,8)(5,6) ]
gap> IsomorphismGroups(g,Group((1,2,3,4),(1,2)));
fail
\endexample

\Declaration{GQuotients}
\index{epimorphisms!find all}
\index{projections!find all}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
gap> h:=Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> quo:=GQuotients(g,h);
[ [ (1,4,2,3), (1,2,4) ] -> [ (2,3), (1,2,3) ] ]
\endexample

\Declaration{IsomorphicSubgroups}
\index{embeddings!find all}
\index{monomorphisms!find all}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));
Group([ (1,2,3,4), (1,2) ])
gap> h:=Group((3,4),(1,2));;
gap> emb:=IsomorphicSubgroups(g,h);
[ [ (3,4), (1,2) ] -> [ (3,4), (1,2) ], 
  [ (3,4), (1,2) ] -> [ (1,3)(2,4), (1,2)(3,4) ] ]
\endexample

\Declaration{MorClassLoop}

The ``Morpheus'' algorithm used to find homomorphisms is described in
section V.5 of \cite{Hulpke96}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Representations for Group Homomorphisms}

The different representations of group homomorphisms are used to indicate
from what type of group to what type of group they map and thus determine
which methods are used to compute images and preimages.

The information in this section is mainly relevant for implementing new
methods and not for using homomorphisms.

\Declaration{IsGroupGeneralMappingByImages}
\Declaration{IsGroupGeneralMappingByAsGroupGeneralMappingByImages}
\Declaration{IsPreimagesByAsGroupGeneralMappingByImages}
\Declaration{IsPermGroupGeneralMapping}
\Declaration{IsToPermGroupGeneralMappingByImages}
\Declaration{IsGroupGeneralMappingByPcgs}
\Declaration{IsPcGroupGeneralMappingByImages}
\Declaration{IsToPcGroupGeneralMappingByImages}
\Declaration{IsFromFpGroupGeneralMappingByImages}
\Declaration{IsFromFpGroupStdGensGeneralMappingByImages}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

