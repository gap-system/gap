%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  fpsemi.msk                GAP documentation                Isabel Araujo
%%
%A  @(#)$Id$
%%
%Y  (C) 1999 School Math and Comp. Sci., University of St.  Andrews, Scotland
%%
\Chapter{Finitely Presented Semigroups}

A *finitely presented semigroup* (resp. *finitely presented monoid*)
is a quotient of a free semigroup (resp. free monoid) on a finite 
number of generators over a finitely generated congruence on
the considered free semigroup (resp. free monoid).

Finitely presented semigroups are obtained by factoring a free semigroup 
by a set of relations (a generating set for the congruence), ie, a set of
pairs of words in the free semigroup.

\beginexample
gap> f:=FreeSemigroup("a","b");;
gap> x:=GeneratorsOfSemigroup(f);;
gap> s:=f/[ [x[1]*x[2],x[2]*x[1]] ];
<fp semigroup on the generators [ a, b ]>
gap> GeneratorsOfSemigroup(s);
[ a, b ]
gap> RelationsOfFpSemigroup(s);
[ [ a*b, b*a ] ]
\endexample

Finitely presented monoids are obtained by factoring a free monoid by
a set of relations. 
What is obtained is a finitely presented semigroup with one
extra generator (corresponding to the identity of the monoid)
and the extra relations involving this generator.
In fact there are no finitely presented monoids in {\GAP}.
The quotient construction on a free monoids produce a finitely
presented semigroup. This enables the user to conveniently enter
a monoid presentation without specifying the identity and its action 
on the other generators.

\beginexample
gap> f:=FreeMonoid("a","b");;
gap> x:=GeneratorsOfMonoid(f);;
[ a, b ]
gap> e:=Identity(f);
<identity ...>
gap> m:=f/[ [x[1]*x[2],e] ];
<fp semigroup on the generators [ <identity ...>, a, b ]>
\endexample

Note that is not possible to refer to the generators by their names.
These names are not variables, but just display figures.
So, if one wants to access the generators by their names, one first has to 
introduce the respective variables and to assign the generators to them.
 

\beginexample
gap> f:=FreeSemigroup("a","b");;
gap> x:=GeneratorsOfSemigroup(f);;
gap> s:=f/[ [x[1]*x[2],x[2]*x[1]] ];;
gap> a;
Variable: 'a' must have a value
gap> a:=GeneratorsOfSemigroup(s)[1];
a
gap> b:=GeneratorsOfSemigroup(s)[2];
b
gap> a in f;
false
gap> a in s;
true
\endexample

Also note that the generators of the free semigroup are different from the
generators of the finitely presented semigroup (even though they are 
displayed by the same names). 
This means that words in the generators of the free semigroup are not
elements of the finitely presented semigroup. Conversely elements of the
finitely presented semigroup are not words.

\beginexample
gap> a*b=a^5;
false
gap> a^5*b^2*a=a^6*b^2;
true
\endexample

Such calculations comparing elements of an finitely presented semigroup
may run into problems:
there are finitely presented semigroups for which no algorithm exists 
(it is known that no such algorithm can exist) that will tell for two 
arbitrary words in the generators whether the corresponding elements 
in the finitely presented semigroup are equal.
Therefore the methods used by {\GAP} to compute in finitely
presented semigroups may run into warning errors, run out of memory or run
forever. If the finitely presented semigroup is (by theory) known to be 
finite the algorithms are guaranteed to terminate (if there is sufficient 
memory available), but the time needed for the calculation cannot be 
bounded a priori. See "Rewriting Systems and the Knuth Bendix Procedure".

Note than elements of a finitely presented semigroup are not printed 
in a unique way.

\beginexample
gap> a^5*b^2*a;
a^5*b^2*a
gap> a^6*b^2;
a^6*b^2
\endexample

\Declaration{IsSubsemigroupFpSemigroup}
\Declaration{IsFpSemigroup}
\Declaration{IsElementOfFpSemigroup}

\beginexample
gap> f := FreeSemigroup("a","b");;
gap> a := GeneratorsOfSemigroup( f )[ 1 ];;
gap> b := GeneratorsOfSemigroup( f )[ 2 ];;
gap> s := f / [ [ a^2 , a*b ] ];;
gap> IsFpSemigroup( s );
true
gap> t := Semigroup( [ GeneratorsOfSemigroup( s )[ 1 ] ]);
<semigroup with 1 generator>
gap> IsSubsemigroupFpSemigroup( t );
true
gap> IsElementOfFpSemigroup( GeneratorsOfSemigroup( t )[ 1 ] );
true
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Finitely Presented Semigroups and Monoids }

\>`<F>/<rels>'{quotient of free semigroup}  

creates a finitely presented semigroup given by the presentation
$\langle<gens>\mid<rels>\rangle$ where <gens> are the generators of the free
semigroup <F>.
Note that relations are entered as pairs of words in the
generators of  the free semigroup. 

\beginexample
gap> f:=FreeSemigroup(3);;
gap> s:=GeneratorsOfSemigroup(f);;
gap> f/[ [s[1]*s[2]*s[1],s[1]] , [s[2]^4,s[1]] ];
<fp semigroup on the generators [ s1, s2, s3 ]>
\endexample

\>`<F>/<rels>'{quotient of free semigroup} 

creates a finitely presented semigroup given by the monoid
presentation $\langle<gens>\mid<rels>\rangle$ where <gens> are the 
generators of the free monoid <F>.
Note that relations are entered as pairs of words in both the
identity and the generators of the free monoid.

\beginexample
gap> f := FreeMonoid( 3 );
<free monoid on the generators [ m1, m2, m3 ]>
gap> x := GeneratorsOfMonoid( f );
[ m1, m2, m3 ]
gap> e:= Identity ( f );
<identity ...>
gap> m := f/[ [x[1]^3,e] , [x[1]*x[2],x[2] ]];
<fp semigroup on the generators [ <identity ...>, m1, m2, m3 ]>
\endexample

One may also call the following functions to construct finitely
presented semigroups.
\Declaration{FactorFreeSemigroupByRelations}

Finally, if one has a finitely presented group, to find an
isomorphic finitely presented semigroup, for example, to apply
the Knuth-Bendix procedure, use:
\Declaration{IsomorphismFpSemigroup}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comparison of Elements of Finitely Presented Semigroups}

\>`<a> = <b>'{comparison!fp semigroup elements}
 

Two elements of a finitely presented semigroups are equal if they are equal in
this semigroup. Nevertheless they may be represented as different words in the
generators. Because of the fundamental problems mentioned in the
introduction to this chapter such a test may take very long and cannot be
guaranteed to finish.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Preimages in the Free Semigroup}

\Declaration{FreeSemigroupOfFpSemigroup}
\Declaration{FreeGeneratorsOfFpSemigroup}
\Declaration{RelationsOfFpSemigroup}

\beginexample
gap> f := FreeSemigroup( "a" , "b" );;
gap> a := GeneratorsOfSemigroup( f )[ 1 ];;
gap> b := GeneratorsOfSemigroup( f )[ 2 ];;
gap> s := f / [ [ a^3 , a ] , [ b^3 , b ] , [ a*b , b*a ] ];             
<fp semigroup on the generators [ a, b ]>
gap> Size( s );
8
gap> FreeSemigroupOfFpSemigroup( s ) = f;
true
gap> FreeGeneratorsOfFpSemigroup( s );
[ a, b ]
gap> RelationsOfFpSemigroup( s );
[ [ a^3, a ], [ b^3, b ], [ a*b, b*a ] ]
\endexample

Elements of a finitely presented semigroup are not words, but are represented
using a word from the free semigroup as representative. 

\>UnderlyingElement( <elm> )!{fp semigroup elements} O 

If <elm> is an element of a finitely presented semigroup, it 
returns the word from the free semigroup that is used as a
representative for <elm>.

\beginexample
gap> w := GeneratorsOfSemigroup(s)[1] * GeneratorsOfSemigroup(s)[2];
a*b
gap> IsWord (w );
false
gap> ue := UnderlyingElement( w ); 
a*b
gap> IsWord( ue );
true
\endexample

\Declaration{ElementOfFpSemigroup}
\beginexample
gap> ge:=ElementOfFpSemigroup( FamilyObj( GeneratorsOfSemigroup(s)[1]), a*b ); 
a*b
gap> ge in f;
false
gap> ge in s;
true
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Rewriting Systems and the Knuth Bendix Procedure}

If a finitely presented semigroup has a confluent rewriting system then it has a solvable
word problem, that is, there is an algorithm to decide when two words in
the free underlying semigroup represent the same element of the
finitely presented semigroup. 
Indeed, once we have a confluent rewriting system, it is possible to successfully 
test that two words represent the same element in the semigroup, by reducing
both words using the rewriting system rules. 

\Declaration{ReducedConfluentRewritingSystem}

\beginexample
gap> f := FreeSemigroup( "a" , "b" );;
gap> a := GeneratorsOfSemigroup( f )[ 1 ];;
gap> b := GeneratorsOfSemigroup( f )[ 2 ];;
gap> g := f /  [ [ a^2 , a*b ] , [ a^4 , b] ];;
gap> rws := ReducedConfluentRewritingSystem(g);
Rewriting System for Semigroup( [ a, b ] ) with rules 
[ [ a*b, a^2 ], [ a^4, b ], [ b*a, a^2 ], [ b^2, a^2 ] ]
\endexample

The creation of a reduced confluent rewriting system for a semigroup, in {\GAP},
uses the Knuth-Bendix procedure for strings, which manipulates 
a rewriting system of the semigroup and attempts to 
make it confluent (See "Rewriting Systems". See also Sims). 
(Since the word problem for semigroups is not solvable in general, 
Knuth-Bendix procedure cannot always terminate). 

In order to apply this procedure we will build a rewriting system
for the semigroup, which we will call a  *Knuth Bendix Rewriting System*
(we need to define this because we need that the rewriting system
to store some information needed for the implementation of the
Knuth Bendix procedure). 
Actually, Knuth Bendix Rewriting Systems are not only useful to get a reduced
confluent rewriting system for the semigroup. These are objects which are
mutable and which can be manipulated (see "rewriting systems").

Note that the implemented version of the Knuth Bendix procedure, in {\GAP}
returns, if it terminates, a confluent rewriting system which is reduced.

Also, a reduction ordering has to be specified when building a rewriting
system. If non is specified, the shortlex ordering is assumed
(note that the procedure may terminate with a certain ordering and
not with another one).

\Declaration{KnuthBendixRewritingSystem}
\>KnuthBendixRewritingSystem(<S>,<lessthanorequal>)

creates the Knuth Bendix rewriting system of the finitely presented
semigroup <S> using the reduction ordering given by <lessthanorequal>.

\Declaration{SemigroupOfRewritingSystem}
\Declaration{FreeSemigroupOfRewritingSystem}

As mentioned before, having a confluent rewriting system, one can decide
whether two words represent the same element of a finitely 
presented semigroup. 

\beginexample
gap> a := GeneratorsOfSemigroup( g )[ 1 ];
a
gap> b := GeneratorsOfSemigroup( g )[ 2 ];
b
gap> a*b*a=a^3;                           
true
gap> ReducedForm(rws,UnderlyingElement(a*b*a));
a^3
gap> ReducedForm(rws,UnderlyingElement(a^3));  
a^3
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Todd-Coxeter Procedure}

This procedure gives a standard way of finding a transformation
representation of a finitely presented semigroup. Usually
one does not explicitly call this procedure but uses
IsomorphismTransformationSemigroup 
or HomomorphismTransformationSemigroup 
(see "IsomorphismTransformationSemigroup").

\Declaration{CosetTableOfFpSemigroup}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E
