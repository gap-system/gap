%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  string.msk                  GAP documentation            Martin Schoenert
%A                                                           Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
\Chapter{Strings and Characters}

\index{type!strings}
\index{doublequotes}
\index{singlequotes}

\Declaration{IsChar}
\beginexample
gap> x:= 'a';  IsChar( x );
'a'
true
gap> '*';
'*'
\endexample

\Declaration{IsString}
\beginexample
gap> s1 := ['H','e','l','l','o',' ','w','o','r','l','d','.'];
"Hello world."
gap> IsString( s1 );
true
gap> s2 := "Hello world.";
"Hello world."
gap> s1 = s2;
true
gap> s3 := "";  # the empty string
""
gap> s3 = [];
true
gap> IsString( [] );
true
gap> IsString( "123" );  IsString( 123 );
true
false
gap> IsString( [ '1', '2', '3' ] );
true
gap> IsString( [ '1', '2', , '4' ] );  # strings must be dense
false
gap> IsString( [ '1', '2', 3 ] );  # strings must only contain characters
false
\endexample

%notest
\beginexample
gap> s := "\007";
"\007"
gap> Print(s); # rings bell in many terminals
\endexample

Note that a string is just a special case of a list.
So everything that is possible for lists (see~"Lists") is also possible
for strings.
Thus you can access the characters in such a string (see~"List Elements"),
test for membership (see~"Membership Test for Collections"),
ask for the length, concatenate strings (see~"Concatenation"),
form substrings etc.
You can even assign to a mutable string (see~"List Assignment").
Of course unless you assign a character in such a way that the list stays
dense,
the resulting list will no longer be a string.

\beginexample
gap> Length( s2 );
12
gap> s2[2];
'e'
gap> 'a' in s2;
false
gap> s2[2] := 'a';;  s2;
"Hallo world."
gap> s1{ [1..4] };
"Hell"
gap> Concatenation( s1{ [ 1 .. 6 ] }, s1{ [ 1 .. 4 ] } );
"Hello Hell"
\endexample

If a string is  displayed by `View', for example as  result of an evaluation
(see~"Main  Loop"), or  by `ViewObj'  and `PrintObj',  it is  displayed with
enclosing doublequotes. (But  note that there is an ambiguity  for the empty
string which is also  an empty list of arbitrary {\GAP}  objects; it is only
printed like  a string if  it was  input as empty  string or converted  to a
string  with "ConvertToStringRep".)  The  difference  between `ViewObj'  and
`PrintObj'  is that  the  latter prints  *all*  non-printable and  non-ASCII
characters  in  three  digit  octal  notation,  while  `ViewObj'  sends  all
printable characters to  the output stream. The output of  `PrintObj' can be
read back into {\GAP}.

Strings  behave  differently  from  other {\GAP}  objects  with  respect  to
`Print', `PrintTo',  or `AppendTo'. These  commands *interpret* a  string in
the sense that  they essentially send the characters of  the string directly
to the output stream/file. (But depending on  the type of the stream and the
presence of some special characters used  as hints for line breaks there may
be sent some additional newline (or backslash and newline) characters.

\beginexample
gap> s4:= "abc\"def\nghi";;
gap> View( s4 );  Print( "\n" );
"abc\"def\nghi"
gap> ViewObj( s4 );  Print( "\n" );
"abc\"def\nghi"
gap> PrintObj( s4 );  Print( "\n" );
"abc\"def\nghi"
gap> Print( s4 );  Print( "\n" );
abc"def
ghi
gap> s := "German uses strange characters: \344\366\374\337\n";
"German uses strange characters: äöüß\n"
gap> Print(s);
German uses strange characters: äöüß
gap> PrintObj(s);
"German uses strange characters: \344\366\374\337\n"gap> 
\endexample

Note that only those line breaks are printed by `Print' that are contained
in the string (`\\n' characters, see~"Special Characters"),
as is shown in the example below.

%notest
\beginexample
gap> s1;
"Hello world."
gap> Print( s1 );
Hello world.gap> Print( s1, "\n" );
Hello world.
gap> Print( s1, "\nnext line\n" );
Hello world.
next line
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Special Characters}

\index{escaped characters}
\index{special character sequences}

There are a number of *special character sequences* that can be used
between the singlequotes of a character literal or between the
doublequotes of a string literal to specify characters. 
They consist of two characters. The first is
a backslash $\backslash$. The second may be any character. If it is an octal
digit (from `0' to `7') there must be two more such digits. The meaning
is given in the following list

\beginlist

\indextt{\\n}\index{newline character}
\item{`\\n'}
    *newline character*.
    This is the character that, at least on UNIX systems,
    separates lines in a text file.
    Printing of this character in a string has the effect of moving
    the cursor down one line and back to the beginning of the line.

\indextt{\\\"}\index{doublequote character}
\item{`\\\"'}
    *doublequote character*.
    Inside a string a doublequote must be escaped by the backslash,
    because it is otherwise interpreted as end of the string.

\atindex{\\'}{@\noexpand`\\\pif'}\index{singlequote character}
\item{`\\\pif'}
    *singlequote character*.
    Inside a character a singlequote must escaped by the backslash,
    because it is otherwise interpreted as end of the character.

\indextt{\\\\}\index{backslash character}
\item{`\\\\'}
    *backslash character*.
    Inside a string a backslash must be escaped by another backslash,
    because it is otherwise interpreted as first character of
    an escape sequence.

\indextt{\\b}\index{backspace character}
\item{`\\b'}
    *backspace character*.
    Printing this character should have the effect of moving the cursor
    back one character.  Whether it works or not is system dependent
    and should not be relied upon.

\indextt{\\r}\index{carriage return character}
\item{`\\r'}
    *carriage return character*.
    Printing this character should have the effect of moving the cursor
    back to the beginning of the same line.  Whether this works or not
    is again system dependent.

\indextt{\\c}\index{flush character}
\item{`\\c'}
    *flush character*.
    This character is not printed.
    Its purpose is to flush the output queue.
    Usually {\GAP} waits until it sees a <newline> before it prints a string.
    If you want to display a string that does not include this character
    use `\\c'.

\indextt{\\XYZ}\index{octal character codes}
\item{`\\XYZ'}
    with X, Y, Z three octal digits. This is translated to the character
    correponding to the number X*64+Y*8+Z modulo 256. This can be used to 
    specify and store  arbitrary binary data as a string in  {\GAP}.

\index{escaping non-special characters}
\item{other}
    For any other character the backslash is simply ignored.

\endlist

Again, if the line is displayed as result of an evaluation, those escape
sequences are displayed in the same way that they are input. 

Only  `Print', `PrintTo', or `AppendTo' send the characters directly to the
output stream.

% XXX Should the characters \< and \> and their use with `Print' be documented?

\beginexample
gap> "This is one line.\nThis is another line.\n";
"This is one line.\nThis is another line.\n"
gap> Print( last );
This is one line.
This is another line.
\endexample

Note in particular that it is not  allowed to enclose a <newline> inside the
string. You can use the  special character sequence `$\backslash$n' to write
strings that include  <newline> characters. If, however, an  input string is
too  long to  fit on  a single  line it  is possible  to *continue*  it over
several lines.  In this case the  last character of each  input line, except
the last line  must be a backslash. Both backslash  and <newline> are thrown
away by  {\GAP} while reading  the string.  Note that the  same continuation
mechanism is available for identifiers and integers, 
see~"Special Rules for Input Lines".


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Internally Represented Strings}

\index{convert!to a string}

\Declaration{IsStringRep}
\Declaration{ConvertToStringRep}
\Declaration{IsEmptyString}
\beginexample
gap> l:= [];;  IsString( l );  IsEmptyString( l );  IsEmpty( l );
true
false
true
gap> l;  ConvertToStringRep( l );  l;
[  ]
""
gap> IsEmptyString( l );  IsEmptyString( "" );  IsEmptyString( "abc" );
true
true
false
gap> ll:= [ 'a', 'b' ];  IsStringRep( ll );  ConvertToStringRep( ll );
"ab"
false
gap> ll;  IsStringRep( ll );
"ab"
true
\endexample

\>EmptyString( <len> ) F

\>ShrinkAllocationString( <str> )

The function `EmptyString' returns an empty string in
internal representation which
has enough memory allocated for <len> characters. This can be useful
for creating and filling a string with a known number of entries.

The function `ShrinkAllocationString' gives back to {\GAP}s
memory manager the physical memory which is allocated for the string
<str> in internal representation but not needed by its current
number of characters.

These functions are intended for saving some of {\GAP}s memory in certain
situations, see the explanations and the example for the analogeous
functions `EmptyPlist' and `ShrinkAllocationPlist'
for plain lists.


\Declaration{CharsFamily}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Recognizing Characters}

\Declaration{IsDigitChar}
\Declaration{IsLowerAlphaChar}
\Declaration{IsUpperAlphaChar}
\Declaration{IsAlphaChar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comparisons of Strings}

\>`<string1> = <string2>'{strings!equality of}
\>`<string1> \<> <string2>'{strings!inequality of}

The equality operator `=' returns to `true' if the two strings
<string1> and <string2> are equal and `false' otherwise. The inequality
operator `\<>' returns `true' if the two strings <string1> and <string2>
are not equal and `false' otherwise.

\beginexample
gap> "Hello world.\n" = "Hello world.\n";
true
gap> "Hello World.\n" = "Hello world.\n";  # string comparison is case sensitive
false
gap> "Hello world." = "Hello world.\n";  # the first string has no <newline>
false
gap> "Goodbye world.\n" = "Hello world.\n";
false
gap> [ 'a', 'b' ] = "ab";
true
\endexample

\>`<string1> \< <string2>'{strings!lexicographic ordering of}

The ordering of strings is lexicographically according to the order
implied by the underlying, system dependent, character set.

\beginexample
gap> "Hello world.\n" < "Hello world.\n";  # the strings are equal
false
gap> "Hello World." < "Hello world.";  # in ASCII capitals range before small letters
true
gap> "Hello world." < "Hello world.\n";  # prefixes are always smaller
true
gap> "Goodbye world.\n" < "Hello world.\n";  # `G' comes before `H', in ASCII at least
true
\endexample

Strings can be compared via `\<' with certain {\GAP} objects that are not
strings, see~"Comparisons" for the details.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations to Produce or Manipulate Strings}

\Declaration{String}

\beginexample
gap> String(123);String([1,2,3]);
"123"
"[ 1, 2, 3 ]"
\endexample

\>HexStringInt( <int> ) F

returns a string which represents the integer <int> with hexa-decimal
digits (using `A-F' as digits `10-15'). The inverse translation can be achieved
with "IntHexString".

\Declaration{StringPP}
\beginexample
gap> StringPP(40320);
"2^7*3^2*5*7"
\endexample

\Declaration{WordAlp}
\beginexample
gap> List([0..5],i->WordAlp("abc",i));
[ "", "a", "b", "c", "aa", "ab" ]
\endexample

\Declaration{LowercaseString}
\beginexample
gap> LowercaseString("This Is UpperCase");
"this is uppercase"
\endexample

\Declaration{SplitString}
\beginexample
gap> SplitString( "substr1:substr2::substr4", ":" );
[ "substr1", "substr2", "", "substr4" ]
gap> SplitString( "a;b;c;d;", ";" );
[ "a", "b", "c", "d" ]
gap> SplitString( "/home//user//dir/", "", "/" );
[ "home", "user", "dir" ]
\endexample

\Declaration{ReplacedString}
\beginexample
gap> ReplacedString("abacab","a","zl");
"zlbzlczlb"
gap> ReplacedString("ababa", "aba","c");
"cba"
gap> ReplacedString("abacab","a","ba");
"babbacbab"
\endexample


\>NormalizeWhitespace( <string> ) F

This  function changes  the string  <string> in  place. The  characters `  '
(space), `\\n', `\\r' and `\\t' are considered as *white space*. Leading and
trailing white space characters in  <string> are removed. Sequences of white
space characters  between other  characters are replaced  by a  single space
character.

See "NormalizedWhitespace" for a non-destructive version.

\beginexample 
gap> s := "   x y \n\n\t\r  z\n   \n";
"   x y \n\n\t\r  z\n   \n"
gap> NormalizeWhitespace(s);
gap> s;
"x y z"
\endexample

\Declaration{NormalizedWhitespace}

\>RemoveCharacters( <string>, <chars> )

Both arguments must be strings. This function efficiently removes all 
characters given in <chars> from <string>.

\beginexample
gap> s := "ab c\ndef\n\ng    h i .\n";
"ab c\ndef\n\ng    h i .\n"
gap> RemoveCharacters(s, WHITESPACE);
gap> s;
"abcdefghi."
\endexample

For the possibility to print {\GAP} objects to strings, see~"String Streams".

\Declaration{JoinStringsWithSeparator}
\Declaration{Chomp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Character Conversion}

The following functions convert characters in their internal integer values
and vice versa. Note that the number corresponding to a particular character
might depend on the system used. While most systems use an extension of
ASCII, in particular character values outside the range 32-126 might differ
between architectures.

All functions in this section are internal and behaviour is undefined if
invarid arguments are given.

\>INT_CHAR(<char>) F

returns an integer value in the range 0-255 that corresponds to <char>.

\>CHAR_INT(<int>) F

returns a character which corresponds to the integer value <int>, which must
be in the range 0-255.

\beginexample
gap> c:=CHAR_INT(65);
'A'
gap> INT_CHAR(c);
65
\endexample

\>SINT_CHAR(<char>) F

returns a signed integer value in the range $-128$--127 that corresponds to
<char>.

\>CHAR_SINT(<int>) F

returns a character which corresponds to the signed integer value <int>,
which must be in the range $-128$--127.

The signed and unsigned integer functions behave the same for values in the
range from 0 to 127.

\beginexample
gap> SINT_CHAR(c);
65
gap> c:=CHAR_SINT(-20);;
gap> SINT_CHAR(c);
-20
gap> INT_CHAR(c);
236
gap> SINT_CHAR(CHAR_INT(255));
-1
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations to Evaluate Strings}

\index{evaluation!strings}
\>Int( <str> )!{for strings} A
\>Rat( <str> )!{for strings} A
\>IntHexString( <str> ) F

return either an integer (`Int' and `IntHexString'), or a rational (`Rat')
as represented by the string <str>.
`Int' returns `fail' if non-digit characters occur in <str>.
For `Rat', the argument string may start with the sign character `{'}-{'}',
followed by either a sequence of digits or by two sequences of digits
that are separated by one of the characters `{'}/{'}' or `{'}.{'}',
where the latter stands for a decimal dot.
(The methods only evaluate numbers but do *not* perform arithmetic!)

`IntHexString' evaluates an integer written with hexa-decimal digits. Here
the letters <a-f> or <A-F> are used as *digits* <10-15>. An error occurs
when a wrong character is found in the string. This function can be used
(together with "HexStringInt") for efficiently storing and reading large
integers from respectively into {\GAP}. Note that the translation between
integers and their hexa-decimal representation costs linear computation time
in terms of the number of digits, while translation from and into decimal
representation needs substantial computations. If <str> is not in compact
string representation then "ConvertToStringRep" is applied to it as side
effect.

\beginexample
gap> Int("12345")+1;
12346
gap> Int("123/45");
fail
gap> Int("1+2");
fail
gap> Int("-12");
-12
gap> Rat("123/45");
41/15
gap> Rat( "123.45" );
2469/20
gap> IntHexString("-abcdef0123456789");
-12379813738877118345
gap> HexStringInt(last);
"-ABCDEF0123456789"
\endexample

\Declaration{Ordinal}
\beginexample
gap> Ordinal(2);  Ordinal(21);  Ordinal(33);  Ordinal(-33);
"2nd"
"21st"
"33rd"
"-33rd"
\endexample

\Declaration{EvalString}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Calendar Arithmetic}

\FileHeader{string}[2]

\Declaration{DaysInYear}
\Declaration{DaysInMonth}
\beginexample
gap> DaysInYear(1998);
365
gap> DaysInMonth(3,1998);
31
\endexample

\Declaration{DMYDay}
\Declaration{DayDMY}
\Declaration{WeekDay}
\Declaration{StringDate}
\beginexample
gap> DayDMY([1,1,1970]);DayDMY([2,1,1970]);
0
1
gap> DMYDay(12345);
[ 20, 10, 2003 ]
gap> WeekDay([11,3,1998]);
"Wed"
gap> StringDate([11,3,1998]);
"11-Mar-1998"
\endexample

\Declaration{HMSMSec}
\Declaration{SecHMSM}
\Declaration{StringTime}
\beginexample
gap> HMSMSec(Factorial(10));
[ 1, 0, 28, 800 ]
gap> SecHMSM([1,10,5,13]);
4205013
gap> StringTime([1,10,5,13]);
" 1:10:05.013"
\endexample

\Declaration{SecondsDMYhms}
\Declaration{DMYhmsSeconds}
\beginexample
gap> SecondsDMYhms([ 9, 9, 2001, 1, 46, 40 ]);
1000000000
gap> DMYhmsSeconds(-1000000000);
[ 24, 4, 1938, 22, 13, 20 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

