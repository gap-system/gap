%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  boolean.msk                 GAP documentation            Martin Schoenert
%A                                                           Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
\Chapter{Booleans}

\index{type!boolean}\index{logical}

The two main *boolean* values are `true' and `false'.
They stand for the *logical* values of the same name.
They appear as values of the conditions in `if'-statements
and `while'-loops.
Booleans are also important as return values of *filters* (see~"Filters")
such as `IsFinite' and `IsBool'.
Note that it is a convention that the name of a function that
returns `true' or `false' according to the outcome, starts with `Is'.

For technical reasons, also the value `fail' (see~"Fail")
is regarded as a boolean.

\Declaration{IsBool}
\beginexample
gap> IsBool( true );  IsBool( false );  IsBool( 17 );
true
true
false
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Fail}\nolabel

\>`fail' V

The value `fail' is used to indicate situations when an operation could
not be performed for the given arguments, either because of shortcomings of
the arguments or because of restrictions in the implementation or
computability. So for example `Position' (see "Position") will return `fail'
if the point searched for is not in the list.

`fail' is simply an object that is different from every other object than
itself.

For technical reasons, `fail' is a boolean value.
But note that `fail' cannot be used to form boolean expressions with
`and', `or', and `not' (see~"Operations for Booleans" below),
and `fail' cannot appear in boolean lists (see Chapter~"Boolean Lists").


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comparisons of Booleans}

\>`<bool1> = <bool2>'{comparisons!of booleans}
\>`<bool1> \<> <bool2>'{comparisons!of booleans}

The equality operator `=' evaluates to `true' if the two boolean values
<bool1> and <bool2> are equal, i.e., both are `true' or both are `false' or
both `fail', and `false' otherwise. The inequality operator `\<>' evaluates
to `true' if the two boolean values <bool1> and <bool2> are different and
`false' otherwise. This operation is also called the *exclusive or*, because
its value is `true' if exactly one of <bool1> or <bool2> is `true'.

You can compare boolean values with objects of other types.
Of course they are never equal.

\beginexample
gap> true = false;
false
gap> false = (true = fail);
true
gap> true <> 17;
true
\endexample

\>`<bool1> \< <bool2>'{ordering!booleans}

The ordering of boolean values is defined by `true \< false \< fail'.
For the comparison of booleans with other {\GAP} objects,
see Section~"Comparisons".

\beginexample
gap> true < false;  fail >= false;
true
true
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Booleans}

\index{operations!for booleans}
\index{logical operations}

The following boolean operations are only applicable to `true' and `false'.

\>`<bool1> or <bool2>'{or}@{`or'}

The logical operator `or' evaluates to `true' if at least one of the two
boolean operands <bool1> and <bool2> is `true' and to `false' otherwise.

`or' first evaluates <bool1>. If the value is neither `true' nor `false'
an error is signalled. If the value is `true', then `or' returns `true'
*without* evaluating <bool2>.  If the value is `false', then `or'
evaluates <bool2>. Again, if the value is neither `true' nor `false' an
error is signalled. Otherwise `or' returns the value of <bool2>. This
*short-circuited* evaluation is important if  the value of <bool1> is
`true' and evaluation of <bool2> would take much time or cause an error.

`or' is associative, i.e., it is allowed to write `<b1> or <b2> or <b3>',
which is interpreted as `(<b1> or <b2>) or <b3>'.  `or' has the lowest
precedence of the logical operators.  All logical operators have lower
precedence than the comparison operators `=', `\<', `in', etc.

\beginexample
gap> true or false;
true
gap> false or false;
false
gap> i := -1;; l := [1,2,3];;
gap> if i <= 0 or l[i] = false then     # this does not cause an error,
>    Print("aha\n"); fi;                # because `l[i]' is not evaluated
aha
\endexample

\>`<bool1> and <bool2>'{and}@{`and'}

The logical operator `and' evaluates to `true' if both boolean operands
<bool1> and <bool2> are `true' and to `false' otherwise.

`and' first evaluates <bool1>.  If the value  is neither `true' nor
`false' an error is signalled.  If the value is `false', then `and'
returns `false' *without* evaluating <bool2>. If the value is `true',
then `and' evaluates <bool2>. Again, if the value is neither `true' nor
`false' an error is signalled.  Otherwise  `and' returns the value of
<bool2>. This *short-circuited* evaluation is important if the value of
<bool1> is `false' and evaluation of  <bool2> would take much time or
cause an error.

`and' is associative, i.e., it is allowed to write `<b1> and <b2> and
<b3>', which is interpreted as `(<b1> and <b2>) and <b3>'. `and' has
higher precedence than the logical `or' operator, but lower than the
unary logical `not' operator.  All  logical operators have  lower
precedence than the comparison operators `=', `\<', `in', etc.

\beginexample
gap> true and false;
false
gap> true and true;
true
gap> false and 17;  # this does not cause an error, because `17' is never looked at
false
\endexample

\>`<fil1> and <fil2>'{and!for filters}@{`and'!for filters}

`and' can also be applied to filters. It returns a filter that when applied
to some argument <x>, tests `<fil1>(<x>) and <fil2>(<x>)'.

\beginexample
gap> andfilt:= IsPosRat and IsInt;;
gap> andfilt( 17 );  andfilt( 1/2 );
true
false
\endexample

\>`not <bool>'{not}@{`not'}

The logical operator `not' returns `true' if the boolean value <bool> is
`false' and `true' otherwise. An error is signalled if <bool> does not
evaluate to `true' or `false'.

`not' has higher precedence than the other logical operators, `or' and
`and'. All logical operators have lower precedence than the comparison
operators `=', `\<', `in', etc.

\beginexample
gap> true and false;
false
gap> not true;
false
gap> not false;
true
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

