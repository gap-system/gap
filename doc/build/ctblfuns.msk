%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  ctblfuns.msk                GAP documentation               Thomas Breuer
%%
%A  @(#)$Id: ctblfuns.msk,v 1.32 2007/01/31 19:02:11 gap Exp $
%%
%Y  (C) 1999 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
%%  The documentation in this chapter corresponds to the declarations in the
%%  library files `ctblfuns.gd', `ctbllatt.gd', `ctblmoli.gd', `ctblpope.gd'.
%%
\Chapter{Class Functions}

\index{characters}
\index{group characters}
\index{virtual characters}
\index{generalized characters}

This chapter describes operations for *class functions of finite groups*.
For operations concerning *character tables*, see Chapter~"Character Tables".

Several examples in this chapter require the {\GAP} Character Table Library
to be available.
If it is not yet loaded then we load it now.

\beginexample
gap> LoadPackage( "ctbllib" );
true
\endexample

\Declaration{IsClassFunction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Why Class Functions?}

\FileHeader[1]{ctblfuns}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Basic Operations for Class Functions}

\FileHeader[2]{ctblfuns}

\Declaration{UnderlyingCharacterTable}
\Declaration{ValuesOfClassFunction}
\beginexample
gap> g:= SymmetricGroup( 4 );
Sym( [ 1 .. 4 ] )
gap> psi:= TrivialCharacter( g );
Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, 1, 1, 1, 1 ] )
gap> UnderlyingCharacterTable( psi );
CharacterTable( Sym( [ 1 .. 4 ] ) )
gap> ValuesOfClassFunction( psi );
[ 1, 1, 1, 1, 1 ]
gap> IsList( psi );
true
gap> psi[1];
1
gap> Length( psi );
5
gap> IsBound( psi[6] );
false
gap> Concatenation( psi, [ 2, 3 ] );
[ 1, 1, 1, 1, 1, 2, 3 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comparison of Class Functions}

\FileHeader[3]{ctblfuns}
\beginexample
gap> grps:= Filtered( AllSmallGroups( 8 ), g -> not IsAbelian( g ) );
[ <pc group of size 8 with 3 generators>, 
  <pc group of size 8 with 3 generators> ]
gap> t1:= CharacterTable( grps[1] );  SetName( t1, "t1" );
CharacterTable( <pc group of size 8 with 3 generators> )
gap> t2:= CharacterTable( grps[2] );  SetName( t2, "t2" );
CharacterTable( <pc group of size 8 with 3 generators> )
gap> irr1:= Irr( grps[1] );
[ Character( t1, [ 1, 1, 1, 1, 1 ] ), Character( t1, [ 1, -1, -1, 1, 1 ] ), 
  Character( t1, [ 1, -1, 1, 1, -1 ] ), Character( t1, [ 1, 1, -1, 1, -1 ] ), 
  Character( t1, [ 2, 0, 0, -2, 0 ] ) ]
gap> irr2:= Irr( grps[2] );
[ Character( t2, [ 1, 1, 1, 1, 1 ] ), Character( t2, [ 1, -1, -1, 1, 1 ] ), 
  Character( t2, [ 1, -1, 1, 1, -1 ] ), Character( t2, [ 1, 1, -1, 1, -1 ] ), 
  Character( t2, [ 2, 0, 0, -2, 0 ] ) ]
gap> irr1 = irr2;
true
gap> IsSSortedList( irr1 );
false
gap> irr1[1] < irr1[2];
false
gap> irr1[2] < irr1[3];
true
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Arithmetic Operations for Class Functions}

\FileHeader[4]{ctblfuns}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Printing Class Functions}

\FileHeader[5]{ctblfuns}
\beginexample
gap> chi:= TrivialCharacter( CharacterTable( "A5" ) );
Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] )
gap> Display( chi );
A5

     2  2  2  .  .  .
     3  1  .  1  .  .
     5  1  .  .  1  1

       1a 2a 3a 5a 5b
    2P 1a 1a 3a 5b 5a
    3P 1a 2a 1a 5b 5a
    5P 1a 2a 3a 1a 1a

Y.1     1  1  1  1  1
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Class Functions from Values Lists}

\Declaration{ClassFunction}
\Declaration{VirtualCharacter}
\Declaration{Character}
\beginexample
gap> g:= DihedralGroup( 8 );  tbl:= CharacterTable( g );
<pc group of size 8 with 3 generators>
CharacterTable( <pc group of size 8 with 3 generators> )
gap> SetName( tbl, "D8" );
gap> phi:= ClassFunction( g, [ 1, -1, 0, 2, -2 ] );
ClassFunction( D8, [ 1, -1, 0, 2, -2 ] )
gap> psi:= ClassFunction( tbl,
>              List( Irr( g ), chi -> ScalarProduct( chi, phi ) ) );
ClassFunction( D8, [ -3/8, 1/8, 9/8, 5/8, -1/4 ] )
gap> chi:= VirtualCharacter( g, [ 0, 0, 8, 0, 0 ] );
VirtualCharacter( D8, [ 0, 0, 8, 0, 0 ] )
gap> reg:= Character( tbl, [ 8, 0, 0, 0, 0 ] );
Character( D8, [ 8, 0, 0, 0, 0 ] )
\endexample

\Declaration{ClassFunctionSameType}
\beginexample
gap> h:= Centre( g );;
gap> centbl:= CharacterTable( h );;  SetName( centbl, "C2" );
gap> ClassFunctionSameType( centbl, phi, [ 1, 1 ] );
ClassFunction( C2, [ 1, 1 ] )
gap> ClassFunctionSameType( centbl, chi, [ 1, 1 ] );
VirtualCharacter( C2, [ 1, 1 ] )
gap> ClassFunctionSameType( centbl, reg, [ 1, 1 ] );
Character( C2, [ 1, 1 ] )
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Class Functions using Groups}

\Declaration{TrivialCharacter}
\beginexample
gap> TrivialCharacter( CharacterTable( "A5" ) );
Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] )
gap> TrivialCharacter( SymmetricGroup( 3 ) );
Character( CharacterTable( Sym( [ 1 .. 3 ] ) ), [ 1, 1, 1 ] )
\endexample

\Declaration{NaturalCharacter}
\beginexample
gap> NaturalCharacter( SymmetricGroup( 3 ) );
Character( CharacterTable( Sym( [ 1 .. 3 ] ) ), [ 3, 1, 0 ] )
gap> NaturalCharacter( Group( [ [ 0, -1 ], [ 1, -1 ] ] ) );
Character( CharacterTable( Group([ [ [ 0, -1 ], [ 1, -1 ] ] ]) ), 
[ 2, -1, -1 ] )
gap> d8:= DihedralGroup( 8 );;  hom:= IsomorphismPermGroup( d8 );;
gap> NaturalCharacter( hom );
Character( CharacterTable( <pc group of size 8 with 3 generators> ), 
[ 8, 0, 0, 0, 0 ] )
\endexample

\Declaration{PermutationCharacter}
\beginexample
gap> PermutationCharacter( GL(2,2), AsSSortedList( GF(2)^2 ), OnRight );
Character( CharacterTable( SL(2,2) ), [ 4, 2, 1 ] )
gap> s3:= SymmetricGroup( 3 );;  a3:= DerivedSubgroup( s3 );;
gap> PermutationCharacter( s3, a3 );
Character( CharacterTable( Sym( [ 1 .. 3 ] ) ), [ 2, 0, 2 ] )
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Class Functions}

\FileHeader[6]{ctblfuns}

\Declaration{IsCharacter}
\Declaration{IsVirtualCharacter}
\Declaration{IsIrreducibleCharacter}
\beginexample
gap> S4:= SymmetricGroup( 4 );;  SetName( S4, "S4" );
gap> psi:= ClassFunction( S4, [ 1, 1, 1, -2, 1 ] );
ClassFunction( CharacterTable( S4 ), [ 1, 1, 1, -2, 1 ] )
gap> IsVirtualCharacter( psi );
true
gap> IsCharacter( psi );
false
gap> chi:= ClassFunction( S4, SizesCentralizers( CharacterTable( S4 ) ) );
ClassFunction( CharacterTable( S4 ), [ 24, 4, 8, 3, 4 ] )
gap> IsCharacter( chi );
true
gap> IsIrreducibleCharacter( chi );
false
gap> IsIrreducibleCharacter( TrivialCharacter( S4 ) );
true
\endexample

\Declaration{DegreeOfCharacter}
\beginexample
gap> List( Irr( S4 ), DegreeOfCharacter );
[ 1, 3, 2, 3, 1 ]
gap> nat:= NaturalCharacter( S4 );
Character( CharacterTable( S4 ), [ 4, 2, 0, 1, 0 ] )
gap> nat[1];
4
\endexample

\index{constituent!of a group character}
\index{decompose!a group character}
\index{multiplicity!of constituents of a group character}
\index{inner product!of group characters}

\Declaration{ScalarProduct}[ctblfuns]!{for characters}
\Declaration{MatScalarProducts}
\Declaration{Norm}[ctblfuns]!{of character}
\beginexample
gap> tbl:= CharacterTable( "A5" );;
gap> ScalarProduct( TrivialCharacter( tbl ), Sum( Irr( tbl ) ) );
1
gap> ScalarProduct( tbl, [ 1, 1, 1, 1, 1 ], Sum( Irr( tbl ) ) );
1
gap> chars:= Irr( tbl ){ [ 2 .. 4 ] };;
gap> chars:= Set( Tensored( chars, chars ) );;
gap> MatScalarProducts( Irr( tbl ), chars );
[ [ 0, 0, 0, 1, 1 ], [ 1, 1, 0, 0, 1 ], [ 1, 0, 1, 0, 1 ], [ 0, 1, 0, 1, 1 ], 
  [ 0, 0, 1, 1, 1 ], [ 1, 1, 1, 1, 1 ] ]
gap> MatScalarProducts( tbl, chars );
[ [ 2 ], [ 1, 3 ], [ 1, 2, 3 ], [ 2, 2, 1, 3 ], [ 2, 1, 2, 2, 3 ], 
  [ 2, 3, 3, 3, 3, 5 ] ]
gap> List( chars, Norm );
[ 2, 3, 3, 3, 3, 5 ]
\endexample

\Declaration{ConstituentsOfCharacter}
\beginexample
gap> nat:= NaturalCharacter( S4 );
Character( CharacterTable( S4 ), [ 4, 2, 0, 1, 0 ] )
gap> ConstituentsOfCharacter( nat );
[ Character( CharacterTable( S4 ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( S4 ), [ 3, 1, -1, 0, -1 ] ) ]
\endexample

\Declaration{KernelOfCharacter}
\Declaration{ClassPositionsOfKernel}
\beginexample
gap> List( Irr( S4 ), KernelOfCharacter );
[ Group([ (), (1,2)(3,4), (1,2,3) ]), Group(()), 
  Group([ (1,2)(3,4), (1,4)(2,3) ]), Group(()), 
  Group([ (), (1,2), (1,2)(3,4), (1,2,3), (1,2,3,4) ]) ]
gap> List( Irr( S4 ), ClassPositionsOfKernel );
[ [ 1, 3, 4 ], [ 1 ], [ 1, 3 ], [ 1 ], [ 1, 2, 3, 4, 5 ] ]
\endexample

\Declaration{CentreOfCharacter}
\Declaration{ClassPositionsOfCentre}[ctblfuns]!{for characters}
\beginexample
gap> List( Irr( S4 ), CentreOfCharacter );
[ Group([ (), (1,2), (1,2)(3,4), (1,2,3), (1,2,3,4) ]), Group(()), 
  Group([ (1,2)(3,4), (1,4)(2,3) ]), Group(()), 
  Group([ (), (1,2), (1,2)(3,4), (1,2,3), (1,2,3,4) ]) ]
gap> List( Irr( S4 ), ClassPositionsOfCentre );
[ [ 1, 2, 3, 4, 5 ], [ 1 ], [ 1, 3 ], [ 1 ], [ 1, 2, 3, 4, 5 ] ]
\endexample

\Declaration{InertiaSubgroup}
\beginexample
gap> der:= DerivedSubgroup( S4 );
Group([ (1,3,2), (2,4,3) ])
gap> List( Irr( der ), chi -> InertiaSubgroup( S4, chi ) );
[ S4, Alt( [ 1 .. 4 ] ), Alt( [ 1 .. 4 ] ), S4 ]
\endexample

\Declaration{CycleStructureClass}
\beginexample
gap> nat:= NaturalCharacter( S4 );
Character( CharacterTable( S4 ), [ 4, 2, 0, 1, 0 ] )
gap> List( [ 1 .. 5 ], i -> CycleStructureClass( nat, i ) );
[ [  ], [ 1 ], [ 2 ], [ , 1 ], [ ,, 1 ] ]
\endexample

\Declaration{IsTransitive}[ctblfuns]!{for characters}
\Declaration{Transitivity}[ctblfuns]!{for characters}
\beginexample
gap> IsTransitive( nat );  Transitivity( nat );
true
4
gap> Transitivity( 2 * TrivialCharacter( S4 ) );
0
\endexample

\Declaration{CentralCharacter}
\Declaration{DeterminantOfCharacter}
\beginexample
gap> CentralCharacter( TrivialCharacter( S4 ) );
ClassFunction( CharacterTable( S4 ), [ 1, 6, 3, 8, 6 ] )
gap> DeterminantOfCharacter( Irr( S4 )[3] );
Character( CharacterTable( S4 ), [ 1, -1, 1, 1, -1 ] )
\endexample

\Declaration{EigenvaluesChar}
\beginexample
gap> chi:= Irr( CharacterTable( "A5" ) )[2];
Character( CharacterTable( "A5" ), [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 
 ] )
gap> List( [ 1 .. 5 ], i -> Eigenvalues( chi, i ) );
[ [ 3 ], [ 2, 1 ], [ 1, 1, 1 ], [ 0, 1, 1, 0, 1 ], [ 1, 0, 0, 1, 1 ] ]
\endexample

\Declaration{Tensored}
\beginexample
gap> irra5:= Irr( CharacterTable( "A5" ) );;
gap> chars1:= irra5{ [ 1 .. 3 ] };;  chars2:= irra5{ [ 2, 3 ] };;
gap> Tensored( chars1, chars2 );
[ Character( CharacterTable( "A5" ), [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 
     ] ), Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 9, 1, 0, -2*E(5)-E(5)^2-E(5)^3-2*E(5)^4, -E(5)-2*E(5)^2-2*E(5)^3-E(5)^4 
     ] ), Character( CharacterTable( "A5" ), [ 9, 1, 0, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 9, 1, 0, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 9, 1, 0, -E(5)-2*E(5)^2-2*E(5)^3-E(5)^4, -2*E(5)-E(5)^2-E(5)^3-2*E(5)^4 
     ] ) ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Restricted and Induced Class Functions}

\FileHeader[7]{ctblfuns}

\Declaration{RestrictedClassFunction}
\Declaration{RestrictedClassFunctions}
\beginexample
gap> a5:= CharacterTable( "A5" );;  s5:= CharacterTable( "S5" );;
gap> RestrictedClassFunction( Irr( s5 )[2], a5 );
Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] )
gap> RestrictedClassFunctions( Irr( s5 ), a5 );
[ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 6, -2, 0, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ) ]
gap> hom:= NaturalHomomorphismByNormalSubgroup( S4, der );;
gap> RestrictedClassFunctions( Irr( Image( hom ) ), hom );
[ Character( CharacterTable( S4 ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( S4 ), [ 1, -1, 1, 1, -1 ] ) ]
\endexample

\Declaration{InducedClassFunction}
\Declaration{InducedClassFunctions}
\beginexample
gap> InducedClassFunctions( Irr( a5 ), s5 );
[ Character( CharacterTable( "A5.2" ), [ 2, 2, 2, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 6, -2, 0, 1, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 6, -2, 0, 1, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 8, 0, 2, -2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 10, 2, -2, 0, 0, 0, 0 ] ) ]
\endexample

\Declaration{InducedCyclic}
\beginexample
gap> InducedCyclic( a5, "all" );
[ Character( CharacterTable( "A5" ), [ 12, 0, 0, 2, 2 ] ), 
  Character( CharacterTable( "A5" ), [ 12, 0, 0, E(5)^2+E(5)^3, E(5)+E(5)^4 
     ] ), Character( CharacterTable( "A5" ), 
    [ 12, 0, 0, E(5)+E(5)^4, E(5)^2+E(5)^3 ] ), 
  Character( CharacterTable( "A5" ), [ 20, 0, -1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 20, 0, 2, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 30, -2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 30, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 60, 0, 0, 0, 0 ] ) ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Reducing Virtual Characters}

\FileHeader[8]{ctblfuns}

\Declaration{ReducedClassFunctions}
\Declaration{ReducedCharacters}
\beginexample
gap> tbl:= CharacterTable( "A5" );;
gap> chars:= Irr( tbl ){ [ 2 .. 4 ] };;
gap> chars:= Set( Tensored( chars, chars ) );;
gap> red:= ReducedClassFunctions( chars );
rec( remainders := [  ], 
  irreducibles := [ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "A5" ), 
        [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] ), 
      Character( CharacterTable( "A5" ), 
        [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ), 
      Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
      Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ) ] )
\endexample

\Declaration{IrreducibleDifferences}
\beginexample
gap> IrreducibleDifferences( a5, chars, "triangle" );
[ Character( CharacterTable( "A5" ), [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 
     ] ), Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ) ]
\endexample

\Declaration{LLL}
\beginexample
gap> s4:= CharacterTable( "Symmetric", 4 );;
gap> chars:= [ [ 8, 0, 0, -1, 0 ], [ 6, 0, 2, 0, 2 ],
>     [ 12, 0, -4, 0, 0 ], [ 6, 0, -2, 0, 0 ], [ 24, 0, 0, 0, 0 ],
>     [ 12, 0, 4, 0, 0 ], [ 6, 0, 2, 0, -2 ], [ 12, -2, 0, 0, 0 ],
>     [ 8, 0, 0, 2, 0 ], [ 12, 2, 0, 0, 0 ], [ 1, 1, 1, 1, 1 ] ];;
gap> LLL( s4, chars );
rec( 
  irreducibles := [ Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 
         ] ), Character( CharacterTable( "Sym(4)" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, 1, -1, 0, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ) ], 
  remainders := [  ], norms := [  ] )
\endexample

\Declaration{Extract}
\beginexample
gap> s4:= CharacterTable( "Symmetric", 4 );;
gap> red:= [ [ 5, 1, 5, 2, 1 ], [ 2, 0, 2, 2, 0 ], [ 3, -1, 3, 0, -1 ],
>            [ 6, 0, -2, 0, 0 ], [ 4, 0, 0, 1, 2 ] ];;
gap> gram:= MatScalarProducts( s4, red, red );
[ [ 6, 3, 2, 0, 2 ], [ 3, 2, 1, 0, 1 ], [ 2, 1, 2, 0, 0 ], [ 0, 0, 0, 2, 1 ], 
  [ 2, 1, 0, 1, 2 ] ]
gap> ext:= Extract( s4, red, gram, 5 );
rec( 
  solution := [ [ [ 1, 1, 0, 0, 2 ], [ 1, 0, 1, 0, 1 ], [ 0, 1, 0, 1, 0 ], [ 
              0, 0, 1, 0, 1 ], [ 0, 0, 0, 1, 0 ] ] ], 
  choice := [ [ 2, 5, 3, 4, 1 ] ] )
gap> dec:= Decreased( s4, red, ext.solution[1], ext.choice[1] );;
gap> Display( dec );
rec(
  irreducibles := 
   [ Character( CharacterTable( "Sym(4)" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, 1, -1, 0, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ) ],
  remainders := [  ],
  matrix := [  ] )
\endexample

\Declaration{OrthogonalEmbeddingsSpecialDimension}
\beginexample
gap> s6:= CharacterTable( "S6" );;
gap> red:= InducedCyclic( s6, "all" );;
gap> Add( red, TrivialCharacter( s6 ) );
gap> lll:= LLL( s6, red );;
gap> irred:= lll.irreducibles;
[ Character( CharacterTable( "A6.2_1" ), [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] )
    , Character( CharacterTable( "A6.2_1" ), [ 9, 1, 0, 0, 1, -1, -3, -3, 1, 
      0, 0 ] ), Character( CharacterTable( "A6.2_1" ), 
    [ 16, 0, -2, -2, 0, 1, 0, 0, 0, 0, 0 ] ) ]
gap> Set( Flat( MatScalarProducts( s6, irred, lll.remainders ) ) );
[ 0 ]
gap> dim:= NrConjugacyClasses( s6 ) - Length( lll.irreducibles );
8
gap> rem:= lll.remainders;;  Length( rem );
8
gap> gram:= MatScalarProducts( s6, rem, rem );;  RankMat( gram );
8
gap> emb1:= OrthogonalEmbeddings( gram, 8 );
rec( vectors := [ [ -1, 0, 1, 0, 1, 0, 1, 0 ], [ 1, 0, 0, 1, 0, 1, 0, 0 ], 
      [ 0, 1, 1, 0, 0, 0, 1, 1 ], [ 0, 1, 1, 0, 0, 0, 1, 0 ], 
      [ 0, 1, 1, 0, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0, 0, 1, 0 ], 
      [ 0, -1, 0, 0, 0, 0, 0, 1 ], [ 0, 1, 0, 0, 0, 0, 0, 0 ], 
      [ 0, 0, 1, 0, 0, 0, 1, 1 ], [ 0, 0, 1, 0, 0, 0, 0, 1 ], 
      [ 0, 0, 1, 0, 0, 0, 0, 0 ], [ 0, 0, 0, -1, 1, 0, 0, 0 ], 
      [ 0, 0, 0, 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 1, 1 ], 
      [ 0, 0, 0, 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 1 ] ], 
  norms := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], 
  solutions := [ [ 1, 2, 3, 7, 11, 12, 13, 15 ], 
      [ 1, 2, 4, 8, 10, 12, 13, 14 ], [ 1, 2, 5, 6, 9, 12, 13, 16 ] ] )
\endexample

In the following example we temporarily decrease the line length limit from
its default value 80 to 62 in order to get a nicer output format.

\beginexample
gap> SizeScreen([ 62, ]);;
gap> emb2:= OrthogonalEmbeddingsSpecialDimension( s6, rem, gram, 8 );
rec( 
  irreducibles := [ Character( CharacterTable( "A6.2_1" ), 
        [ 5, 1, -1, 2, -1, 0, 1, -3, -1, 1, 0 ] ), 
      Character( CharacterTable( "A6.2_1" ), 
        [ 5, 1, 2, -1, -1, 0, -3, 1, -1, 0, 1 ] ), 
      Character( CharacterTable( "A6.2_1" ), 
        [ 10, -2, 1, 1, 0, 0, -2, 2, 0, 1, -1 ] ), 
      Character( CharacterTable( "A6.2_1" ), 
        [ 10, -2, 1, 1, 0, 0, 2, -2, 0, -1, 1 ] ) ], 
  remainders := 
    [ VirtualCharacter( CharacterTable( "A6.2_1" ), 
        [ 0, 0, 3, -3, 0, 0, 4, -4, 0, 1, -1 ] ), 
      VirtualCharacter( CharacterTable( "A6.2_1" ), 
        [ 6, 2, 3, 0, 0, 1, 2, -2, 0, -1, -2 ] ), 
      VirtualCharacter( CharacterTable( "A6.2_1" ), 
        [ 10, 2, 1, 1, 2, 0, 2, 2, -2, -1, -1 ] ), 
      VirtualCharacter( CharacterTable( "A6.2_1" ), 
        [ 14, 2, 2, -1, 0, -1, 6, 2, 0, 0, -1 ] ) ] )
gap> SizeScreen([ 80, ]);;
\endexample

\Declaration{Decreased}
\beginexample
gap> s4:= CharacterTable( "Symmetric", 4 );;
gap> x:= Irr( s4 );;
gap> red:= [ x[1]+x[2], -x[1]-x[3], -x[1]+x[3], -x[2]-x[4] ];;
gap> mat:= MatScalarProducts( s4, red, red );
[ [ 2, -1, -1, -1 ], [ -1, 2, 0, 0 ], [ -1, 0, 2, 0 ], [ -1, 0, 0, 2 ] ]
gap> emb:= OrthogonalEmbeddings( mat );
rec( vectors := [ [ -1, 1, 1, 0 ], [ -1, 1, 0, 1 ], [ 1, -1, 0, 0 ], 
      [ -1, 0, 1, 1 ], [ -1, 0, 1, 0 ], [ -1, 0, 0, 1 ], [ 0, -1, 1, 0 ], 
      [ 0, -1, 0, 1 ], [ 0, 1, 0, 0 ], [ 0, 0, -1, 1 ], [ 0, 0, 1, 0 ], 
      [ 0, 0, 0, 1 ] ], norms := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], 
  solutions := [ [ 1, 6, 7, 12 ], [ 2, 5, 8, 11 ], [ 3, 4, 9, 10 ] ] )
gap> dec:= Decreased( s4, red, emb.vectors{ emb.solutions[1] } );;
gap> Display( dec );
rec(
  irreducibles := 
   [ Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, 1, -1, 0, -1 ] ) ],
  remainders := [  ],
  matrix := [  ] )
gap> Decreased( s4, red, emb.vectors{ emb.solutions[2] } );
fail
gap> Decreased( s4, red, emb.vectors{ emb.solutions[3] } );
fail
\endexample

\Declaration{DnLattice}
\beginexample
gap> s4:= CharacterTable( "Symmetric", 4 );;
gap> red:= [ [ 2, 0, 2, 2, 0 ], [ 4, 0, 0, 1, 2 ],
>            [ 5, -1, 1, -1, 1 ], [ -1, 1, 3, -1, -1 ] ];;
gap> gram:= MatScalarProducts( s4, red, red );
[ [ 2, 1, 0, 0 ], [ 1, 2, 1, -1 ], [ 0, 1, 2, 0 ], [ 0, -1, 0, 2 ] ]
gap> dn:= DnLattice( s4, gram, red );; Display( dn );
rec(
  gram := [  ],
  remainders := [  ],
  irreducibles := 
   [ Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ) ] )
\endexample

\Declaration{DnLatticeIterative}
\beginexample
gap> s4:= CharacterTable( "Symmetric", 4 );;
gap> red:= [ [ 2, 0, 2, 2, 0 ], [ 4, 0, 0, 1, 2 ],
>            [ 5, -1, 1, -1, 1 ], [ -1, 1, 3, -1, -1 ] ];;
gap> dn:= DnLatticeIterative( s4, red );; Display( dn );
rec(
  irreducibles := 
   [ Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ) ],
  remainders := [  ],
  norms := [  ] )
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Symmetrizations of Class Functions}

\index{characters!symmetrizations of}

\Declaration{Symmetrizations}
\beginexample
gap> tbl:= CharacterTable( "A5" );;
gap> Symmetrizations( Irr( tbl ){ [ 1 .. 3 ] }, 3 );
[ VirtualCharacter( CharacterTable( "A5" ), [ 0, 0, 0, 0, 0 ] ), 
  VirtualCharacter( CharacterTable( "A5" ), [ 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 8, 0, -1, -E(5)-E(5)^4, -E(5)^2-E(5)^3 
     ] ), Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 8, 0, -1, -E(5)^2-E(5)^3, -E(5)-E(5)^4 
     ] ), Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ) ]
\endexample

\Declaration{SymmetricParts}
\beginexample
gap> SymmetricParts( tbl, Irr( tbl ), 3 );
[ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 20, 0, 2, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 35, 3, 2, 0, 0 ] ) ]
\endexample

\Declaration{AntiSymmetricParts}
\beginexample
gap> AntiSymmetricParts( tbl, Irr( tbl ), 3 );
[ VirtualCharacter( CharacterTable( "A5" ), [ 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ) ]
\endexample

\Declaration{OrthogonalComponents}
\index{symmetrizations!orthogonal}%
\index{Frame}%
\atindex{Murnaghan components}{@Murnaghan components}
\beginexample
gap> tbl:= CharacterTable( "A8" );;  chi:= Irr( tbl )[2];
Character( CharacterTable( "A8" ), [ 7, -1, 3, 4, 1, -1, 1, 2, 0, -1, 0, 0, 
  -1, -1 ] )
gap> OrthogonalComponents( tbl, [ chi ], 3 );
[ ClassFunction( CharacterTable( "A8" ), [ 21, -3, 1, 6, 0, 1, -1, 1, -2, 0, 
      0, 0, 1, 1 ] ), ClassFunction( CharacterTable( "A8" ), 
    [ 27, 3, 7, 9, 0, -1, 1, 2, 1, 0, -1, -1, -1, -1 ] ), 
  ClassFunction( CharacterTable( "A8" ), [ 105, 1, 5, 15, -3, 1, -1, 0, -1, 
      1, 0, 0, 0, 0 ] ), ClassFunction( CharacterTable( "A8" ), 
    [ 35, 3, -5, 5, 2, -1, -1, 0, 1, 0, 0, 0, 0, 0 ] ), 
  ClassFunction( CharacterTable( "A8" ), [ 77, -3, 13, 17, 2, 1, 1, 2, 1, 0, 
      0, 0, 2, 2 ] ) ]
\endexample

\Declaration{SymplecticComponents}
\index{symmetrizations!symplectic}%
\atindex{Murnaghan components}{@Murnaghan components}
\beginexample
gap> tbl:= CharacterTable( "U3(3)" );;  chi:= Irr( tbl )[2];
Character( CharacterTable( "U3(3)" ), [ 6, -2, -3, 0, -2, -2, 2, 1, -1, -1, 
  0, 0, 1, 1 ] )
gap> SymplecticComponents( tbl, [ chi ], 3 );
[ ClassFunction( CharacterTable( "U3(3)" ), [ 14, -2, 5, -1, 2, 2, 2, 1, 0, 
      0, 0, 0, -1, -1 ] ), ClassFunction( CharacterTable( "U3(3)" ), 
    [ 21, 5, 3, 0, 1, 1, 1, -1, 0, 0, -1, -1, 1, 1 ] ), 
  ClassFunction( CharacterTable( "U3(3)" ), [ 64, 0, -8, -2, 0, 0, 0, 0, 1, 
      1, 0, 0, 0, 0 ] ), ClassFunction( CharacterTable( "U3(3)" ), 
    [ 14, 6, -4, 2, -2, -2, 2, 0, 0, 0, 0, 0, -2, -2 ] ), 
  ClassFunction( CharacterTable( "U3(3)" ), [ 56, -8, 2, 2, 0, 0, 0, -2, 0, 
      0, 0, 0, 0, 0 ] ) ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Molien Series}\nolabel

\Declaration{MolienSeries}
\beginexample
gap> t:= CharacterTable( AlternatingGroup( 5 ) );;
gap> psi:= First( Irr( t ), x -> Degree( x ) = 3 );;
gap> mol:= MolienSeries( psi );
( 1-z^2-z^3+z^6+z^7-z^9 ) / ( (1-z^5)*(1-z^3)*(1-z^2)^2 )
\endexample

\Declaration{MolienSeriesInfo}
\beginexample
gap> HasMolienSeriesInfo( mol );
true
gap> MolienSeriesInfo( mol );
rec( summands := [ rec( numer := [ -24, -12, -24 ], r := 5, k := 1 ), 
      rec( numer := [ -20 ], r := 3, k := 1 ), 
      rec( numer := [ -45/4, 75/4, -15/4, -15/4 ], r := 2, k := 2 ), 
      rec( numer := [ -1 ], r := 1, k := 3 ), 
      rec( numer := [ -15/4 ], r := 1, k := 1 ) ], size := 60, degree := 3, 
  numer := -x_1^9+x_1^7+x_1^6-x_1^3-x_1^2+1, 
  denom := x_1^12-2*x_1^10-x_1^9+x_1^8+x_1^7+x_1^5+x_1^4-x_1^3-2*x_1^2+1, 
  denominfo := [ 5, 1, 3, 1, 2, 2 ], numerstring := "1-z^2-z^3+z^6+z^7-z^9", 
  denomstring := "(1-z^5)*(1-z^3)*(1-z^2)^2", 
  ratfun := ( 1-z^2-z^3+z^6+z^7-z^9 ) / ( (1-z^5)*(1-z^3)*(1-z^2)^2 ) )
\endexample

\Declaration{ValueMolienSeries}
\beginexample
gap> List( [ 0 .. 20 ], i -> ValueMolienSeries( mol, i ) );
[ 1, 0, 1, 0, 1, 0, 2, 0, 2, 0, 3, 0, 4, 0, 4, 1, 5, 1, 6, 1, 7 ]
\endexample

\Declaration{MolienSeriesWithGivenDenominator}
\beginexample
gap> MolienSeriesWithGivenDenominator( mol, [ 2, 6, 10 ] );
( 1+z^15 ) / ( (1-z^10)*(1-z^6)*(1-z^2) )
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Possible Permutation Characters}

\index{characters!permutation}%
\index{candidates!for permutation characters}%
\index{possible permutation characters}%
\index{permutation characters!possible}

\FileHeader[1]{ctblpope}

\Declaration{PermCharInfo}
\beginexample
gap> t:= CharacterTable( "A6" );;
gap> psi:= Sum( Irr( t ){ [ 1, 3, 6 ] } );
Character( CharacterTable( "A6" ), [ 15, 3, 0, 3, 1, 0, 0 ] )
gap> info:= PermCharInfo( t, psi );
rec( contained := [ [ 1, 9, 0, 8, 6, 0, 0 ] ], 
  bound := [ [ 1, 3, 8, 8, 6, 24, 24 ] ], 
  display := rec( classes := [ 1, 2, 4, 5 ], 
      chars := [ [ 15, 3, 0, 3, 1, 0, 0 ], [ 1, 9, 0, 8, 6, 0, 0 ], 
          [ 1, 3, 8, 8, 6, 24, 24 ] ], letter := "I" ), 
  ATLAS := [ "1a+5b+9a" ] )
gap> Display( t, info.display );
A6

     2  3  3  .  2
     3  2  .  2  .
     5  1  .  .  .

       1a 2a 3b 4a
    2P 1a 1a 3b 2a
    3P 1a 2a 1a 4a
    5P 1a 2a 3b 4a

Y.1    15  3  3  1
Y.2     1  9  8  6
Y.3     1  3  8  6
gap> j1:= CharacterTable( "J1" );;
gap> psi:= TrivialCharacter( CharacterTable( "7:6" ) )^j1;
Character( CharacterTable( "J1" ), [ 4180, 20, 10, 0, 0, 2, 1, 0, 0, 0, 0, 0, 
  0, 0, 0 ] )
gap> PermCharInfo( j1, psi ).ATLAS;
[ "1a+56aabb+76aaab+77aabbcc+120aaabbbccc+133a^{4}bbcc+209a^{5}" ]
\endexample

\Declaration{PermCharInfoRelative}
\beginexample
gap> t:= CharacterTable( "A5" );;
gap> t2:= CharacterTable( "A5.2" );;
gap> List( Irr( t2 ), x -> x[1] );
[ 1, 1, 6, 4, 4, 5, 5 ]
gap> List( Irr( t ), x -> x[1] );
[ 1, 3, 3, 4, 5 ]
gap> permchars:= List( [ [1], [1,2], [1,7], [1,3,4,4,6,6,7] ],
>                      l -> Sum( Irr( t2 ){ l } ) );
[ Character( CharacterTable( "A5.2" ), [ 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5.2" ), [ 2, 2, 2, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 6, 2, 0, 1, 0, 2, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 30, 2, 0, 0, 6, 0, 0 ] ) ]
gap> info:= PermCharInfoRelative( t, t2, permchars );;
gap> info.ATLAS;
[ "1a^+", "1a^{\\pm}", "1a^++5a^-", "1a^++3ab+4(a^+)^{2}+5a^{\\pm}a^+" ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Computing Possible Permutation Characters}

\index{characters!permutation}%
\index{candidates!for permutation characters}%
\index{possible permutation characters}%
\index{permutation characters!possible}

\Declaration{PermChars}

\Declaration{TestPerm1}
\beginexample
gap> tbl:= CharacterTable( "A5" );;
gap> rat:= RationalizedMat( Irr( tbl ) );
[ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 6, -2, 0, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ) ]
gap> tup:= Filtered( Tuples( [ 0, 1 ], 4 ), x -> not IsZero( x ) );
[ [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ], [ 0, 0, 1, 1 ], [ 0, 1, 0, 0 ], 
  [ 0, 1, 0, 1 ], [ 0, 1, 1, 0 ], [ 0, 1, 1, 1 ], [ 1, 0, 0, 0 ], 
  [ 1, 0, 0, 1 ], [ 1, 0, 1, 0 ], [ 1, 0, 1, 1 ], [ 1, 1, 0, 0 ], 
  [ 1, 1, 0, 1 ], [ 1, 1, 1, 0 ], [ 1, 1, 1, 1 ] ]
gap> lincomb:= List( tup, coeff -> coeff * rat );;
gap> List( lincomb, psi -> TestPerm1( tbl, psi ) );
[ 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0 ]
gap> List( lincomb, psi -> TestPerm2( tbl, psi ) );
[ 0, 5, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1 ]
gap> Set( List( TestPerm3( tbl, lincomb ), x -> Position( lincomb, x ) ) );
[ 1, 4, 6, 7, 8, 9, 10, 11, 13 ]
gap> tbl:= CharacterTable( "A7" );
CharacterTable( "A7" )
gap> perms:= PermChars( tbl, rec( degree:= 315 ) );
[ Character( CharacterTable( "A7" ), [ 315, 3, 0, 0, 3, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "A7" ), [ 315, 15, 0, 0, 1, 0, 0, 0, 0 ] ) ]
gap> TestPerm4( tbl, perms );
[ Character( CharacterTable( "A7" ), [ 315, 15, 0, 0, 1, 0, 0, 0, 0 ] ) ]
gap> perms:= PermChars( tbl, rec( degree:= 15 ) );
[ Character( CharacterTable( "A7" ), [ 15, 3, 0, 3, 1, 0, 0, 1, 1 ] ), 
  Character( CharacterTable( "A7" ), [ 15, 3, 3, 0, 1, 0, 3, 1, 1 ] ) ]
gap> TestPerm5( tbl, perms, tbl mod 5 );
[ Character( CharacterTable( "A7" ), [ 15, 3, 0, 3, 1, 0, 0, 1, 1 ] ) ]
\endexample

\Declaration{PermBounds}
\Declaration{PermComb}
\Declaration{Inequalities}

\beginexample
gap> tbl:= CharacterTable( "M11" );;
gap> PermComb( tbl, rec( degree:= 110 ) );
[ Character( CharacterTable( "M11" ), [ 110, 6, 2, 2, 0, 0, 2, 2, 0, 0 ] ), 
  Character( CharacterTable( "M11" ), [ 110, 6, 2, 6, 0, 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "M11" ), [ 110, 14, 2, 2, 0, 2, 0, 0, 0, 0 ] ) ]
gap> # Now compute only multiplicity free permutation characters.
gap> bounds:= List( RationalizedMat( Irr( tbl ) ), x -> 1 );;
gap> PermComb( tbl, rec( degree:= 110, maxmult:= bounds ) );
[ Character( CharacterTable( "M11" ), [ 110, 6, 2, 2, 0, 0, 2, 2, 0, 0 ] ) ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Brauer Characters}

\Declaration{FrobeniusCharacterValue}
\Declaration{BrauerCharacterValue}
\beginexample
gap> g:= SL(2,4);;           # 2-dim. irreducible representation of A5
gap> ccl:= ConjugacyClasses( g );;
gap> rep:= List( ccl, Representative );;
gap> List( rep, Order );
[ 1, 2, 5, 5, 3 ]
gap> phi:= List( rep, BrauerCharacterValue );
[ 2, fail, E(5)^2+E(5)^3, E(5)+E(5)^4, -1 ]
gap> List( phi{ [ 1, 3, 4, 5 ] }, x -> FrobeniusCharacterValue( x, 2 ) );
[ 0*Z(2), Z(2^2), Z(2^2)^2, Z(2)^0 ]
gap> List( rep{ [ 1, 3, 4, 5 ] }, TraceMat );
[ 0*Z(2), Z(2^2), Z(2^2)^2, Z(2)^0 ]
\endexample

\Declaration{SizeOfFieldOfDefinition}
\Declaration{RealizableBrauerCharacters}
\beginexample
gap> irr:= Irr( CharacterTable( "A5" ) mod 2 );
[ Character( BrauerTable( "A5", 2 ), [ 1, 1, 1, 1 ] ), 
  Character( BrauerTable( "A5", 2 ), [ 2, -1, E(5)+E(5)^4, E(5)^2+E(5)^3 ] ), 
  Character( BrauerTable( "A5", 2 ), [ 2, -1, E(5)^2+E(5)^3, E(5)+E(5)^4 ] ), 
  Character( BrauerTable( "A5", 2 ), [ 4, 1, -1, -1 ] ) ]
gap> List( irr, phi -> SizeOfFieldOfDefinition( phi, 2 ) );
[ 2, 4, 4, 2 ]
gap> RealizableBrauerCharacters( irr, 2 );
[ Character( BrauerTable( "A5", 2 ), [ 1, 1, 1, 1 ] ), 
  ClassFunction( BrauerTable( "A5", 2 ), [ 4, -2, -1, -1 ] ), 
  Character( BrauerTable( "A5", 2 ), [ 4, 1, -1, -1 ] ) ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Domains Generated by Class Functions}

{\GAP} supports groups, vector spaces, and algebras generated by class
functions.

\beginexample
gap> d8:= DihedralGroup( 8 );
<pc group of size 8 with 3 generators>
gap> lin:= LinearCharacters( d8 );;
gap> irr:= Irr( d8 );;
gap> g:= Group( lin, lin[1] );
<group with 4 generators>
gap> Size( g );
4
gap> IdGroup( g );
[ 4, 2 ]
gap> v:= VectorSpace( Rationals, lin );;
gap> w:= VectorSpace( Rationals, irr );;
gap> Dimension( v );
4
gap> Dimension( w );
5
\endexample

Note that for generating a group of class functions,
one should use the two-argument version of `Group' (see~"Group"),
because a call of the one-argument version will return the cyclic matrix
group generated by the matrix of the intended generating class functions
if this matrix is invertible.
% Otherwise it seems to work -- why?

\beginexample
gap> g:= CyclicGroup( 4 );;
gap> irr:= Irr( g );;
gap> Size( Group( irr ) );
infinity
gap> Size( Group( irr, TrivialCharacter( g ) ) );
4
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

