%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Solvable Groups}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Polycyclic generating systems}

A  generating  sequence $(g_1,\ldots,g_n)$ for a   group <G> is  called a
*polycyclic generating system* (or *pcgs*)  if the series of subgroups $G
= G_0 > G_1 > \ldots >  G_n = \{1\}$ with  $G_i = \< g_{i+1}, \ldots, g_n
>$ is a  subnormal series for   <G> with cyclic factors $G_i/G_{i+1}$  of
prime order. Such  a pcgs exists for  a finite <G> if  and only if <G> is
solvable.

\>Pcgs( <G> )

This function constructs  and returns a  pcgs for the group  <G> if it is
solvable and returns `fail' otherwise.

\>ExponentsOfPcElement( <pcgs>, <g> )
\>DepthOfPcElement( <pcgs>, <g> )
\>LeadingExponentOfPcElement( <pcgs>, <g> )

These functions ``factorize'' a given  element <g> of `<pcgs>.group' into
the  generators  in  the  list $(g_1,\ldots,g_n)$. `ExponentsOfPcElement'
returns a list <e> such that
$$ g = g_1^{e[1]}.g_2^{e[2]}.\ldots.g_n^{e[n]}\. $$
The  default method  performs  a division algorithm,  i.e., it determines
$e[1]$ such that $g_1^{-e[1]}g \in \< g_2, \ldots,  g_n >$, by increasing
$e[1]$  until the membership  test yields  true. Then  <g> is replaced by
$g_1^{-e[1]}g$ and the step is repeated for $e[2]$ and so on.

The functions   `DepthOfPcElement'      and  `LeadingExponentOfPcElement'
determine  the depth  and  the leading  exponent   (as an integer)  of an
element w.r.t.\ a pcgs. Both functions can be  viewed as special versions
of the function `ExponentsOfPcElement'.

\>RelativeOrderOfPcElement( <pcgs>, <g> )

Given an element <g> with  `DepthPcElement( <pcgs>, <g>   ) = <d>',  this
function determines the order of the coset $G_{d-1}g$ in the factor group
$G_{d-1}/G_d$. The default method performs  a division step like the  one
described in `ExponentsOfPcElement' above.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes of polycyclic generating systems}\null

\>GroupOfPcgs( <pcgs> )
\>GroupByPcgs( <pcgs> )

\index{polycyclic generating systems!attributes for}%
These two functions return the group generated by the elements of <pcgs>.
The subtle difference is that  `GroupByPcgs' may  construct a new  group,
e.g., a pc group  with new collector, whose  family is different from the
family of <pcgs>.  By contrast,  `GroupOfPcgs'  is supposed to contain  a
group that was there before  <pcgs> was constructed  (and was put it when
<pcgs> was made).

\>RelativeOrders( <pcgs> )

This is simply a list of the `RelativeOrderOfPcElement's.

\>PcSeries( <pcgs> )
\>NormalPcSeries( <pcgs> )
\>NormalPcFirst( <pcgs> )

This function returns the series of subgroups  of `GroupOfPcgs( <pcgs> )'
generated by the end-pieces of  <pcgs> (i.e., `List( [1..Length(<pcgs>)],
<i> -> GroupByGenerators( <pcgs>{[<i>..Length(<pcgs>)]} ) )'). (This is a
subnormal  series.) If possible,  `NormalPcSeries(  <pcgs>  )' returns  a
subseries of `PcSeries(  <pcgs>  )' which  is  even a normal series  with
abelian factors. This need not be possible for every pcgs, although every
solvable group has a pcgs with this property. `NormalPcFirst' returns the
list of positions where the  generating  subsequences for the members  of
`NormalPcSeries' start.
\beginexample
    gap> s4 := Group((1,2,3,4),(1,2));;  SetName( s4, "S4" );
    gap> p := Pcgs( s4 );  PcSeries( p );
    Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,2)(3,4) ])
    [ S4, Group( [ (2,4,3), (1,4)(2,3), (1,2)(3,4) ], ... ), 
      Group( [ (1,4)(2,3), (1,2)(3,4) ], ... ), 
      Group( [ (1,2)(3,4) ], ... ), Group( [  ], ... ) ]
|_
    gap> NormalPcSeries( p );  NormalPcFirst( p );
    [ Group( [ (3,4), (2,4,3), (1,4)(2,3), (1,2)(3,4) ], ... ), 
      Group( [ (2,4,3), (1,4)(2,3), (1,2)(3,4) ], ... ), 
      Group( [ (1,4)(2,3), (1,2)(3,4) ], ... ), Group( [  ], ... ) ]
    [ 1, 2, 3, 5 ]
\endexample
Note the final `5' in the  `NormalPcFirst( <p> )',  it corresponds to the
trivial subgroup at the end of `NormalPcSeries( <p> )'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Induced polycyclic generating systems}\null

\index{polycyclic generating systems!induced}%
Let $G$ be a solvable group with pcgs $(g_1,\ldots,g_n)$ and let $U$ be a
subgroup of  $G$  with  pcgs  $(u_1,\ldots,u_m)$.   We then have   unique
factorizations        $u_i=g_1^{e_{i1}}.\ldots.g_n^{e_{in}}$.     Certain
transformations,    like     $u_i       \mapsto    u_i.u_{i+1}^{e_{i+1}}.
\ldots.u_m^{e_m}$, which  transform the given  pcgs of $U$  into another,
correspond   to   manipulations   of    the    rows   of    the    matrix
$(e_{ij})_{i=1,\ldots,m,\,j=1,\ldots,n}$ which  are   the      elementary
operations of a non-commutative variant  of Gauss' elimination algorithm.
We  can  achieve a pcgs   for $U$ where  the  corresponding matrix has an
echelon form like
%display{tex}
$$ \def\dotfill{\cleaders\hbox{$\mkern1.5mu\.\mkern1.5mu$}\hfill}%
   \left(\vcenter{\halign{&\hbox to1em{\hfil$#$\hfil}\cr%
            \*&\*&\multispan4\dotfill&\*\cr
              &  &\*&\*&\*&\omit\dotfill&\*\cr
              &  &  &  &  &\*&\*\cr
              &  &  &  &  &  &  \cr}}\right) $$
%display{text}
% / * * ....... * \
% |     * * * . * |
% |           * * |
% \               /
%enddisplay
(with zeros in  the lower left  half). Such a  pcgs for $U$ is called  an
*induced pcgs* w.r.t.\ the pcgs of $G$. Working a bit harder, we can also
achieve a pcgs for $U$ for which in addition  the leftmost entry in every
non-zero row in the matrix is~1, and where  the entries in the rows above
such 1's are~0. There is exactly one pcgs for  $U$ with these properties,
it is called the *canonical pcgs* w.r.t.\ the pcgs of $G$.

\>InducedPcgsByGenerators( <pcgs>, <gens> )
\>ParentPcgs( <indpcgs> )

{\GAP} can  calculate induced and  canonical pcgs  and it is particularly
interested in  canonical pcgs of subgroups of  a fixed solvable group <G>
because these pcgs distinguish the subgroups (avoiding membership tests).
The function for induced pcgs  taks two arguments, namely  a pcgs of  the
supergroup <G> and a list of generators for the subgroup.
\beginexample
    gap> G := SymmetricGroup( IsPcGroup, 4 );;  pcgs := Pcgs( G );
    Pcgs([ f1, f2, f3, f4 ])
    gap> u := Subgroup( G, [ G.2^2, G.1*G.2 ] );
    Group( [ f2^2, f1*f2 ], ... )
    gap> InducedPcgsByGenerators( pcgs, GeneratorsOfGroup( u ) );
    Pcgs([ f1*f2, f2^2 ])
\endexample
Here the corresponding matrix is
%display{tex}
$({1\atop} {1\atop2} {0\atop0} {0\atop0})$.
%display{text}
% /1 1 0 0\
% \  2 0 0/.
%enddisplay
The pcgs relative  to which an induced  pcgs  was formed can  be retrived
from the induced pcgs as the value of the attribute `ParentPcgs'.

\>CanonicalPcgsWrtHomePcgs( <U> )
\>HomePcgs( <U> )

The  canonical pcgs  for  a subgroup  $U$ should really  be an attribute,
because it  must be looked   up  whenever $U$   is  compared to   another
subgroup. But since  the canonical pcgs  is also  defined w.r.t.\ another
pcgs, we   need to  be  more  specific.   There  is  a  {\GAP}  attribute
`CanonicalPcgsWrtHomePcgs' and  another attribute `HomePcgs', which holds
the pcgs with respect  to which the  canonical pcgs will be computed.  Of
course this home pcgs should be  the pcgs of <G>, and  hence the same for
all subgroups of <G>. {\GAP} automatically provides a home pcgs for every
newly-constructed solvable group <G>, in such a way that `HomePcgs( <G> )
= Pcgs( <G> )', and every group constructed as  `Subgroup( <G>, \dots\ )'
will inherit this home pcgs.
\beginexample
    gap> HomePcgs( u );
    Pcgs([ f1, f2, f3, f4 ])
    gap> CanonicalPcgsWrtHomePcgs( u );
    Pcgs([ f1, f2 ])
\endexample
Now the corresponding matrix is
%display{tex}
$({1\atop} {0\atop1} {0\atop0} {0\atop0})$.
%display{text}
% /1 0 0 0\
% \  1 0 0/.
%enddisplay

\>CanonicalPcgsWrtFamilyPcgs( <U> )
\>FamilyPcgs( <U> )

For  pc   groups (but *not*   for permutation  groups)   there is another
mechanism  similar  to  `HomePcgs'.      Since  the  elements      of   a
newly-constructed pc group <G> make up a whole new family, it makes sense
to speak of a family pcgs. If <U> is a subgroup of <G>, then `FamilyPcgs(
<U> )' must always equal `FamilyPcgs( <G> ) = HomePcgs( <G> ) = Pcgs( <G>
)', whereas `HomePcgs( <U> )'  could also be  the pcgs of an intermediate
group between <G> and  <U>, of which we  want to regard <U>  as subgroup.
But even if  we can change  our mind about which  group <U> is a subgroup
of, we cannot change anything about the family  the elments of <U> belong
to.  During one {\GAP}  session, this family  will always  be the same pc
group  <G>,  whose collector is  based on  a fixed  pcgs,  namely the one
returned by `FamilyPcgs( <U> )'.

@ WHAT IS THE REAL DIFFERENCE HERE? I CAN CHANGE  NEITHER FAMILY PCGS NOR
HOME PCGS OF U! @

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Modulo polycyclic generating systems}\null

\>`<pcgs> mod <indpcgs>'{modulo}!{for pcgs}
\>NumeratorOfModuloPcgs( <modpcgs> )
\>DenominatorOfModuloPcgs( <modpcgs> )

\index{polycyclic generating systems!modulo}%
Let $G$ be  a solvable group  and $N$ a normal  subgroup. A *modulo pcgs*
for $G/N$ is a pcgs for the factor group  even if the factor group itself
is unknown. To construct such  a thing, you need only  a pcgs for $G$ and
an induced pcgs for  $N$, but *no*  group  (isomorphic to) $G/N$. Such  a
factor group is  expensive to obtain, because it  requires the setup of a
new  collector (even if $G$ and  $N$ were  permutation groups, the factor
would  be  a  pc   group,   see  "NaturalHomomorphismByNormalSubgroup!for
permutation groups"),   although the group operations  could   as well be
performed  in $G$. Comparing elements  in the  factor group then requires
comparison modulo~$N$, and this is where  the modulo pcgs helps: It makes
the functions like  `ExponentsOfPcElement' return exponent lists that are
valid for~$G/N$.
\beginexample
    gap> N := PCore( G, 2 );
    Group( [ f4, f3, f3*f4 ], ... )
    gap> indpcgs := InducedPcgsByGenerators( pcgs,GeneratorsOfGroup(N) );
    Pcgs([ f3, f4 ])
    gap> modpcgs := pcgs mod indpcgs;
    (Pcgs([ f1, f2, f3, f4 ]) mod Pcgs([ f3, f4 ]))
|_
    gap> RelativeOrders( modpcgs );
    [ 2, 3 ]
    gap> DepthPcElement( modpcgs, G.4 );
    3
    gap> ExponentsOfPcElement( modpcgs, G.1*G.3 );
    [ 1, 0 ]
    gap> PcElementByExponents( modpcgs, last );
    f1
\endexample
Observe that in  the  last two commands,   the group elements   are given
resp.\  returned as elements of $G$  although they are meant to represent
elements of~$G/N$. A modulo pcgs can also be constructed from two induced
pcgs, if   both are induced   w.r.t.\ the  same  parent  pcgs. With  this
generalization, <N> need not be  a subgroup of <G>, as  long as <G> still
normalizes~<N>. In this case, the modulo pcgs will be constructed for the
factor group $GN/N \cong G/G\cap N$,  and the group elements contained in
it  will  lie inside  <G>. The same   generalization was made for natural
homomorphisms, see "NaturalHomomorphismByNormalSubgroup".

In  any case, a  modulo pcgs  has two attributes, `NumeratorOfModuloPcgs'
and `DenominatorOfModuloPcgs', which contain the two  pcgs from which the
modulo pcgs was made.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group functions!for solvable groups}

\>ElementaryAbelianSeries( <G> )

The default  function converts   <G> into an   isomorphic pc   group  and
computes the elementary abelian series in this group.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Affine methods!for solvable groups}

Let $U$ and $H$ be subgroups of a group  $G$ such that $H$ normalizes $U$
and   consider the action  of  $H$ on $U$ by   conjugation. If $U$ has an
elementary abelian subgroup $N$ (i.e., a  vector space) that is normal in
both $U$  and   $H$,  then affine  methods  can   be  employed  to deduce
information   about  $H$-conjugacy   in   $U$   from  information   about
$H$-conjugacy in $U/N$. In  particular, one can  define a set $R_H(U)$ of
*canonical  $H$-class  representatives*   for  $U$  such  that,  given  a
representative $hN\in R_H(U/N)$ in the   factor group, the   intersection
$R_H(U)   \cap hN$  is  of the   form $hK$    with $K$  a   set  of orbit
representatives of the affine action on the vector space $N$ given by
$$ C \to {\rm AGL}(N), \quad c \mapsto ( n \mapsto [h,c] n^c ), $$
where $C$ is the full preimage  of $C_{H/N}(hN)$ in $H$. The centralizers
of the representatives in $R_H(U)$  are obtained from the stabilizers  in
this affine action,  so that the procedure  can be  iterated to determine
$R_H(\tilde U)$ in a bigger group $\tilde U$ such that $U=\tilde U/\tilde
N$.

If $N$ is central in  $C$, the set $K$ in  the above step can more easily
be obtained as  a  complement to $[h,C]$ in  $N$  and there is a  similar
shortcut  for    the centralizer. The methods     are  fully described in
\cite{MeckyNeubuser89}.

\>Centralizer( <G>, <U> | <u> )!{for solvable groups}

The centralizer of a  group or an element   is calculated by  the methods
mentioned  above. If only one argument  <U> is given,  the centralizer of
<U> in its parent group is calculated.

\>ConjugacyClasses( [ <H>, ] <U> )!{for solvable groups}

The <H>-conjugacy classes of <U> are calculated by affine methods. If the
first argument <H> is not given, the <U>-classes of <U> are calculated.

\>RationalClasses( <P> )!{for p-groups}

The  shortcut  which the conjugacy  class  calculation  takes for central
normal  subgroups  can be  developed  further so  that   it computes  for
$p$-groups not  only the conjugacy classes but  also the rational classes
(see "Rational classes!for groups"). The method is described in chapter~2
of \cite{Theissen93}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operation functions!for solvable groups}

\>ExternalSet( <G>, <D>, \[, {Pcgs( <G> )}, <oprs> \] \[, <opr> \] )%
  !{for solvable groups}
\)\it and the other operation functions analogously

For a solvable group <G>, the  operation functions use special algorithms
which make use of  a pcgs for  <G>. To activate  these methods, you  must
supply an external set constructed
\beginlist
\item{$\bullet$}
  either via <gens>    and <oprs>, where `<gens>   =  Pcgs( <G>  )'  (for
  example, as `ExternalSet( <G>, <D>, Pcgs( <G> ), <oprs>, <opr> )'), or
\item{$\bullet$}
  or without   <gens> and  <oprs>, where   `IsPcgsComputable(  <G> )'  is
  `true', e.g. if <G> already has a pcgs.
\endlist

\>Enumerator( <xset> )!{for external orbits!for solvable groups}
\>Stabilizer( <G>, <D>, <p> \[, {Pcgs( <G> )}, <oprs> \] \[, <opr> \] )%
  !{for solvable groups}
\>StabilizerOfExternalSet( <xset> )!{for solvable groups}
\>OrbitStabilizer( <G>, \[ <D>, \] <p> \[, {Pcgs( <G> )}, <oprs> \] %
                   \[, <opr> \] )!{for solvable groups}
\>CanonicalRepresentativeOfExternalSet( <xset> )!{for solvable groups}
\>OperatorOfExternalSet( <xset> )!{for solvable groups}

\danger    Since every group permutes   the  orbits of  a normal subgroup
setwise, and since  a solvable group <G> has  a composition series $<G> =
G_0 > \ldots  > G_n=\{1\}$ with cyclic  factors, the <G>-orbit of a point
<p> can  be  constructed by iterated  cyclic   extension. The  orbit $<p>
G_{i-1}$ is   either  equal  to the   orbit   $<p>  G_i$  or it    is the
concatenation  the pairwise   disjoint  mapped orbits   $<p>  G_ig^j$ for
$j=0,\ldots, [G_{i-1}:G_i] - 1$ if  $\langle G_i, g\rangle = G_{i-1}$. In
particular, the orbit of <p> under a  member of the composition series is
always a starting-piece of the entire <G>-orbit.

If the orbit is stable in a cyclic extension step, i.e.,  if $p G_{i-1} =
p G_i$, there is an element $h\in G_i$ such that $<p>.gh^{-1} = <p>$ with
<g> as above.  The elements $gh^{-1}$  collected over all steps  in which
the orbit is stable form a (reversed) pcgs for  the stabilizer of <p>. In
this way  the stabilizer  can  be  computed together  with the  orbit  in
`OrbitStabilizer'. In a similar manner one can construct, given any point
<p> of  the operation   domain, an  element  in <G>  mapping <p>  to  its
canonical representative.

\>RepresentativeOperation( <G>, <D>, <d>, <e> \[, {Pcgs( <G> )}, <oprs> %
                           \] \[, <opr> \] )!{for solvable groups}

If <d> and <e> are in the same orbit of an operation <xset>, the external
orbits `$xorb_d$    := ExternalOrbit( <xset>,  <d>   )'  and `$xorb_e$ :=
ExternalOrbit(      <xset>,     <e>    )'     will     have    the   same
`CanonicalRepresentativeOfExternalSet',        and    hence             a
`RepresentativeOperation'  from   <d> to <e>   can be  calculated  as the
quotient `OperatorOfExternalSet(  $xorb_d$  )    * OperatorOfExternalSet(
$xorb_e$ ) ^ -1'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local Variables:
% mode:               text
% mode:               outline-minor
% outline-regexp:     "\\\\Chapter\\|\\\\Section"
% paragraph-start:    "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% paragraph-separate: "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% fill-column:        73
% End:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
