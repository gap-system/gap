<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %A  grpfp.msk                   GAP documentation            Alexander Hulpke -->
<!-- %%                                                             Volkmar Felsch -->
<!-- %% -->
<!-- %A  @(#)<M>Id: grpfp.msk,v 1.84 2006/03/08 14:50:04 jjm Exp </M> -->
<!-- %% -->
<!-- %Y  (C) 1998 School Math and Comp. Sci., University of St Andrews, Scotland -->
<!-- %Y  Copyright (C) 2002 The GAP Group -->
<!-- %% -->
<Chapter Label="Finitely Presented Groups">
<Heading>Finitely Presented Groups</Heading>

A <E>finitely presented group</E> (in short: FpGroup) is a group generated by
a finite set of <E>abstract generators</E> subject to a finite set of
<E>relations</E> that these generators satisfy.
Every finite group can be represented as a finitely presented group,
though in almost all cases it is computationally much more efficient to work
in another representation (even the regular permutation representation).
<P/>
Finitely presented groups are obtained by factoring a free group by a set
of relators. Their elements know about this presentation and compare
accordingly.
<P/>
So to create a finitely presented group you first have to generate a free
group (see&nbsp;<Ref Func="FreeGroup" Label="for given rank"/> for details).

There are two ways to specify a quotient of the free group: either by giving
a list of relators or by giving a list of equations.

Relators are just words in the generators of the free group. Equations are 
represented as pairs of words in the generators of the free group. 

In either case the generators of the quotient are <E>the images</E> of the free
generators under the canonical homomorphism from the free group onto the quotient.
So for example to create the group
<Display Mode="M">
\langle a, b \mid a^2, b^3, (a b)^5 \rangle
</Display>
you can use the following commands:
<Example><![CDATA[
gap> f := FreeGroup( "a", "b" );;
gap> g := f / [ f.1^2, f.2^3, (f.1*f.2)^5 ];
<fp group on the generators [ a, b ]>
gap> h := f / [ [f.1^2, f.1^0], [f.2^3, f.1^0], [(f.1*f.2)^4, f.2^-1*f.1^-1] ];
<fp group on the generators [ a, b ]>
]]></Example>
<P/>
Note that you cannot call the generators by their names. These names are
not variables, but just display figures. So, if you want to access the
generators by their names, you first have to introduce the respective
variables and to assign the generators to them.
<P/>
<Example><![CDATA[
gap> Unbind(a);
gap> GeneratorsOfGroup( g );
[ a, b ]
gap> a;
Error, Variable: 'a' must have a value
gap> a := g.1;; b := g.2;; # assign variables
gap> GeneratorsOfGroup( g );
[ a, b ]
gap> a in f;
false
gap> a in g;
true
]]></Example>
<P/>
To relieve you of the tedium of typing the above assignments,
<E>when working interactively</E>,
there is the function <Ref Oper="AssignGeneratorVariables"/>.
<P/>
Note that the generators of the free group are different from the
generators of the FpGroup (even though they are displayed by the same
names). That means that words in the generators of the free group are not
elements of the finitely presented group. Vice versa elements of the
FpGroup are not words.
<P/>
<Example><![CDATA[
gap> a*b = b*a;
false
gap> (b^2*a*b)^2 = a^0;
true
]]></Example>
<P/>
Such calculations comparing elements of an FpGroup may run into problems:
There exist finitely
presented groups for which no algorithm exists (it is known that no such
algorithm can exist) that will tell for two arbitrary words in the
generators whether the corresponding elements in the FpGroup are equal.
<P/>
Therefore the methods used by &GAP; to compute in finitely
presented groups may run into warning errors, run out of memory or run
forever. If the FpGroup is (by theory) known to be finite the
algorithms are guaranteed to terminate (if there is sufficient memory
available), but the time needed for the calculation cannot be bounded a
priori. See <Ref Sect="Coset Tables and Coset Enumeration"/> and 
<Ref Sect="Testing Finiteness of Finitely Presented Groups"/>.
<P/>
<Example><![CDATA[
gap> (b^2*a*b)^2;
(b^2*a*b)^2
gap> a^0;
<identity ...>
]]></Example>
<P/>
A consequence of our convention is that elements of finitely presented
groups are not printed in a unique way.
See also <Ref Func="SetReducedMultiplication"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:IsSubgroupFpGroup">
<Heading>IsSubgroupFpGroup and IsFpGroup</Heading>

<#Include Label="IsSubgroupFpGroup">
<#Include Label="IsFpGroup">
<#Include Label="InfoFpGroup">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Creating Finitely Presented Groups">
<Heading>Creating Finitely Presented Groups</Heading>

<ManSection>
<Meth Name="\/" Arg="F, rels"
 Label="for a free group and a list of elements"/>
<Meth Name="\/" Arg="F, eqns"
 Label="for a free group and a list of pairs of elements"/>

<Description>
<Index Subkey="for finitely presented groups">quotient</Index>
creates a finitely presented group given by the presentation
<M>\langle gens \mid <A>rels</A> \rangle</M> or
<M>\langle gens \mid <A>eqns</A> \rangle</M>, respectively
where <M>gens</M> are the free generators of the free group <A>F</A>.
Relations can be entered either as words or
as pairs of words in the generators of <A>F</A>. In the former case
we refer to the words given as <E>relators</E>, in the latter we
refer to the pairs of words as <E>equations</E>.
The two methods can currently not be mixed.
<P/>
The same result is obtained with the infix operator <C>/</C>,
i.e., as <A>F</A> <C>/</C> <A>rels</A>.
<P/>
<Example><![CDATA[
gap> f := FreeGroup( 3 );;
gap> f / [ f.1^4, f.2^3, f.3^5, f.1*f.2*f.3 ];
<fp group on the generators [ f1, f2, f3 ]>
gap> f / [ [ f.1^4, f.1^0 ], [ f.2^3, f.1^0 ], [ f.1, f.2^-1*f.3^-1 ] ];
<fp group on the generators [ f1, f2, f3 ]>
]]></Example>
</Description>
</ManSection>

<#Include Label="FactorGroupFpGroupByRels">
<#Include Label="ParseRelators">
<#Include Label="StringFactorizationWord">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparison of Elements of Finitely Presented Groups">
<Heading>Comparison of Elements of Finitely Presented Groups</Heading>

<ManSection>
<Meth Name="\=" Arg="a, b" Label="for two elements in a f.p. group"/>

<Description>
<Index Subkey="elements of finitely presented groups">equality</Index>
Two elements of a finitely presented group are equal if they are equal in
this group. Nevertheless they may be represented as different words in the
generators. Because of the fundamental problems mentioned in the
introduction to this chapter such a test may take very long and cannot be
guaranteed to finish.
<P/>
The method employed by &GAP; for such an equality test use the underlying
finitely presented group. First (unless this group is known to be infinite)
&GAP; tries to find a faithful permutation representation by a bounded
Todd-Coxeter.
If this fails, a Knuth-Bendix
(see <Ref Sect="Rewriting Systems and the Knuth-Bendix Procedure"/>)
is attempted and the words are compared via their normal form.
<P/>
If only elements in a subgroup are to be tested for equality it thus can be
useful to translate the problem in a new finitely presented group by
rewriting (see <Ref Attr="IsomorphismFpGroup"/>);
<P/>
The equality test of elements underlies many <Q>basic</Q> calculations,
such as the order of an element,
and the same type of problems can arise there.
In some cases, working with rewriting systems can still help to solve the
problem.
The <Package>kbmag</Package> package provides such functionality,
see the package manual for further details.
</Description>
</ManSection>


<ManSection>
<Meth Name="\&lt;" Arg="a, b" Label="for two elements in a f.p. group"/>

<Description>
<Index Subkey="elements of finitely presented groups">smaller</Index>
Compared with equality testing,
problems get even worse when trying to compute a total ordering on the
elements of a finitely presented group. As any ordering that is guaranteed
to be reproducible in different runs of &GAP; or even with different groups
given by syntactically equal presentations would be prohibitively expensive
to implement, the ordering of elements is depending on a method chosen by
&GAP; and not guaranteed to stay the same when repeating the construction
of an FpGroup. The only guarantee given for the <C>&lt;</C>
ordering for such elements is that it will stay the same for one family
during its lifetime.
The attribute <Ref Attr="FpElmComparisonMethod"/> is used to obtain
a comparison function for a family of FpGroup elements.
</Description>
</ManSection>

<#Include Label="FpElmComparisonMethod">
<#Include Label="SetReducedMultiplication">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Preimages in the Free Group">
<Heading>Preimages in the Free Group</Heading>

<#Include Label="FreeGroupOfFpGroup">
<#Include Label="FreeGeneratorsOfFpGroup">
<#Include Label="RelatorsOfFpGroup">


<ManSection>
<Oper Name="UnderlyingElement" Arg='elm' Label="fp group elements"/>

<Description>
Let <A>elm</A> be an element of a group whose elements are represented as
words with further properties.
Then <Ref Oper="UnderlyingElement" Label="fp group elements"/> returns
the word from the free group that is used as a representative for <A>elm</A>.
<P/>
<Example><![CDATA[
gap> w := g.1*g.2;
a*b
gap> IsWord( w );
false
gap> ue := UnderlyingElement( w );
a*b
gap> IsWord( ue );
true
]]></Example>
</Description>
</ManSection>


<#Include Label="ElementOfFpGroup">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Operations for Finitely Presented Groups">
<Heading>Operations for Finitely Presented Groups</Heading>

Finitely presented groups are groups and so all operations for groups should
be applicable to them (though not necessarily efficient methods are
available).
Most methods for finitely presented groups rely on coset enumeration.
See&nbsp;<Ref Sect="Coset Tables and Coset Enumeration"/> for details.
<P/>
The command <Ref Attr="IsomorphismPermGroup"/> can be used to obtain
a faithful permutation representation,
if such a representation of small degree exists.
(Otherwise it might run very long or fail.)
<Example><![CDATA[
gap> f := FreeGroup( "a", "b" );
<free group on the generators [ a, b ]>
gap> g := f / [ f.1^2, f.2^3, (f.1*f.2)^5 ];
<fp group on the generators [ a, b ]>
gap> h := IsomorphismPermGroup( g );
[ a, b ] -> [ (1,2)(3,5), (2,3,4) ]
gap> u:=Subgroup(g,[g.1*g.2]);;rt:=RightTransversal(g,u);
RightTransversal(<fp group of size 60 on the generators 
[ a, b ]>,Group([ a*b ]))
gap> Image(ActionHomomorphism(g,rt,OnRight));
Group([ (1,2)(3,4)(5,7)(6,8)(9,10)(11,12), 
  (1,3,2)(4,5,6)(7,8,9)(10,11,12) ])
]]></Example>


<ManSection>
<Meth Name="PseudoRandom" Arg='F:radius:=l'
 Label="for finitely presented groups"/>

<Description>
The default algorithm for <Ref Oper="PseudoRandom"/>
makes little sense for finitely presented or free groups,
as it produces words that are extremely long.
<P/>
By specifying the option <C>radius</C>,
instead elements are taken as words in the generators of <A>F</A>
in the ball of radius <A>l</A> with equal distribution in the free group.
<P/>
<Log><![CDATA[
gap> PseudoRandom(g:radius:=20);
a^3*b^2*a^-2*b^-1*a*b^-4*a*b^-1*a*b^-4
]]></Log>
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Coset Tables and Coset Enumeration">
<Heading>Coset Tables and Coset Enumeration</Heading>

Coset enumeration (see <Cite Key="Neu82"/> for an explanation) is one of the
fundamental tools for the examination of finitely presented groups.
This section describes &GAP; functions that can be used to invoke a coset
enumeration.
<P/>
Note that in addition to the built-in coset enumerator there is the &GAP;
package <Package>ACE</Package>.
Moreover, &GAP; provides an interactive Todd-Coxeter
in the &GAP; package <Package>ITC</Package>
which is based on the <Package>XGAP</Package> package.

<#Include Label="CosetTable">
<#Include Label="TracedCosetFpGroup">

<ManSection>
<Oper Name="FactorCosetAction" Arg='G, H' Label="for fp groups"/>

<Description>
returns the action of <A>G</A> on the cosets of its subgroup <A>H</A>.
<P/>
<Example><![CDATA[
gap> u := Subgroup( g, [ g.1, g.1^g.2 ] );
Group([ a, b^-1*a*b ])
gap> FactorCosetAction( g, u );
[ a, b ] -> [ (2,4)(5,6), (1,2,3)(4,5,6) ]
]]></Example>
</Description>
</ManSection>


<#Include Label="CosetTableBySubgroup">
<#Include Label="CosetTableFromGensAndRels">
<#Include Label="CosetTableDefaultMaxLimit">
<#Include Label="CosetTableDefaultLimit">
<#Include Label="MostFrequentGeneratorFpGroup">
<#Include Label="IndicesInvolutaryGenerators">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Standardization of coset tables">
<Heading>Standardization of coset tables</Heading>

For any two coset numbers <M>i</M> and <M>j</M> with <M>i &lt; j</M>
the first occurrence of <M>i</M> in a coset table precedes
the first occurrence of <M>j</M> with respect to
the usual row-wise ordering of the table entries. Following the notation of
Charles Sims' book on computation with finitely presented groups
<Cite Key="Sims94"/> we call such a table a <E>standard coset table</E>.
<P/>
The table entries which contain the first occurrences of the coset numbers
<M>i &gt; 1</M> recursively provide for each <M>i</M> a representative of the
corresponding coset in form of a unique word <M>w_i</M> in the generators and
inverse generators of <M>G</M>.
The first coset (which is <M>H</M> itself) can be represented by
the empty word <M>w_1</M>. A coset table is standard if and only
if the words <M>w_1, w_2, \ldots</M> are length-plus-lexicographic ordered
(as defined in <Cite Key="Sims94"/>), for short: <E>lenlex</E>.
<P/>
This standardization of coset tables is
different from that used in &GAP; versions 4.2 and earlier. Before
that, we ignored the columns that correspond to inverse generators and
hence only considered words in the generators of <M>G</M>. We call
this older ordering the <E>semilenlex</E> standard as it 
also applies to the case of semigroups where no inverses of the generators are known.
<P/>
We changed our default from the semilenlex standard to the lenlex
standard to be consistent with <Cite Key="Sims94"/>. However, the
semilenlex standardisation remains available and the convention used
for all implicit standardisations can be selected by setting the value of the global variable
<Ref Var="CosetTableStandard"/> to either <C>"lenlex"</C> or
<C>"semilenlex"</C>.

Independent of the current value of <Ref Var="CosetTableStandard"/>
you can  standardize (or restandardize) a coset table at any
time using <Ref Func="StandardizeTable"/>.

<#Include Label="CosetTableStandard">
<#Include Label="StandardizeTable">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Coset tables for subgroups in the whole group">
<Heading>Coset tables for subgroups in the whole group</Heading>

<#Include Label="CosetTableInWholeGroup">
<#Include Label="SubgroupOfWholeGroupByCosetTable">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Augmented Coset Tables and Rewriting">
<Heading>Augmented Coset Tables and Rewriting</Heading>

<#Include Label="AugmentedCosetTableInWholeGroup">
<#Include Label="AugmentedCosetTableMtc">
<#Include Label="AugmentedCosetTableRrs">
<#Include Label="RewriteWord">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Low Index Subgroups">
<Heading>Low Index Subgroups</Heading>

<#Include Label="LowIndexSubgroupsFpGroupIterator">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Converting Groups to Finitely Presented Groups">
<Heading>Converting Groups to Finitely Presented Groups</Heading>

<#Include Label="IsomorphismFpGroup">
<#Include Label="IsomorphismFpGroupByGenerators">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="New Presentations and Presentations for Subgroups">
<Heading>New Presentations and Presentations for Subgroups</Heading>

<Index Key="IsomorphismFpGroup" Subkey="for subgroups of fp groups">
<C>IsomorphismFpGroup</C></Index>
<Ref Attr="IsomorphismFpGroup"/> is also used to compute
a new finitely presented group that is isomorphic to the given subgroup
of a finitely presented group.
(This is typically the only method to compute with subgroups of a finitely
presented group.)
<P/>
<Example><![CDATA[
gap> f:=FreeGroup(2);;
gap> g:=f/[f.1^2,f.2^3,(f.1*f.2)^5];
<fp group on the generators [ f1, f2 ]>
gap> u:=Subgroup(g,[g.1*g.2]);
Group([ f1*f2 ])
gap> hom:=IsomorphismFpGroup(u);
[ <[ [ 1, 1 ] ]|f2^-1*f1^-1> ] -> [ F1 ]
gap> new:=Range(hom);
<fp group on the generators [ F1 ]>
gap> List(GeneratorsOfGroup(new),i->PreImagesRepresentative(hom,i));
[ <[ [ 1, 1 ] ]|f2^-1*f1^-1> ]
]]></Example>
<P/>
When working with such homomorphisms, some subgroup elements are expressed
as extremely long words in the group generators. Therefore the underlying
words of subgroup
generators stored in the isomorphism (as obtained by
<Ref Attr="MappingGeneratorsImages"/> and displayed when
<Ref Func="View"/>ing the homomorphism)
as well as preimages under the homomorphism are stored in the form of
straight line program elements
(see&nbsp;<Ref Sect="Straight Line Program Elements"/>). These will
behave like ordinary words and no extra treatment should be necessary.
<P/>
<Example><![CDATA[
gap> r:=Range(hom).1^10;
F1^10
gap> p:=PreImagesRepresentative(hom,r);
<[ [ 1, 10 ] ]|(f2^-1*f1^-1)^10>
]]></Example>

If desired, it also is possible to convert these underlying words using
<Ref Func="EvalStraightLineProgElm"/>:

<Example><![CDATA[
gap> r:=EvalStraightLineProgElm(UnderlyingElement(p));
(f2^-1*f1^-1)^10
gap> p:=ElementOfFpGroup(FamilyObj(p),r);
(f2^-1*f1^-1)^10
]]></Example>
<P/>
(If you are only interested in a finitely presented group isomorphic to
the given subgroup but not in the isomorphism,
you may also use the functions
<Ref Func="PresentationViaCosetTable"/> and <Ref Func="FpGroupPresentation"/>
(see <Ref Sect="Creating Presentations"/>).)
<P/>
Homomorphisms can also be used to obtain an isomorphic finitely presented
group with a (hopefully) simpler presentation.
<P/>
<#Include Label="IsomorphismSimplifiedFpGroup">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Preimages under Homomorphisms from an FpGroup">
<Heading>Preimages under Homomorphisms from an FpGroup</Heading>

For some subgroups of a finitely presented group the number of
subgroup generators increases with the index of the subgroup. However often
these generators are not needed at all for further calculations, but what is
needed is the action of the cosets of the subgroup. This gives the image of
the subgroup in a finite quotient and this finite quotient can be used to
calculate normalizers, closures, intersections and so
forth&nbsp;<Cite Key="HulpkeQuot"/>.
<P/>
The same applies for subgroups that are obtained as preimages under
homomorphisms.

<#Include Label="SubgroupOfWholeGroupByQuotientSubgroup">
<#Include Label="IsSubgroupOfWholeGroupByQuotientRep">
<#Include Label="AsSubgroupOfWholeGroupByQuotient">
<#Include Label="DefiningQuotientHomomorphism">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Quotient Methods">
<Heading>Quotient Methods</Heading>

An important class of algorithms for finitely presented groups are the
<E>quotient algorithms</E> which compute quotient groups of a given finitely
presented group. There are algorithms for epimorphisms onto abelian groups,
<M>p</M>-groups and solvable groups.
(The <Q>low index</Q> algorithm
&ndash;<Ref Oper="LowIndexSubgroupsFpGroup"/>&ndash;
can be considered as well as an algorithm that produces permutation group
quotients.)
<P/>
<Ref Attr="MaximalAbelianQuotient"/>,
as defined for general groups, returns the largest abelian
quotient of the given group.

<Example><![CDATA[
gap> f:=FreeGroup(2);;fp:=f/[f.1^6,f.2^6,(f.1*f.2)^12];
<fp group on the generators [ f1, f2 ]>
gap> hom:=MaximalAbelianQuotient(fp);
[ f1, f2 ] -> [ f1, f3 ]
gap> Size(Image(hom));
36
]]></Example>

<#Include Label="PQuotient">
<#Include Label="EpimorphismQuotientSystem">
<#Include Label="EpimorphismPGroup">
<#Include Label="EpimorphismNilpotentQuotient">
<#Include Label="SolvableQuotient">
<#Include Label="EpimorphismSolvableQuotient">
<#Include Label="LargerQuotientBySubgroupAbelianization">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Abelian Invariants for Subgroups">
<Heading>Abelian Invariants for Subgroups</Heading>

Using variations of coset enumeration it is possible to compute the abelian
invariants of a subgroup of a finitely presented group without computing a
complete presentation for the subgroup in the first place.
Typically, the operation <Ref Attr="AbelianInvariants"/> when called for
subgroups should automatically take care of this,
but in case you want to have further control about the methods used,
the following operations might be of use.

<#Include Label="AbelianInvariantsSubgroupFpGroup">
<#Include Label="AbelianInvariantsSubgroupFpGroupMtc">
<#Include Label="AbelianInvariantsSubgroupFpGroupRrs">
<#Include Label="AbelianInvariantsNormalClosureFpGroup">
<#Include Label="AbelianInvariantsNormalClosureFpGroupRrs">

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Testing Finiteness of Finitely Presented Groups">
<Heading>Testing Finiteness of Finitely Presented Groups</Heading>

As a consequence of the algorithmic insolvabilities mentioned in the
introduction to this chapter, there cannot be a general method that will
test whether a given finitely presented group is actually finite. 
<P/>
Therefore testing the finiteness of a finitely presented group
can be problematic.
What &GAP; actually does upon a call of <Ref Prop="IsFinite"/>
(or if it is &ndash;probably implicitly&ndash; asked for a faithful
permutation representation)
is to test whether it can find (via coset enumeration) a
cyclic subgroup of finite index. If it can, it rewrites the presentation to
this subgroup. Since the subgroup is cyclic, its size can be checked easily
from the resulting presentation, the size of the whole group is the product
of the index and the subgroup size.  Since however no bound for the index of
such a subgroup (if any exist) is known, such a test might continue
unsuccessfully until memory is exhausted.
<P/>
On the other hand, a couple of methods exist, that might prove that a group
is infinite. Again, none is guaranteed to work in every case:
<P/>
The first method is to find (for example via the low index algorithm,
see&nbsp;<Ref Oper="LowIndexSubgroupsFpGroup"/>) a subgroup <M>U</M>
such that <M>[U:U']</M> is infinite.
If <M>U</M> has finite index, this can be checked by
<Ref Prop="IsInfiniteAbelianizationGroup"/>.
<P/>
Note that this test has been done traditionally by checking the
<Ref Attr="AbelianInvariants"/>
(see section&nbsp;<Ref Sect="Abelian Invariants for Subgroups"/>)
of <M>U</M>,
<Ref Prop="IsInfiniteAbelianizationGroup"/> does a
similar calculation but stops as soon as it is known whether <M>0</M> is an
invariant without computing the actual values. This can be notably faster.
<P/>
Another method is based on <M>p</M>-group quotients,
see <Ref Func="NewmanInfinityCriterion"/>.

<#Include Label="IsInfiniteAbelianizationGroup:grp">
<#Include Label="NewmanInfinityCriterion">

</Section>
</Chapter>

