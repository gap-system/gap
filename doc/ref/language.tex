%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%A language.tex            GAP documentation                Martin Schoenert
%
%A @(#)$Id$
%
%Y Copyright 1990-1992, Lehrstuhl D fuer Mathematik, RWTH Aachen, Germany
%
%% This file describes the {\GAP} programming language.
%
%
\Chapter{The Programming Language}

This chapter describes the {\GAP} programming language.  It should allow
you in principle to predict the result of each and every input. In order
to know what we are talking about, we first have to look more closely at
the process of interpretation and the various representations of data
involved.

First we have the input to {\GAP}, given as a string of characters. How
those characters enter {\GAP} is operating system dependent, e.g., they
might be entered at a terminal, pasted with a mouse into a window, or
read from a file. The mechanism does not matter. This representation of
expressions by characters is called the *external representation* of the
expression. Every expression has at least one external representation
that can be entered to get exactly this expression.

The input, i.e., the external representation, is transformed in a process
called *reading* to an internal representation.  At this point the input
is analyzed and inputs  that are not legal external representations,
according to the rules given below, are rejected as errors. Those rules
are usually called the *syntax* of a programming language.

The internal representation created by reading is called either an
*expression* or a *statement*.  Later we will distinguish between those
two terms, however now we will use them interchangeably. The exact form
of the internal representation does not matter. It could be a string of
characters equal to the external representation, in which case the
reading would only need to check for errors. It could be a series of
machine instructions for the processor on which {\GAP} is running, in
which case the reading would more appropriately be called compilation.
It is in fact a tree--like structure.

After the input has been read it is again transformed in a process called
*evaluation* or *execution*. Later we will distinguish between those two
terms too, but for the moment we will use them interchangeably. The name
hints at the nature of this process, it replaces an expression with the
value of the expression. This works recursively, i.e., to evaluate an
expression first the subexpressions are evaluated and then the value of
the expression is computed from those values according to rules given below.
Those rules are usually called the *semantics* of a programming language.

The result of the evaluation is, not surprisingly, called a *value*. The
set of values  is of course a  much smaller set than the  set of
expressions; for every value there may be several expressions that will
evaluate to  this value. Again the form in which such a  value is
represented internally does not  matter. It is  in fact a tree--like
structure again.

The last process is called *printing*. It takes the value produced by
the evaluation and creates an external representation, i.e., a string of
characters again. What you do with this external representation is up to
you. You can look at it, paste it with the mouse into another window, or
write it to a file.

Lets look at an example to make this more clear. Suppose you type in the
following string of 8 characters

\begintt
1 + 2 * 3;
\endtt

{\GAP} takes  this external representation  and creates  a tree like
internal representation, which we can picture as follows

\begintt
  +
 / \
1   *
   / \
  2   3
\endtt

This expression is then evaluated. To do this {\GAP} first evaluates the
right subexpression `2*3'.  Again, to do this {\GAP} first evaluates its
subexpressions 2 and 3. However they are so simple that they are their
own value, we say that they are self--evaluating. After this has been
done, the rule for `*' tells us that the value is the product of the
values of the two subexpressions, which in this case is clearly 6.
Combining this with the value of the left operand of the `+', which is
self--evaluating, too, gives us the value of the whole expression 7. This
is then printed, i.e., converted into the external representation
consisting of the single character `7'.

In this fashion we can predict the result of every input when we know the
syntactic rules that govern the process of reading and the semantic rules
that tell us for every expression how its value is computed in terms of
the values of the subexpressions. The syntactic rules are given in
sections "Lexical Structure",  "Symbols", "Whitespaces", "Keywords",
"Identifiers", and "The Syntax in BNF", the semantic rules are given in
sections "Expressions", "Variables", "Function Calls", "Comparisons",
"Infix Operators",  "Statements", "Assignments", "Procedure Calls", "If",
"While", "Repeat", "For", "Functions", and the chapters describing the
individual data types.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Lexical Structure}

The input of {\GAP} consists of sequences of the following characters.

Digits, uppercase and lowercase letters, <space>, <tab>, <newline>, and
the special characters

\begintt
"    `    (    )    *    +    ,    _
.    /    :    ;    <    =    >    ~
[    ]    ^    _    {    }    &
\endtt

Other characters will be signalled as illegal.  Inside strings and
comments the full character set supported by the computer is allowed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Symbols}

The process of reading, i.e., of assembling the input into expressions,
has a subprocess, called *scanning*, that assembles the characters into
symbols.  A *symbol* is a sequence of characters that form a lexical
unit. The set of symbols consists of keywords, identifiers, strings,
integers, and operator and delimiter symbols.

A keyword is a reserved word consisting entirely of lowercase letters
(see "Keywords"). An identifier is a sequence of letters and digits that
contains at least one letter and is not a keyword (see "Identifiers").
An integer is a sequence of digits (see "Integers").  A string is a
sequence of  arbitrary characters  enclosed in double quotes (see
"Strings and Characters").

Operator and delimiter symbols are

\begintt
+    -    *    /    ^    ~
=    <>   <    <=   >    >=
:=   .    ..   ->   ,    ;
[    ]    {    }    (    )
\endtt

Note that during the process of scanning also all whitespace is removed
(see "Whitespaces").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Whitespaces}
\index{space}
\index{blank}\index{tabulator}\index{newline}\index{comments}

The  characters <space>, <tab>,  <newline>, and  <return> are called
*whitespace characters*.  Whitespace is used  as necessary to separate
lexical symbols, such as integers, identifiers, or keywords. For example
`Thorondor' is a single identifier, while `Th or ondor' is the keyword
`or' between the two identifiers `Th' and `ondor'. Whitespace may occur
between any two symbols, but not within a symbol. Two or more adjacent
whitespaces are equivalent to a single whitespace. Apart from the role
as separator of symbols, whitespaces are  otherwise insignificant.
Whitespaces may also occur inside a string, where they are significant.
Whitespaces should also be used freely for improved readability.

A *comment* starts with the  character `\#', which is sometimes called
sharp or hatch, and continues to the end of the line on which the comment
character appears. The whole comment, including `\#' and the <newline>
character is treated as a single  whitespace. Inside a string, the
comment character `\#' looses its role and is just an ordinary character.

For example, the following statement

\begintt
if i<0 then a:=-i;else a:=i;fi;
\endtt

is equivalent to

\begintt
if i < 0 then   # if i is negative
  a := -i;      #   take its inverse
else            # otherwise
  a := i;       #   take itself
fi;
\endtt

(which by the way shows that it is possible to write superfluous
comments). However the first statement is not equivalent to

\begintt
ifi<0thena:=-i;elsea:=i;fi;
\endtt

since the keyword `if' must be separated from the identifier `i' by a
whitespace, and similarly `then' and `a', and `else' and `a' must be
separated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Keywords}

*Keywords* are reserved words that are used to denote special operations
or are part of statements. They must not be used as identifiers. The
keywords are

\begintt
and     do       elif   else    end     fi
for     function if     in      local   mod
not     od       or     repeat  return  then
until   while    quit
\endtt

Note that all keywords are written in lowercase. For example only `else'
is  a keyword; `Else', `eLsE', `ELSE'  and  so forth are ordinary
identifiers. Keywords must not contain whitespace, for example `el if'
is not the same as `elif'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Identifiers}

An identifier is used to refer to  a variable (see "Variables").  An
identifier consists of letters, digits, and underscores `\_', and must
contain at least one letter or underscore.  An identifier is terminated
by the first character not in this class. Examples of valid identifiers
are

\begintt
a           foo         aLongIdentifier
hello       Hello       HELLO
x100        100x       _100
some_people_prefer_underscores_to_separate_words
WePreferMixedCaseToSeparateWords
\endtt

Note that case is significant, so the three identifiers in the second
line are distinguished.

The backslash `\\' can be used to include other characters in identifiers;
a backslash followed by a character is equivalent  to the character,
except that this escape sequence is considered to be an ordinary letter.
For example
\begintt
G\(2\,5\)
\endtt
is an identifier, not a call to a function `G'.

An identifier that starts with a backslash is never a keyword, so for
example `\\*' and `\\mod' are identifiers.

The length of identifiers is not limited,  however only the first 1023
characters are significant. The escape sequence `\\'<newline> is ignored,
making it possible to split long identifiers over multiple lines.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Expressions}
\index{evaluation}

An *expression* is a construct that evaluates to a value.  Syntactic
constructs that are executed to produce a side effect and return no value
are called *statements* (see "Statements"). Expressions appear as right
hand sides of assignments (see "Assignments"), as actual arguments in
function calls (see "Function Calls"), and in statements.

Note that an expression is not the same as a value. For example `1 + 11'
is an  expression, whose value is  the  integer 12.  The external
representation of this integer is the character sequence `12', i.e., this
sequence is output if the integer is printed. This sequence is another
expression whose value is the integer 12.  The process of finding the
value of an expression is done by the interpreter and is called the
*evaluation* of the expression.

Variables, function calls, and integer, permutation, string, function,
list, and record literals (see "Variables", "Function Calls", "Integers",
"Permutations",  "Strings  and  Characters",  "Functions",  "Lists",
"Records"), are the simplest cases of expressions.

Expressions, for example the simple expressions mentioned above, can be
combined with the operators to form more complex expressions. Of course
those expressions can then be combined further with the operators to form
even more complex expressions. The *operators* fall into three classes.
The *comparisons* are `=', `\<', `\<>', `\<=', `>',  `>=', and `in' (see
"Comparisons" and "In"). The *arithmetic operators* are `+', `-', `*',
`/', `mod', and `^'  (see "Infix Operators").  The *logical operators* are
`not', `and', and `or' (see "Operations for Booleans").

\beginexample
gap> 2 * 2;  # a very simple expression with value
4
gap> 2 * 2 + 9 = Fibonacci(7) and Fibonacci(13) in Primes;
true      # a more complex expression
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Variables}
\index{scope}\index{bound}

A *variable* is a location in a {\GAP} program that points to a value.
We say the variable is *bound* to this value. If a variable is evaluated
it evaluates to this value.

Initially an ordinary variable is not bound to any value. The variable
can be bound to a value by *assigning* this value to the variable (see
"Assignments"). Because of this we sometimes say that a variable that is
not bound to any value has no assigned value. Assignment is in fact the
only way by which a variable, which is not an argument of a function, can
be bound to a value. After a variable has been bound to a  value an
assignment can also be used to bind the variable to another value.

A special class of variables are *arguments* of functions. They behave
similarly to other variables, except they are bound to the value of the
actual arguments upon a function call (see "Function Calls").

Each variable has a name that is also called its *identifier*. This is
because in a given scope an identifier identifies a unique variable (see
"Identifiers"). A *scope* is a lexical part of a program text. There is
the global scope that encloses the entire program text, and there are
local scopes that range from the `function' keyword, denoting the
beginning of a function definition, to the corresponding `end' keyword.
A local scope introduces new variables, whose identifiers are given in
the formal argument list and the `local' declaration of the function (see
"Functions"). Usage of an identifier in a program text refers to the
variable in the innermost scope that has this identifier as its name.
Because this mapping from identifiers to variables is done when the
program is read, not when it is executed, {\GAP} is said to have *lexical
scoping*.  The following example shows how one identifier refers to
different variables at different points in the program text.

\begintt
 g := 0;      # global variable g
 x := function ( a, b, c )
  local  y;
  g := c;     # c refers to argument c of function x
  y := function ( y )
    local d, e, f;
    d := y;   # y refers to argument y of function y
    e := b;   # b refers to argument b of function x
    f := g;   # g refers to global variable g
    return d + e + f;
  end;
  return y( a ); # y refers to local y of function x
end;
\endtt

It is important to note that the concept of a variable in {\GAP} is quite
different from the concept of a variable in programming languages like
PASCAL.

In those languages a variable denotes a block of memory. The
value of the variable is stored in this block. So in those languages two
variables can have the same value, but they can never have identical
values, because they denote different blocks of memory.  Note that
PASCAL has the concept of a reference argument. It seems as if such an
argument and the variable used in the actual function call have the same
value, since changing the argument's value also changes the value of the
variable used in the actual function call.  But this is not so; the
reference argument is actually a pointer to the variable used in the
actual function call, and it is the compiler that inserts enough magic to
make the pointer invisible.  In order for this to work the compiler
needs enough information to compute the amount of memory needed for each
variable in a program, which is readily available in the declarations
PASCAL requires for every variable.

In {\GAP} on the other hand each variable justs points to a value,
and different variables can share the same value.

\>Unbind(<ident>)

deletes the identifier <ident>. If there is no other variable pointing to
the same value as <ident> was, this value will be removed by the next
garbage collection. Therefore `Unbind' can be used to get rid of unwanted
large objects.

For records and lists `Unbind' can be used to delete components or entries.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Function Calls}

\>`<function-var>()'{function call}
\>`<function-var>( <arg-expr> {, <arg-expr>} )'{function call with arguments}

The function call has the effect of calling the function <function-var>.
The precise semantics are as follows.

First {\GAP} evaluates the <function-var>. Usually <function-var> is a
variable, and {\GAP} does nothing more than taking the value of this
variable.  It is allowed though that <function-var> is a more complex
expression, namely it can for example be a selection of a list element
`<list-var>[<int-expr>]', or  a  selection of  a  record component
`<record-var>.<ident>'. In any case {\GAP} tests whether the value is a
function. If it is not, {\GAP} signals an error.

Next {\GAP} checks that the number of actual arguments <arg-expr>s agrees
with the number of formal arguments as given in the function definition.
If they do not agree {\GAP} signals an error. An exception is the case
when there is exactly one formal argument with the name `arg', in which
case any number of actual arguments is allowed.

Now {\GAP} allocates for each formal argument and for each formal local a
new variable. Remember that a variable is a location in a {\GAP} program
that points to a value. Thus for  each formal argument and for each
formal local such a location is allocated.

Next the arguments <arg-expr>s are evaluated, and the values are assigned
to the newly created variables corresponding to the formal arguments. Of
course the first value is assigned to the new variable corresponding to
the first formal argument, the second  value  is assigned to the new
variable corresponding  to  the second  formal argument, and  so on.
However, {\GAP} does not make any guarantee about the order in which the
arguments are evaluated. They might be evaluated left to right, right to
left, or in any other order, but each argument is evaluated once. An
exception again occurs if the function has only one formal argument with
the name `arg'. In this case the values of all the actual arguments are
stored in  a list and this  list is assigned to the  new variable
corresponding to the formal argument `arg'.

The new variables corresponding to the formal locals are initially not
bound to any  value.  So trying  to evaluate those  variables before
something has been assigned to them will signal an error.

Now the body of the function, which is a statement, is executed. If the
identifier of one of the formal arguments or formal locals appears in the
body of the function it refers to the new variable that was allocated for
this formal argument or formal local, and evaluates to the value of this
variable.

If during the execution of the body of the function a `return' statement
with an expression (see "Return") is executed, execution of the body is
terminated and the value of the function call is the value of the
expression of the `return'. If during the execution of the body a
`return' statement without an expression is executed, execution of the
body is terminated and the function call does not produce a value, in
which case we call this call a procedure call (see "Procedure Calls").
If the execution of the body completes without execution of a `return'
statement, the function call again produces no value, and again we talk
about a procedure call.

\beginexample
gap> Fibonacci( 11 );
  # a call to the function `Fibonacci' with actual argument `11'
89
\endexample

\begintt
gap> RightCosets( G, Intersection( U, V ) );;
  # a call to the operation `RightCosets'
  # where the second actual argument is another function call
\endtt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes}

Some single-argument operations are declared as attributes. Attributes not
only compute a result, but also store the result in the object. These stored
results can not be changed. A second call to the attribute will return the
*same* object. (Therefore all attribute values are immutable.) The cost of
such a lookup call is usually negligible.
Properties are a special form of attributes that have the value `true' or
`false'.
In this manual attributes and properties can be recognized by an `A' or `P'
to the right of the operation definition.

\index{setter}\index{tester}
For every attribute two further operations, the *attribute setter* and the
*attribute tester* are defined. If the attribute is called `Name' they are
called `SetName' and `HasName' respectively. 

\>HasName(<obj>) P

returns `true' or `false' depending on whether the attribute `Name' is know
for <orbj>.

\>SetName(<obj>,<val>) O

Stores <val> as the attribute `Name' of <obj>. If already another attribute
value is stored, the command is ignored.

\beginexample
gap> g:=Group((1,2,3,4),(1,2));;Size(g);
24
gap> HasSize(g);
true
gap> SetSize(g,99);
gap> Size(g);
24
\endexample

Note, however, that it is impossible to get rid of a stored attribute
value because the system may have drawn conclusions from the (wrong)
value, and just removing the value would not help.

\>AttributeValueNotSet(<attr>,<obj>) F

If the attribute <attr> is stored for <obj> this function simply returns the
value of this attribute. If the value is not stored, it computes the value
of <attr>(<obj>) and returns the value *without storing it* in <obj>. this
can be useful when ``large'' attributes (such as element lists)
are needed only once and should not be stored in the object.

\beginexample
gap> HasAsList(g);
false
gap> AttributeValueNotSet(AsList,g);
[ (), (1,2)(3,4), (1,4)(2,3), (1,3)(2,4), (2,3,4), (1,2,4), (1,4,3),
(1,3,2), 
  (2,4,3), (1,2,3), (1,4,2), (1,3,4), (3,4), (1,2), (1,4,2,3), (1,3,2,4), 
  (2,3), (1,2,4,3), (1,4), (1,3,4,2), (2,4), (1,2,3,4), (1,4,3,2), (1,3) ]
gap> HasAsList(g);
false
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comparisons}

\>`<left-expr> =  <right-expr>'{equality test}
\>`<left-expr> \<> <right-expr>'{inequality test}

The operator `=' tests for equality of its two operands and evaluates to
`true' if they are equal and to `false' otherwise. Likewise `\<>' tests
for inequality of its two operands. Note that any two objects can be
compared, i.e., `=' and `\<>' will never signal an error. For each type
of objects the definition of equality is given in the respective chapter.
Objects of different types are never equal, i.e., `=' evaluates in this
case to `false', and `\<>' evaluates to `true'.

\>`<left-expr> \< <right-expr>'{smaller test}
\>`<left-expr> >  <right-expr>'{larger test}
\>`<left-expr> \<= <right-expr>'{smaller or equal}
\>`<left-expr> >= <right-expr>'{larger or equal}

`\<' denotes less than, `\<=' less than or equal, `>' greater than, and
`>=' greater than or equal of its two operands. For each type of objects
the definition of the ordering is given in the respective chapter.
Only for the following types, an ordering of objects of different types
is supported.
Rationals are smallest, next are cyclotomics,
followed by finite field elements, permutations, words,
words in solvable groups, boolean values, functions,
lists, and records are largest.

Comparison operators, which includes the operator `in' (see "In") are not
associative, i.e., it is not allowed to write `<a> = <b> \<> <c> = <d>',
you must use `(<a> = <b>) \<> (<c> = <d>)' instead. The comparison
operators have  higher precedence  than  the logical operators (see
"Operations for Booleans"), but lower precedence than the arithmetic
operators (see "Infix Operators"). Thus, for example, `<a> * <b> = <c> and
<d>' is interpreted, `((<a> * <b>) = <c>) and <d>)'.

\beginexample
gap> 2 * 2 + 9 = Fibonacci(7);  # a comparison where the left
true               # operand is an expression
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Infix Operators}

\index{precedence}\index{associativity}

\>`+ <right-expr>'{positive number}
\>`- <right-expr>'{negative number}
\>`<left-expr> + <right-expr>'{addition}
\>`<left-expr> - <right-expr>'{subtraction}
\>`<left-expr> * <right-expr>'{multiplication}
\>`<left-expr> / <right-expr>'{division}
\>`<left-expr> mod <right-expr>'{modulo}
\>`<left-expr> ^ <right-expr>'{power}

The arithmetic operators are `+', `-', `*', `/', `mod', and `^'.
The meanings (semantic) of those operators generally depend on the types
of the operands involved, and they are defined in the various chapters
describing the types. However basically the meanings are as follows.

`+' denotes the addition, and `-' the subtraction of ring and field
elements.  `*' is the multiplication of group elements, `/' is the
multiplication of the left operand with the inverse of the right operand.
`mod' is only defined for integers and rationals and denotes the modulo
operation. `+' and `-' can also be used as unary operations. The unary
`+' is ignored and unary `-' is equivalent to multiplication by -1. `^'
denotes powering of a group element if the right operand is an integer,
and is also used to denote operation if the right operand is a group
element.

The *precedence* of those operators is as follows. The powering operator
`^' has the highest precedence, followed by the unary operators `+' and
`-', which are followed by the multiplicative operators `*', `/', and
`mod', and the additive binary operators `+' and `-' have the lowest
precedence.  That means that the expression `-2 ^ -2 * 3 + 1' is
interpreted as `(-(2 ^ (-2)) * 3) + 1'. If in doubt use parentheses
to clarify your intention.

The *associativity* of the arithmetic operators is as follows.
`^' is not associative, i.e., it is illegal to write `2^3^4',
use parentheses to clarify whether you mean `(2^3) ^ 4' or `2 ^ (3^4)'.
The unary
operators `+' and `-' are right associative, because they are written to
the left of their operands. `*', `/', `mod', `+', and `-' are all left
associative, i.e., `1-2-3' is interpreted as `(1-2)-3' not as `1-(2-3)'.
Again, if in doubt use parentheses to clarify your intentions.

The arithmetic operators have higher precedence than the comparison
operators (see "Comparisons" and "In") and the logical operators (see
"Operations for Booleans"). Thus, for example, `<a> * <b> = <c> and
<d>' is interpreted, `((<a> * <b>) = <c>) and <d>'.

\beginexample
gap> 2 * 2 + 9;  # a very simple arithmetic expression
13
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Statements}
\index{execution}

Assignments (see "Assignments"), Procedure calls (see "Procedure Calls"),
`if' statements (see "If"), `while' (see "While"), `repeat'  (see
"Repeat") and `for' loops (see "For"), and the `return' statement (see
"Return") are called statements. They can be entered interactively or be
part of a function definition. Every statement must be terminated by a
semicolon.

Statements, unlike expressions, have no value. They are executed only to
produce an effect. For example an assignment has the effect of assigning
a  value to a variable, a `for' loop  has the effect of executing a
statement sequence for all elements in a list and so on. We will talk
about *evaluation* of expressions but about *execution* of statements to
emphasize this difference.

It is possible to use expressions as statements. However this does cause
a warning.

\begintt
gap> if i <> 0 then k = 16/i; fi;
Syntax error: := expected
if i <> 0 then k = 16/i; fi;
                 ^
\endtt

As you can see from the example this is useful for those users who are
used to languages where `=' instead of `:=' denotes assignment.

A sequence of one or more statements is a statement sequence, and may
occur everywhere instead of a single statement. There is nothing like
PASCAL's BEGIN-END, instead each construct is terminated by a keyword.
The most simple statement sequence is a single semicolon, which can be
used as an empty statement sequence.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Assignments}

\>`<var> := <expr>;'{assignment!variable}

The *assignment* has the effect of assigning the value of the expressions
<expr> to the variable <var>.

The variable <var> may be an ordinary variable (see "Variables"), a list
element selection `<list-var>[<int-expr>]' (see "List Assignment") or a
record component  selection  `<record-var>.<ident>'  (see  "Record
Assignment"). Since a list element or a record component may itself be a
list or a record the left hand side of an assignment may be arbitrarily
complex.

Note that variables do not have a type. Thus any value may be assigned
to any variable.  For example a variable with an integer value may be
assigned a permutation or a list or anything else.

If the expression <expr> is a function call then this function must
return a value.  If the function does not return a value an error is
signalled and you enter a break loop (see "Break Loops").  As usual you
can leave the break  loop  with `quit;'.  If you enter  `return
<return-expr>;' the value of the expression <return-expr> is assigned to
the variable, and execution continues after the assignment.

\beginexample
gap> S6 := rec( size := 720 );; S6;
rec(
 size := 720 )
gap> S6.generators := [ (1,2), (1,2,3,4,5) ];; S6;
rec(
 size := 720,
 generators := [ (1,2), (1,2,3,4,5) ] )
gap> S6.generators[2] := (1,2,3,4,5,6);; S6;
rec(
 size := 720,
 generators := [ (1,2), (1,2,3,4,5,6) ] )
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Procedure Calls}

\>`<procedure-var>();'{procedure call}
\>`<procedure-var>( <arg-expr> {,<arg-expr>} );'{procedure call with arguments}

The  procedure call  has  the  effect  of calling  the procedure
<procedure-var>.  A procedure call is done exactly like a function call
(see "Function Calls"). The distinction between functions and procedures
is only for the sake of the discussion, {\GAP} does not distinguish
between them.

A *function* does return a value but does not produce a side effect. As
a convention the name of a function is a noun, denoting what the function
returns, e.g., `Length', `Concatenation' and `Order'.

A *procedure* is a function that does not return a value but produces
some  effect. Procedures are called  only for  this effect. As  a
convention the name of a procedure is a verb, denoting what the procedure
does, e.g., `Print', `Append' and `Sort'.

\begintt
gap> Read( "myfile.g" );   # a call to the procedure Read
gap> l := [ 1, 2 ];;
gap> Append( l, [3,4,5] );  # a call to the procedure Append
\endtt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{If}

\index{fi}\index{then}\index{else}\index{elif}

\>`if <bool-expr1> then <statements1> { elif <bool-expr2> then <statements2> }[ else <statements3> ] fi;'{if statement}

The `if' statement allows one to execute statements depending on the
value of some boolean expression. The execution is done as follows.

First the expression <bool-expr1> following the `if' is evaluated. If it
evaluates to `true' the statement sequence <statements1> after the first
`then' is executed, and the execution of the `if' statement is complete.

Otherwise the expressions <bool-expr2> following the `elif' are evaluated
in turn. There may be any number of `elif' parts, possibly none at all.
As soon as an expression evaluates to `true' the corresponding statement
sequence <statements2> is executed and execution of the `if' statement is
complete.

If the `if' expression and all, if any, `elif' expressions evaluate to
`false' and there is an `else' part, which is optional, its statement
sequence <statements3> is executed  and the  execution of  the `if'
statement is complete. If there is no `else' part the `if' statement is
complete without executing any statement sequence.

Since the `if' statement is terminated by the `fi' keyword there is no
question where an `else' part belongs, i.e., {\GAP} has no dangling else.

In `if <expr1> then if <expr2> then <stats1> else <stats2> fi; fi;'

the `else' part belongs to the second  `if' statement, whereas in

`if <expr1> then if <expr2> then <stats1> fi; else <stats2> fi;'

the `else' part belongs to the first `if' statement.

Since an if statement is not an expression it is not possible to write

\beginexample
abs := if x > 0 then x; else -x; fi;
\endexample

which would, even if legal syntax, be  meaningless, since the `if'
statement does not produce a value that could be assigned to `abs'.

If one of the expressions <bool-expr1>, <bool-expr2> is evaluated
and its value is neither `true' nor `false' an error is signalled
and a break loop (see "Break Loops") is entered. As usual you
can leave  the break loop with `quit;'.  If you enter `return true;',
execution of the `if' statement continues as if the expression whose
evaluation  failed had evaluated to `true'.   Likewise, if you enter
`return false;', execution of the `if' statement continues as if the
expression whose evaluation failed had evaluated to `false'.

\beginexample
gap> i := 10;;
gap> if 0 < i then
>    s := 1;
>  elif i < 0 then
>    s := -1;
>  else
>    s := 0;
>  fi;
gap> s;
1    # the sign of i
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{While}

\index{loop!while}

\>`while <bool-expr> do <statements> od;'{while loop}

The `while' loop executes the statement sequence <statements> while the
condition <bool-expr> evaluates to `true'.

First <bool-expr> is evaluated. If it evaluates to `false' execution of
the `while' loop terminates and the statement immediately following the
`while' loop is executed next. Otherwise if it evaluates to `true' the
<statements> are executed and the whole process begins again.

The difference between the `while'  loop and the `repeat until' loop
(see "Repeat") is that the <statements> in the `repeat until' loop are
executed at least once, while the <statements> in the `while' loop are
not executed at all if <bool-expr> is `false' at the first iteration.

If <bool-expr> does not evaluate to `true' or `false' an error is
signalled and a break loop (see "Break Loops") is entered. As usual you
can leave the break loop with `quit;'.  If you enter `return false;',
execution continues with the next statement immediately following the
`while' loop.  If you enter `return true;', execution continues at
<statements>, after which the next evaluation of <bool-expr> may cause
another error.

\beginexample
gap> i := 0;; s := 0;;
gap> while s <= 200 do
>    i := i + 1; s := s + i^2;
>  od;
gap> s;
204    # first sum of the first i squares larger than 200
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Repeat}

\index{loop!repeat}\index{until}

\>`repeat <statements> until <bool-expr>;'{repeat loop}

The `repeat' loop executes the statement sequence <statements> until the
condition <bool-expr> evaluates to `true'.

First <statements> are executed.  Then <bool-expr> is evaluated. If it
evaluates  to `true' the `repeat'  loop terminates and the statement
immediately following the `repeat' loop is executed next. Otherwise if
it evaluates to `false' the whole process begins again with the execution
of the <statements>.

The difference between the `while' loop (see "While") and the `repeat
until' loop is that the <statements> in the `repeat until' loop are
executed at least once, while the <statements> in the `while' loop are
not executed at all if <bool-expr> is `false' at the first iteration.

If <bool-expr> does not evaluate to `true'  or `false' an error is
signalled and a break loop (see "Break Loops") is entered. As usual you
can leave the break loop with `quit;'.  If you enter `return true;',
execution continues with the next statement  immediately following the
`repeat' loop.  If you enter `return  false;', execution continues at
<statements>, after which the next evaluation of <bool-expr> may cause
another error.

\beginexample
gap> i := 0;; s := 0;;
gap> repeat
>    i := i + 1; s := s + i^2;
>  until s > 200;
gap> s;
204    # first sum of the first i squares larger than 200
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{For}

\index{loop!for}\index{do}\index{od}

\>`for <simple-var> in <list-expr> do <statements> od;'{for loop}

The `for' loop executes  the statement sequence <statements> for every
element of the list <list-expr>.

The statement sequence <statements> is first executed with <simple-var>
bound to the first element of the list <list>, then with <simple-var>
bound to the second element of <list> and so on. <simple-var> must be a
simple variable,  it  must not   be  a list   element  selection
`<list-var>[<int-expr>]'   or    a  record  component selection
`<record-var>.<ident>'.

The execution of the `for' loop over a list is exactly equivalent to
the following `while' loop

\begintt
<loop-list> := <list>;
<loop-index> := 1;
while <loop-index> <= Length(<loop-list>) do
  <variable> := <loop-list>[<loop-index>];
  <statements>
  <loop-index> := <loop-index> + 1;
od;
\endtt

with the  exception  that <loop-list> and <loop-index> are different
variables for each `for' loop that do not interfere with each other.

The list <list> is very often a range.

\>`for <variable> in [<from>..<to>] do <statements> od;'{loop over range}

corresponds to the more common

\){`for <variable> from <from> to <to> do <statements> od;'}

in other programming languages.

\beginexample
gap> s := 0;;
gap> for i in [1..100] do
>    s := s + i;
> od;
gap> s;
5050
\endexample

Note in the following example how the modification of the *list* in the
loop body causes the loop body also to be executed for the new values

\beginexample
gap> l := [ 1, 2, 3, 4, 5, 6 ];;
gap> for i in l do
>    Print( i, " " );
>    if i mod 2 = 0 then Add( l, 3 * i / 2 ); fi;
> od; Print( "\n" );
1 2 3 4 5 6 3 6 9 9
gap> l;
[ 1, 2, 3, 4, 5, 6, 3, 6, 9, 9 ]
\endexample

Note in the following example that the modification of the *variable*
that holds the list has no influence on the loop

\beginexample
gap> l := [ 1, 2, 3, 4, 5, 6 ];;
gap> for i in l do
>    Print( i, " " );
>    l := [];
> od; Print( "\n" );
1 2 3 4 5 6
gap> l;
[ ]
\endexample

\>`for <variable> in <iterator> do <statements> od;'{loop over iterator}

It is also possible to have a `for'-loop run over an iterator. In this case
the for loop is equivalent to

\begintt
while not IsDoneIterator(<iterator>) do
  <variable> := NextIterator(<iterator>)
  <statements>
od;
\endtt

See "Iterators" for details about iterators.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Functions}
\index{function}\index{end}\index{local}
\index{recursion}\index{recursive functions}
\index{environment}\index{body}

\begintt
function ( [ <arg-ident> {, <arg-ident>} )
[local  <loc-ident> {, <loc-ident>} ; ]
<statements>
end
\endtt

A function is in fact a literal and not a statement. Such a function
literal can be assigned to a variable or to a list element or a record
component. Later this function can be called as described in "Function
Calls".

The following is an example of a function definition.  It is a function
to compute values of the Fibonacci sequence (see "Fibonacci")

\beginexample
gap> fib := function ( n )
>     local f1, f2, f3, i;
>     f1 := 1; f2 := 1;
>     for i in [3..n] do
>       f3 := f1 + f2;
>       f1 := f2;
>       f2 := f3;
>     od;
>     return f2;
>   end;;
gap> List( [1..10], fib );
[ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
\endexample

Because for each of the formal arguments <arg-ident> and for each of the
formal locals <loc-ident> a new variable is allocated when the function
is called (see "Function Calls"), it is possible that a function calls
itself. This is usually called *recursion*. The following is a recursive
function that computes values of the Fibonacci sequence

\beginexample
gap> fib := function ( n )
>     if n < 3 then
>       return 1;
>     else
>       return fib(n-1) + fib(n-2);
>     fi;
>   end;;
gap> List( [1..10], fib );
[ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
\endexample

Note that the recursive version needs `2 * fib(<n>)-1' steps to compute
`fib(<n>)', while the iterative version  of `fib' needs only `<n>-2'
steps.  Both are not optimal however, the library function `Fibonacci'
only needs about `Log(<n>)' steps.

\>`<arg-ident> -> <expr>'{arrow notation for functions}

This is a shorthand for

\){`function ( <arg-ident> ) return <expr>; end'.}

<arg-ident> must be a single identifier, i.e., it is not possible to
write functions of several arguments this way. Also `arg' is not treated
specially, so it is also impossible to write functions that take a
variable number of arguments this way.

The following is an example of a typical use of such a function

\beginexample
gap> Sum( List( [1..100], x -> x^2 ) );
338350
\endexample

When a function <fun1> definition is evaluated inside another function
<fun2>, {\GAP} binds all the identifiers inside the function <fun1> that
are identifiers of an argument or a local of <fun2> to the corresponding
variable. This set of bindings is called the environment of the function
<fun1>. When <fun1> is called, its body is executed in this environment.
The following implementation of a simple stack uses this. Values can be
pushed onto the stack and then later be popped off again.  The
interesting thing here is that the functions `push' and `pop' in the
record returned by `Stack' access the local variable `stack' of `Stack'.
When `Stack' is called a new variable for the identifier `stack' is
created.  When the function definitions of `push' and `pop' are then
evaluated (as part of the `return' statement) each reference to `stack'
is bound to this new variable. Note also that the two stacks `A' and `B'
do not interfere, because each call of `Stack' creates a new variable for
`stack'.

\beginexample
gap> Stack := function ()
>     local  stack;
>     stack := [];
>     return rec(
>       push := function ( value )
>         Add( stack, value );
>       end,
>       pop := function ()
>         local  value;
>         value := stack[Length(stack)];
>         Unbind( stack[Length(stack)] );
>         return value;
>       end
>     );
>  end;;
gap> A := Stack();;
gap> B := Stack();;
gap> A.push( 1 ); A.push( 2 ); A.push( 3 );
gap> B.push( 4 ); B.push( 5 ); B.push( 6 );
gap> A.pop(); A.pop(); A.pop();
3
2
1
gap> B.pop(); B.pop(); B.pop();
6
5
4
\endexample

This feature should be used rarely, since its implementation in {\GAP} is
not very efficient.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Return}

\>`return;'{return from functions}

In this form `return' terminates the call of the innermost function that
is currently executing, and control returns to the calling function. An
error is signalled if no function is currently executing. No value is
returned by the function.

\>`return <expr>;'{return a value}

In this form `return' terminates the call of the innermost function that
is currently executing, and returns the value of the expression <expr>.
Control returns to the calling function. An error is signalled if no
function is currently executing.

Both statements can also be used in break loops (see "Break Loops").
`return;' has the effect that the computation continues where it was
interrupted by an error or the user hitting <ctr>-`C'.  `return <expr>;'
can be used to continue execution after an error. What happens with the
value <expr> depends on the particular error.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The Syntax in BNF}

\index{BNF}

This section contains the definition  of the {\GAP} syntax in Backus-Naur
form.

A  BNF is a set of rules, whose left side  is the name of  a  syntactical
construct.  Those  names  are enclosed in angle  brackets and  written in
<italics>.  The right side of each rule contains a possible form for that
syntactic  construct.   Each  right  side  may  contain  names  of  other
syntactic  constructs,  again  enclosed in angle brackets and written  in
<italics>,  or character  sequences that  must  occur literally; they are
written in `typewriter style'.

Furthermore  each righthand side  can contain  the  following metasymbols
written in *boldface*.  If the right  hand  side contains forms separated
by a pipe symbol  ($|$)  this means  that one  of the possible forms can
occur.  If a part of a form  is enclosed  in square brackets  ([ ])  this
means that this part is optional, i.e.  might be present or  missing.  If
part  of the form is enclosed  in curly braces  (`\{  \}')  this means that
the part may occur arbitrarily often, or possibly be missing.

\vfill\eject% new page
\vbox{\settabs\+<Permutation> &:=& `( <Expr> \{, <Expr> \} )\{ ( <Expr> \{, <Expr> \} ) \}'\cr
\+<Ident>&:=&`a|...|z|A|...|Z|_\{a|...|z|A|...|Z|0|...|9|_\}'\cr
\+<Var>&:=&<Ident>\cr
\+&$|$&<Var> `.' <Ident>\cr
\+&$|$&<Var> `.' `(' <Expr> `)'\cr
\+&$|$&<Var> `[' <Expr> `]'\cr
\+&$|$&<Var> `\{ <Expr> \}'\cr
\+&$|$&<Var> `( [ <Expr> \{ ,<Expr> \} ] )'\cr
\+<List>&:=&`[ [ <Expr> ] \{, [ <Expr> ] \} ]'\cr
\+&$|$&`[ <Expr> [, <Expr> ] .. <Expr> ]'\cr
\+<Record>&:=&`rec( [ <Ident> := <Expr>\{, <Ident> := <Expr> \} ] )'\cr
\+<Permutation>&:=&`( <Expr> \{, <Expr> \} )\{ ( <Expr> \{, <Expr> \} ) \}'\cr
\+<Function>&:=&`function ( [ <Ident> \{, <Ident> \} ] )'\cr
\+& &    `[ local  <Ident> \{, <Ident> \} ; ]'\cr
\+& &    <Statements>\cr
\+& &`end'\cr
\+<Char>&:=&\pif <any character> \pif\cr
\+<String>&:=&`" \{ <any character> \} "'\cr
\+<Int>&:=&`0|1|...|9\{0|1|...|9\}'\cr
\+<Atom>&:=&<Int>\cr
\+&$|$&<Var>\cr
\+&$|$&`( <Expr> )'\cr
\+&$|$&<Permutation>\cr
\+&$|$&<Char>\cr
\+&$|$&<String>\cr
\+&$|$&<Function>\cr
\+&$|$&<List>\cr
\+&$|$&<Record>\cr
\+<Factor>&:=&`\{+|-\} <Atom> [ ^ \{+|-\} <Atom> ]'\cr
\+<Term>&:=&`<Factor> \{ *|/|mod <Factor> \}'\cr
\+<Arith>&:=&`<Term> \{ +|- <Term> \}'\cr
\+<Rel>&:=&`\{ not \} <Arith> \{ |=|<>|<|>|<=|>=|in| <Arith> \}'\cr
\+<And>&:=&`<Rel> \{ and <Rel> \}'\cr
\+<Log>&:=&`<And> \{ or <And> \}'\cr
\+<Expr>&:=&<Log>\cr
\+&$|$&`<Var> [ -> <Log> ]'\cr
\+<Statement>&:=&<Expr>\cr
\+&$|$&<Var> `:=' <Expr>\cr
\+&$|$&`if   <Expr>  then <Statements>'\cr
\+&&`\{elif <Expr> then '&`<Statements> \}'\cr
\+&&`[ else'&`<Statements>  ] fi'\cr
\+&$|$&`for <Var> in <Expr> do <Statements> od'\cr
\+&$|$&`while <Expr>  do' <Statements>  od'\cr
\+&$|$&`repeat <Statements>  until <Expr>'\cr
\+&$|$&`return [ <Expr> ]'\cr
\+&$|$&`quit'\cr
\+<Statements>&:=&`\{ <Statement> ; \}'\cr
\+&$|$&`;'\cr
}
