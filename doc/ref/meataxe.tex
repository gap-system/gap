%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  meataxe.tex                 GAP documentation        Alexander Hulpke
%%
%H  @(#)$Id$
%%
%Y  Copyright 1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,   Germany
%%
%%  This file contains a description of the MeatAxe functions.
%%

\Chapter{The MeatAxe}

The MeatAxe \cite{Par84} is a tool for the examination of submodules of a
group algebra. It is a basic tool for the examination of group actions on
finite-dimensional modules.

{\GAP} uses the improved MeatAxe of Derek Holt and Sarah Rees, and
also incorporates further improvements of Ivanyos and Lux.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{MeatAxe Modules}

\>GModuleByMats(<gens>,<field>)
\>GModuleByMats(<emptygens>,<dim>,<field>)

creates a MeatAxe module over <field> from a list of invertible matrices 
<gens> which reflect a group's action. If the list of generators is empty,
the dimension must be given as second argument.

MeatAxe routines are on a level with Gaussian elimination. Therefore they do
not deal with {\GAP} modules but essentially with lists of matrices. For the
MeatAxe, a module is a record with components
\beginitems
`generators'&A list of matrices which represent a group operation on a
finite dimensional row vector space.

`dimension'&The dimension of the vector space (this is the common length of
the row vectors (see~"DimensionOfVectors")).

`field'&The field over which the vector space is defined.
\enditems
Once a module has been created its entries may not be changed. A MeatAxe may
create a new component <NameOfMeatAxe> in which it can store private
information. By a MeatAxe ``submodule'' or ``factor module'' we denote
actually the *induced action* on the submodule, respectively factor module.
Therefore the submodules or factor modules are again MeatAxe modules. The
arrangement of `generators' is guaranteed to be the same for the induced
modules, but to obtain the complete relation to the original module, the
bases used are needed as well.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Selecting a Different MeatAxe}

All MeatAxe routines are accessed via the global variable `MTX', which is a
record whose components hold the various functions. It is possible to have
several implementations of a MeatAxe available. Each MeatAxe represents its
routines in an own global variable and assigning `MTX' to this variable
selects the corresponding MeatAxe.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Accessing a Module}

Even though a MeatAxe module is a record, its components should never be
accessed outside of MeatAxe functions. Instead the following operations
should be used:

\>MTX.Generators(<module>)

returns a list of matrix generators of <module>.

\>MTX.Dimension(<module>)

returns the dimension in which the matrices act.

\>MTX.Field(<module>)

returns the field over which <module> is defined.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Irreducibility Tests}

\>MTX.IsIrreducible(<module>) AST

tests whether the module <module> is irreducible (i.e. contains no proper
submodules.)

\>MTX.IsAbsolutelyIrreducible(<module>) AST

A module is absolutely irreducible if it remains irreducible over the
algebraic closure of the field. (Formally: If the tensor product $L\otimes_K
M$ is irreducible where $M$ is the module defined over $K$ and $L$ is the
algebraic closure of $K$.)

\>MTX.DegreeSplittingField(<module>)

returns the degree of the splitting field as extension of the prime field.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Finding Submodules}

\>MTX.SubmoduleGModule(<module>, <subspace>) F

<subspace> should be a subspace of (or a vector in) the underlying vector
space of <module> i.e. the full row space of the same dimension and over
the same field as <module>. A normalized basis of the submodule of
<module> generated by <subspace> is returned.

\>MTX.ProperSubmoduleBasis(<module>) F

returns the action on a proper submodule and `fail' if no proper submodule
exists.

\>MTX.BasesSubmodules(<module>) F

returns a list containing a basis for every submodule.

\>MTX.BasesMinimalSubmodules(<module>) F

returns a list of bases of all minimal submodules.

\>MTX.BasesMaximalSubmodules(<module>) F

returns a list of bases of all maximal submodules.

\>MTX.BasisRadical(<module>) F

returns a basis of the radical of <module>.

\>MTX.BasisSocle(<module>) F

returns a basis of the socle of <module>.

\>MTX.BasesMinimalSupermodules(<module>,<sub>) F

returns a list of bases of all minimal supermodules of the submodule given by
the basis <sub>.

\>MTX.BasesCompositionSeries(<module>) F

returns a list of bases of submodules in a composition series in ascending
order.

\>MTX.CompositionFactors(<module>) F

returns a list of composition factors of <module> in ascending order.

\>MTX.CollectedFactors(<module>) F

returns a list giving all irreducible composition factors with their
frequencies.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Induced Actions}

\>MTX.InducedActionSubmodule(<module>,<sub>) F
\>MTX.InducedActionSubmoduleNB(<module>,sub) F

creates a new module corresponding to the action of <module> on <sub>. In
the `NB' version the basis <sub> must be normed. (That is it must be in
echelon form with pivots normed to 1.)

\>MTX.InducedActionFactorModule(<module>,<sub>[,<compl>]) F

creates a new module corresponding to the action of <module> on the
factor of <sub>. If <compl> is given, it has to be a basis of a
(vectorspace-)complement of <sub>. The action then will correspond to
<compl>.

\>MTX.InducedAction(<module>,<sub>[,<type>]) F

Computes induced actions on submodules or factormodules and also returns the
corresponding bases. The action taken is binary encoded in <type>:
1 stands for subspace action, 2 for
factor action and 4 for action of the full module
on a subspace adapted basis.
The routine returns the computed results in a list in sequence
(<sub>,<quot>,<both>,<basis>) where <basis> is a basis for the whole space,
extending <sub>. (Actions which are not computed are omitted, so the
returned list may be shorter.)
If no <type> is given, it is assumed to be 7.
The basis given in <sub> must be normed!

All these routines return `fail' if <sub> is not a proper subspace.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Module Homomorphisms}

\>MTX.IsEquivalent(<module>1,module2) F

tests two irreducible modules for equivalence.

\>MTX.Isomorphism(<module1>,<module2>) F

returns an isomorphism from <module1> to <module2> (if one exists) and 
`fail' otherwise. It requires that one of the modules is known to be
irreducible. It implicitly assumes that the same group is acting, otherwise
the results are unpredictable.
The isomorphism is given by a matrix $M$, whose rows give the images of the
standard basis vectors of module2 in the standard basis of module1. That is,
conjugation of the generators of <module2> with $M$ yields the
generators of <module1>.

\>MTX.Homomorphism(<module1>,<module2>,<mat>) F

<mat> should be a <dim1> $\times$ <dim2> matrix defining a homomorphism
from <module1> to <module2>.  This function verifies that <mat>
really does define a module homomorphism, and then returns the
corresponding homomorphism between the underlying row spaces of the
modules. This can be used for computing kernels, images and pre-images.

\>MTX.Homomorphisms(<module1>,<module2>) F

returns a basis of all homomorphisms from the irreducible module 
<module1> to <module2>.

\>MTX.Distinguish(<cf>,<nr>) F

Let <cf> be the output of `MTX.CollectedFactors'. This routine
tries to find a group algebra element that has nullity zero on all
composition factors except number <nr>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The Smash MeatAxe}

The standard MeatAxe provided in the {\GAP} library is
is based on the MeatAxe in the {\sf Smash} share
package for {\GAP}3, originally written by Derek Holt and Sarah Rees
(\cite{HR94}). It is
accessible via the variable `SMTX' to which `MTX' is assigned by default. 
For the sake of completeness the remaining sections document more technical
functions of this MeatAxe.

\>SMTX.RandomIrreducibleSubGModule(<module>) F

returns the module action on a random irreducible submodule.

\>SMTX.GoodElementGModule(<module>) F

finds an element with minimal possible nullspace dimension if <module>
is known to be irreducible.

\>SMTX.SortHomGModule(<module1>,<module2>,<homs>) F

Function to sort the output of `Homomorphisms'.

\>SMTX.MinimalSubGModules(<module1>,<module2>[,<max>])

returns (at most <max>) bases of submodules of <module2> which are
isomorphic to the irreducible module  <module1>.

\>SMTX.Setter(<string>)

returns a setter function for the component `smashMeataxe.(string)'.

\>SMTX.Getter(<string>)

returns a getter function for the component `smashMeataxe.(string)'.

\>SMTX.IrreducibilityTest(<module>)

Tests for irreducibility and sets a subbasis if reducible. It neither sets
an irreducibility flag, nor tests it. Thus the routine also can simply be
called to obtain a random submodule.

\>SMTX.AbsoluteIrreducibilityTest(<module>)

Tests for absolute irreducibility and sets splitting field degree. It
neither sets an absolute irreducibility flag, nor tests it.

\>SMTX.MinimalSubGModule(<module>,<cf>,<nr>)

returns the basis of a minimal submodule of <module> containing the
indicated composition factor. It assumes `Distinguish' has been called
already.

\>SMTX.MatrixSum(<matrices1>,<matrices2>)

creates the direct sum of two matrix lists.

\>SMTX.CompleteBasis(<module>,<pbasis>)

extends the partial basis <pbasis> to a basis of the full space
by action of <module>. It returns whether it succeeded.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Smash MeatAxe Flags}

The following getter routines access internal flags. For each routine, the
appropriate setters name is prefixed with <Set>.

\>SMTX.Subbasis

Basis of a submodule

\>SMTX.AlgEl

list `[newgens,coefflist]' giving an algebra element used for chopping.

\>SMTX.AlgElMat

matrix of `SMTX.AlgEl'.

\>SMTX.AlgElCharPol

minimal polynomial of `SMTX.AlgEl'.

\>SMTX.AlgElCharPolFac

used factor of `SMTX.AlgEl'.

\>SMTX.AlgElNullspaceVec

nullspace of the matrix evaluated under this factor.

\>SMTX.AlgElNullspaceDimension

dimension of the nullspace.

\>SMTX.CentMat


\>SMTX.CentMatMinPoly


