%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  group.tex                 GAP documentation             Thomas Breuer
%W                                                         & Frank Celler
%W                                                     & Martin Schoenert
%W                                                       & Heiko Theissen
%%
%H  @(#)$Id$
%%
%Y  Copyright 1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,   Germany
%%
%%  This file contains a tutorial introduction to lists.
%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Groups and Homomorphisms}

In this chapter we will show  some computations with groups. The examples
deal most with permutation groups, because they are the most easy ones to
input.  The   functions mentioned    here,   like  `Group',   `Size'   or
`SylowSubgroup', however, are the same for all  kinds of groups, although
the algorithms which compute the information  of course will be different
in most cases.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Permutation groups}

Permutation  groups  are so easy to  input  because their elements, i.e.,
permutations,  are  so easy to  type: they  are  entered and displayed in
disjoint cycle notation. So let's construct a permutation group:
\beginexample
    gap> s8 := Group( (1,2), (1,2,3,4,5,6,7,8) );
    Group( [ (1,2), (1,2,3,4,5,6,7,8) ], ... )
\endexample
We  formed  the  group     generated by  the permutations    `(1,2)'  and
`(1,2,3,4,5,6,7,8)', which  is well known   to be the symmetric  group on
eight  points, and assigned it to  the identifier `s8'. `s8' contains the
alternating group on eight points which can be described in several ways,
e.g.,  as group  of all  even permutations  in  `s8',  or as its  derived
subgroup.
\beginexample
    gap> a8 := DerivedSubgroup( s8 );
    Group( [ (1,3,2), (2,4,3), (3,5,4), (4,6,5), (5,7,6), (6,8,7) ], ... )
    gap> Size( a8 ); IsAbelian( a8 ); IsPerfect( a8 );
    20160
    false
    true
\endexample
Once information about a group like `a8'  has been computed, it is stored
in the group so that it can simply be looked up  if it is required again.
This holds for all pieces of information  in the previous example. Had we
computed  `a8' as `CommutatorSubgroup(  s8, s8 )',  however, it would not
have been stored, because it would then  have been computed as a function
of *two* arguments, and hence one could  not attribute it  to just one of
them. (Of  course   the function  `CommutatorSubgroup'  can  compute  the
commutator subgroup of *two* arbitrary subgroups.) The situation is a bit
different for Sylow  <p>-subgroups:  The  function  `SylowSubgroup'  also
requires two arguments, namely a group and a prime <p>, but the result is
stored in the  group --- namely together  with  the prime  <p> in a  list
called `ComputedSylowSubgroups', but we won't dwell on the details here.
\beginexample
    gap> syl2 := SylowSubgroup( a8, 2 );; Size( syl2 );
    64
    gap> Normalizer( a8, syl2 ) = syl2;
    true
    gap> cent := Centralizer( a8, Centre( syl2 ) );; Size( cent );
    192
    gap> DerivedSeries( cent );; List( last, Size );
    [ 192, 96, 32, 2, 1 ]
\endexample
We have typed double semicolons  after some commands  to avoid the output
of the  groups   (which would  be  printed  by their  generator   lists).
Nevertheless, the beginner  is  encouraged to   type  a single  semicolon
instead and study the full output. This  remark also applies for the rest
of this tutorial.

With the next  examples, we want  to calculcate a  subgroup of `a8', then
its  normalizer and finally determine the  structure of the extension. We
begin by forming a subgroup   generated by three commuting   involutions,
i.e., a subgroup  isomorphic to the   additive group of the  vector space
$2^3$.
\beginexample
    gap> elab := Group( (1,2)(3,4)(5,6)(7,8), (1,3)(2,4)(5,7)(6,8),
    >                   (1,5)(2,6)(3,7)(4,8) );;
    Group( [ (1,2)(3,4)(5,6)(7,8), (1,3)(2,4)(5,7)(6,8),
      (1,5)(2,6)(3,7)(4,8) ] )
    gap> Size( elab );
    8
    gap> IsElementaryAbelian( elab );
    true
\endexample
As usual, {\GAP} prints the group by giving  all its generators. This can
be annoying, especially if there are many of them or  if they are of huge
degree. It also makes  it difficult to recognize  a particular group when
there already several  around. Note  that  although it is no  problem for
*us* to    specify a particular  group to   {\GAP}, by  using well-chosen
identifiers such as `a8'  and `elab', it is  impossible for {\GAP} to use
these identifiers when printing  a group for us,  because the group  does
not know which identifier(s) point  to it, in fact  there can be several.
In order to    give a name  to  the  group  itself (rather   than  to the
identifier), you have to use the function `SetName'.  We do this with the
name `2^3' here which reflects  the mathematical properties of the group.
From now on,  {\GAP} will use  this name when  printing the group for us,
but we still cannot use this name to specify the group to {\GAP}, because
the name does  not know to which group   is was assigned (after  all, you
could assign the   same  name to several  groups).  When  talking  to the
computer, you must always use identifiers.
\beginexample
    gap> SetName( elab, "2^3" ); elab;
    2^3
    gap> norm := Normalizer( a8, elab );; Size( norm );
    1344
\endexample
\index{homomorphism!natural}%
Now that  we  have the subgroup `norm'   of order 1344   and its subgroup
`elab', we want to look  at its factor  group. But since  we also want to
find preimages of factor group elements in `norm', we really want to look
at the  *natural homomorphism* defined on  `norm' with  kernel `elab' and
whose image is the factor group.
\beginexample
    gap> hom := NaturalHomomorphismByNormalSubgroup( norm, elab );
    <operation homomorphism>
    gap> f := Image( hom );
    Group( [ (), (), (), (4,5)(6,7), (4,6)(5,7), (2,3)(6,7), (2,4)(3,5), 
      (1,2)(5,6) ], ... )
    gap> Size( f );
    168
\endexample
The factor group  is again represented as  a  permutation group. However,
the operation domain  of this factor  group has  nothing  to do with  the
operation domain of `norm'. (It only happens that both are subsets of the
natural numbers.) We can now form  images and preimages under the natural
homomorphism. The set of  preimages of an element under  `hom' is a coset
modulo `elab'. We use the function  `PreImages' here because `hom' is not
a bijection, so an  element of the range can   have several preimages  or
none at all.
\beginexample
    gap> Kernel( hom );
    2^3
    gap> x := (1,8,3,5,7,6,2);; Image( hom, x );
    ( 1, 7, 5, 6, 2, 3, 4)
    gap> coset := PreImages( hom, last );
    RightCoset(2^3,( 2, 8, 6, 7, 3, 4, 5))
    gap> GeneratorsOfGroup( elab )[1] * x in coset;
    true
\endexample
The factor  group `f'  is  a simple  group,  i.e., it has  no non-trivial
normal subgroups. {\GAP} can detect this fact,  and it can then also find
the name by which this simple group is known among group theorists. (Such
names are of course not available for non-simple groups.)
\beginexample
    gap> IsSimple( f ); IsomorphismTypeFiniteSimpleGroup( f );
    true
    "A(1,7) = L(2,7) ~ B(1,7) = O(3,7) ~ C(1,7) = S(2,7) ~ 2A(1,7) =\
    U(2,7) ~ A(2,2) = L(3,2)"
    gap> SetName( f, "L_3(2)" );
\endexample
We give `f' the name  `L_3(2)' because the  last part of the name  string
reveals that  it is isomorphic to  the simple linear group $L_3(2)$. This
group, however, also has a  lot of other  names. Names that are connected
with a  `=' sign  are different names   for the same matrix group,  i.e.,
`A(2,2)' is the  Lie type notation for  the  classical notation `L(3,2)'.
Other pairs  of  names are  connected via `~',  these then  specify other
classical  groups  that are isomorphic  to that  linear  group (e.g., the
symplectic group `S(2,7)', whose Lie type notation would be `C(1,7)').

The group `norm' acts on the eight elements of its normal subgroup `elab'
by conjugation,  yielding  a representation   of $L_3(2)$ in   `s8' which
leaves one    point  fixed  (namely  point~`1').    The   image of   this
representation can be computed with the function  `Operation'; it is even
contained  in the group `norm' and  we can show  that `norm'  is indeed a
split extension of the elementary abelian group $2^3$  with this image of
$L_3(2)$.
\beginexample
    gap> op := Operation( norm, elab );
    Group( [ (), (), (), (5,6)(7,8), (5,7)(6,8), (3,4)(7,8), (3,5)(4,6), 
      (2,3)(6,7) ], ... )
    gap> IsSubgroup( a8, op ); IsSubgroup( norm, op );
    true
    true
    gap> IsTrivial( Intersection( elab, op ) );
    true
    gap> SetName( norm, "2^3:L_3(2)" );
\endexample
By the way, you should not try the operator `\<'  instead of the function
`IsSubgroup'. Something like
\beginexample
    gap> elab < a8;
    false
\endexample
will not cause an error, but the result does not  tell anything about the
inclusion of one group in another; `\<' tests  which of the two groups is
less is some total order. On the other hand, the equality operator `=' in
fact does test the equality of groups.

{\bf Summary.}   In  this section   we have   used   the elementary group
functions to determine  the structure of  a normalizer. We have  assigned
names  to the involved groups which  reflect their mathematical structure
and {\GAP} uses these names when printing the groups.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations!of groups}

In  order to get  another  representation  of  `a8', we consider  another
action, namely  that on  the elements   of a  certain conjugacy  class by
conjugation.
\beginexample
    gap> ccl := ConjugacyClasses( a8 );; Length( ccl );
    14
    gap> List( ccl, c -> Order( Representative( c ) ) );
    [ 1, 7, 7, 4, 2, 2, 4, 3, 3, 5, 6, 6, 15, 15 ]
    gap> List( ccl, Size );
    [ 1, 2880, 2880, 1260, 105, 210, 2520, 1120, 112, 1344, 1680, 3360,
      1344, 1344 ]
\endexample
Note  the  difference between `Order'  (which   means the element order),
`Size' (which means the size of the conjugacy  class) and `Length' (which
means the length of  a list). We choose to  let `a8' operate on the class
of length~112.
\beginexample
    gap> class := First( ccl, c -> Size(c) = 112 );;
    gap> op := Operation( a8, AsList( class ) );;
\endexample
We use `AsList' here  to convert the conjugacy class  into a list  of its
elements whereas we   wrote  `Operation( norm,  elab )'   directly in the
previous section. The reason is that  the elementary abelian group `elab'
can  be quickly enumerated by   {\GAP}  whereas the standard  enumeration
method for conjugacy classes is  slower than just explicit calculation of
the elements. However, {\GAP} is reluctant  to construct explicit element
lists, because for really large groups this direct method is infeasible.

We got a permutation representation `op' on 112 points, which we now test
for primitivity. If  it is not primitive, we  can obtain  a minimal block
system (i.e., one where the  blocks have minimal  length) by the function
`Blocks'.
\beginexample
    gap> IsPrimitive( op, [ 1 .. 112 ] );
    false
    gap> blocks := Blocks( op, [ 1 .. 112 ] );;
\endexample
Note that we  must specify the domain  of the operation. You  might think
that the   functions `IsPrimitive' and `Blocks'  could  use `[1..112]' as
default  domain if no  domain was  given. But  this  is not so  easy, for
example  would the default domain  of `Group(  (2,3,4)  )' be `[1..4]' or
`[2..4]'? To  avoid confusion, all operation  functions  require that you
specify  the domain of operation. If  we had specified  `[1..113]' in the
primitivity test above,  point~113  would have been  a fixpoint  (and the
operation would not even have been transitive).

Now `blocks' is a list of blocks (i.e., a list of lists), which we do not
print  here for the  sake of saving paper (try  it for yourself). In fact
all we want to know is the size of  the blocks, or  rather how many there
are (the product of these two numbers must of course be~112). Then we can
obtain a new  permutation group  of the  corresponding  degree by letting
`op' act on these blocks setwise.
\beginexample
    gap> Length( blocks[1] );  Length( blocks );
    2
    56
    gap> op2 := Operation( op, blocks, OnSets );;
    gap> IsPrimitive( op2, [ 1 .. 56 ] );
    true
\endexample
The action of `op' on the given block system gave us a new representation
on 56 points which is primitive, i.e., the  point stabilizer is a maximal
subgroup. We  compute its preimage in the  representation on eight points
using the   associated   operation homomorphisms (which   of   course are
monomorphisms). We construct  the  composition of two  homomorphisms with
the `*' operator, reading left-to-right.
\beginexample
    gap> ophom := OperationHomomorphism( a8, op );;
    gap> ophom2 := OperationHomomorphism( op, op2 );;
    gap> composition := ophom * ophom2;;
    gap> stab := Stabilizer( op2, 1 );;
    gap> preim := PreImages( composition, stab );
    Group( [ ( 1, 3, 2), ( 2, 4, 3), ( 5, 8, 6), ( 1, 2)( 6, 8),
      ( 3, 4, 7) ], ... )
\endexample
The normalizer of an element in the conjugacy class `class' is a group of
order 360, too. In fact, it is a conjugate of the maximal subgroup we had
found before, and a conjugating element in `a8'  is found by the function
`RepresentativeOperation'.
\beginexample
    gap> sgp := Normalizer( a8, Subgroup(a8,[Representative(class)]) );;
    gap> Size( sgp );
    360
    gap> RepresentativeOperation( a8, sgp, preim );
    (5,6)(7,8)
\endexample
% The scalar product  of permutation characters  of two subgroups <U>, <V>,
% say, equals  the number  of $(<U>,<V>)$-double  cosets. For example,  the
% norm of  the natural permutation character of  degree  eight is two since
% the action of `a8' on the cosets of a point stabilizer is at least doubly
% transitive. We   also   compute  the   numbers  of    $(`sgp',`sgp')$ and
% $(`sgp',`stab')$ double cosets.
% \beginexample
%     gap> stab := Stabilizer( a8, 1 );;
%     gap> Length( DoubleCosets( a8, stab, stab ) );
%     2
%     gap> Length( DoubleCosets( a8, sgp, sgp ) );
%     4
%     gap> Length( DoubleCosets( a8, sgp, stab ) );
%     2
% \endexample

\index{homomorphism!operation} \index{external set}%
So far we have seen  a few applications  of the functions `Operation' and
`OperationHomomorphism'. But perhaps even  more  interesting is the  fact
that  the  natural  homomorphism `hom'   constructed  above  is  also  an
*operation  homomorphism*;  this  is also  the  reason  why its image  is
represented as a permutation group:  it is the natural representation for
operations. We will now look at this operation homomorphism again to find
out on what   objects it  operates.  These  objects  form the   so-called
*external set* which is  associated with every operation homomorphism. We
will  mention  external sets  only   superficially in this  tutorial, for
details see "ref:External Sets" in the  reference manual. For the moment,
we need   only know that   the external set is  obtained  by the function
`UnderlyingExternalSet'.
\beginexample
    gap> t := UnderlyingExternalSet( hom );
    RightTransversal( 2^3:L_3(2), Group( 
    [ (1,2)(3,4)(5,6)(7,8), (1,3)(2,4)(5,7)(6,8), (1,5)(2,6)(3,7)(4,8), 
      (5,6)(7,8), (5,7)(6,8), (3,4)(7,8), (3,5)(4,6) ], ... ) )
\endexample
\index{right transversal}%
For  the   natural homomorphism   `hom' the  external   set  is a  *right
transversal* of a subgroup  <U>   in `norm',  and   action on the   right
transversal means really action  of the cosets  of the subgroup <U>. When
executing  the function  call `NaturalHomomorphismByNormalSubgroup( norm,
elab )', {\GAP} has  chosen a subgroup  <U> for which  the kernel of this
action (i.e., the core of  <U> in `norm')  is the desired normal subgroup
`elab'. For the purpose of operating on the cosets, the right transversal
`t' contains  one representative  from each coset  of <U>.  Regarded this
way, a transversal  is simply a list of  group elements, and you can make
{\GAP} produce this list by `AsList(t)'. (Try it.)

The  image of  such   a   representative from  `AsList(t)' under    right
multiplication with an  element  from `norm'  will in general  not be  in
`AsList(t)',  because it will   not  be among the  chosen representatives
again.   Hence right multiplication is not   an operation on `AsList(t)'.
However, {\GAP} uses a special trick to be discussed below to make this a
well-defined  operation  on the  cosets   represented by the  elements of
`AsList(t)'. For now, it is important  to know that  the external set `t'
is   more  than just the  right  transversal  on  which  the group `norm'
operates. Altogether three things  are necessary to specify an operation:
a  group~<G>, a  set~<D>, and a   function $<opr>\colon <D>\times  <G>\to
<D>$. We can access these ingredients with the following functions:
\beginexample
    gap> ActingDomain(t); Enumerator(t); FunctionOperation(t);
    2^3:L_3(2)  # the group
|_
    RightTransversal( 2^3:L_3(2), Group( 
    [ (1,2)(3,4)(5,6)(7,8), (1,3)(2,4)(5,7)(6,8), (1,5)(2,6)(3,7)(4,8),
      (5,6)(7,8), (5,7)(6,8), (3,4)(7,8), (3,5)(4,6) ], ... ) )  # the
    set
|_
    function( pnt, elm ) ... end  # the function
    gap> NameFunction( last );
    "OnRight"
\endexample
The function  which   is  named  `"OnRight"'  is  also   assigned to  the
identifier `OnRight', and it means multiplication from the right, this is
the usual way to operate on a right transversal. `OnRight( <d>, <g> )' is
defined as `<d> * <g>'.

\exercise In analogy to `OnRight'  you might expect a function  `OnLeft',
but  actually    there   are    two    functions    `OnLeftInverse'   and
`OnLeftAntiOperation'. How are they defined and why?

\answer   `OnLeftInverse(  <d>,  <g>  )'  means   `<g>^-1 *  <d>',  i.e.,
multiplication  with the  inverse   from   the  left, which defines    an
operation. In constrast,  the mapping $<left>\colon (<d>,<g>) \mapsto <g>
* <d>$ does not yield an operation, but an anti-operation, i.e., $<left>(
<left>( <d>,  <g>_1 ), <g>_2  ) = <left>( <d>, <g>_2  * <g>_1 )$, whereas
for an  operation, the  right hand side  is required  to have the product
$<g>_1 * <g>_2$.  The {\GAP} function which  performs this mapping <left>
is therefore called  `OnLeftAntiOperation', and, unlike  `OnLeftInverse',
this cannot be used as last argument to an operation function.

\index{enumerator}%
Observe  that the external set `t'  and  its `Enumerator' are printed the
same way, but  be aware that an   external set also comprises  the acting
domain  and the operation function.  The  `Enumerator' itself, i.e.,  the
right transversal, in turn comprises knowledge about the group `norm' and
the  subgroup <U>,  and  this is what  allows  the special trick promised
above. As far as `Position' is  concerned, the `Enumerator' behaves as an
(immutable) list and you can ask for the position of an element in it.
\beginexample
    gap> elm := (1,4)(2,7)(3,6)(5,8);;
    gap> Position( Enumerator(t), elm );
    fail
    gap> PositionCanonical( Enumerator(t), elm );
    5
\endexample
\atindex{Position vs. PositionCanonical}{@\noexpand `Position' vs.\ %
\noexpand `PositionCanonical'}%
The result `fail'   means that the element was   not found at  all in the
list: it is not among the chosen  representatives. The difference between
the functions `Position' and `PositionCanonical' is that the first simply
looks whether `elm' is contained among the representatives which together
form the  right transversal `t', whereas  the second really looks for the
position of the  coset described by  the  representative `elm'. In  other
words, it first replaces `elm' by a  canonical representative of the same
coset (which must be contained in `Enumerator(t)') and then looks for its
position, hence the name. The  function `OperationHomomorphism' (and  its
relatives) always use  `PositionCanonical' when they calculate the images
of   the  generators of  the    source  group (here,  `norm')   under the
homomorphism  (here, `hom').  Therefore  they  can  give a   well-defined
operation on an   <enumerator>, even   if the   operation  would not   be
well-defined on `AsList( <enumerator> )'.

\exercise   What   would     be  the  result    of   the  function   call
`PositionCanonical( AsList(t), elm )' (where `AsList(t)' is equivalent to
`AsList(Enumerator(t))')?

\answer `fail', because `AsList(t)'  is simply a list of  representatives
without  any knowledge about the  cosets  they represent. In other words,
{\GAP}    does not  know  that  they   are   representatives, and so  the
``canonical representative'' associated with `elm' is `elm' itself, which
is not among the elements of the list.

The image of  the natural homomorphism  is the permutation group `f' that
results from the operation of `norm' on the right  transversal. It can be
calculcated by either of the following commands. The second of them shows
that the external set `t' contains all information  that is necessary for
`Operation' to do its work.
\beginexample
    gap> Operation( norm, Enumerator(t), OnRight ) = f;
    true
    gap> Operation( t ) = f;
    true
\endexample
We  have specified the operation function  `OnRight' in this example, but
we have seen  examples like `Operation( norm,  elab )' earlier where this
third argument was not given. If an operation function is omitted, {\GAP}
always assumes `OnPoints' which is defined as `OnPoints( <d>, <g> ) = <d>
^ <g>'. This ``caret''  operator denotes conjugation in  a group if  both
arguments <d> and  <g> are group elements  (contained in a common group),
but it also  denotes the natural  operation  of permutations on  positive
integers (and exponentiation of integers as well, of course).

\exercise Could   these  several meanings    of  `<d>  ^ <g>'   lead   to
ambiguities?

\answer Yes, if <d> is a cyclotomic and <g> a positive integer, then `<d>
^ <g>' could mean exponentiation  as well as conjugation  in the group of
non-zero cyclotomics.  To   avoid such  ambiguities, {\GAP}   refuses  to
construct groups of cyclotomic numbers.

% \exercise What difference does  it make whether something  is stored in a
% record  component   like `hom!.externalSet'   or   as  an attribute  like
% `Enumerator(t)'?
%  
% \answer  A record component  like `hom!.externalSet' must be entered when
% the object `hom'  is constructed, which makes  sense because an operation
% homomorphism   like  `hom' is  constructed for     a given external  set.
% Attributes like `Enumerator(t)' need not  be set upon construction of the
% object, they can be computed  and stored when  they are required for  the
% first time and subsequently be looked up. This  mechanism is explained in
% section~"Attributes".

{\bf Summary.} In this section we have learned  how groups can operate on
{\GAP}   objects such as  integers  and   group  elements.  We  have used
`OperationHomomorphism',    among   others,   to   construct   a  natural
homomorphism,  in which case the  group operated on the right transversal
of a suitable subgroup. This right transversal gave us an example for the
use of `PositionCanonical', which allowed  us to specify cosets by giving
representatives.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroups!as stabilizers}

Operation functions can also be  used without constructing external sets.
We will try to   find several subgroups  in `a8'  as stabilizers of  such
operations. One subgroup is immediately  available, namely the stabilizer
of one point. The index of the stabilizer must of course  be equal to the
length of the orbit, i.e.,~8.
\beginexample
    gap> u8 := Stabilizer( a8, 1 );
    Group( [ (2,4,3), (3,5,4), (4,6,5), (5,7,6), (6,8,7) ], ... )
    gap> Index( a8, u8 );
    8
    gap> Orbit( a8, 1 ); Length( last );
    [ 1, 2, 3, 4, 5, 6, 7, 8 ]
    8
\endexample
This gives us a hint how to find further  subgroups. Each subgroup is the
stabilizer of a point of an appropriate  transitive operation (namely the
operation  on  the cosets of that  subgroup  or another operation that is
equivalent to  this operation).  So the question   is how  to find  other
operations. The obvious thing is to operate  on pairs of points. So using
the function `Tuples' we first generate a list of all pairs.
\beginexample
    gap> pairs := Tuples( [1..8], 2 );;
\endexample
Now we would like to have `a8' operate on this  domain. But we cannot use
the  default operation `OnPoints'  because    `<list> ^ <perm>' is    not
defined. So we  must tell the functions  from the operations package  how
the group elements operate on the elements of  the domain. In our example
we can do this by simply passing `OnPairs' as optional last argument. All
functions  from the operations package  accept  such an optional argument
that describes the operation. One example is `IsTransitive'.
\beginexample
    gap> IsTransitive( a8, pairs, OnPairs );
    false 
\endexample
The operation is not transitive,  so we want to  find out what the orbits
are. The function `Orbits' does that for us. It returns a list of all the
orbits.
\beginexample
    gap> orbs := Orbits( a8, pairs, OnPairs );; Length( orbs );
    2
    gap> List( orbs, o -> o[1] );
    [ [ 1, 1 ], [ 1, 2 ] ]
\endexample
The operation of `a8'   on the first  orbit (this  is the one  containing
`[1,1]', try `[1,1] in orbs[1]') is of  course equivalent to the original
operation, so we ignore it and work with the second orbit.
\beginexample
    gap> u56 := Stabilizer( a8, orbs[2][1], OnPairs );; Index( a8, u56 );
    56 
\endexample
So   now   we have  found   a  second subgroup.   To   make the following
computations a little bit easier and more efficient  we would now like to
work on the points `[1..56]'  instead of the list  of pairs. The function
`OperationHomomorphism' does what  we need.   It creates a   homomorphism
defined on `a8' whose image is a new group  that operates on `[1..56]' in
the same way that `a8' operates on the second orbit.
\beginexample
    gap> h56 := OperationHomomorphism( a8, orbs[2], OnPairs );;
    gap> a8_56 := Image( h56 );;
\endexample
We would now like to know if the subgroup `u56' of index 56 that we found
is  maximal or  not.   Again  we can make  use  of  a function  from  the
operations package.  Namely a subgroup is maximal if the operation on the
cosets of  this subgroup is primitive.
\beginexample
    gap> IsPrimitive( a8_56, [1..56] );
    false 
\endexample
Remember that we  can leave out the  function  if we mean  `OnPoints' but
that we have to specify the operation domain for all operation functions.

\exercise What happens if  you call a function  like `Operation( <G>, <D>
)',  where the group  <G>  moves points  that are   not contained in  the
operation domain~<D>?

\answer If the  operation domain <D> is  closed  under the action  of the
group <G>, i.e., if  it is a union of  orbits, `Operation' will construct
the operation only on that domain, i.e.,  it will compute the restriction
of <G> to~<D>. If  the operation domain  is  not closed, however,  {\GAP}
will   fail to construct  the     generating permutations and return    a
`MagmaWithInverses( [ fail,  \dots,  fail  ] )',  which  is no  good  for
further computations. An exception to this rule is the function `Orbits':
if  <D> is not   closed under <G>, then    `Orbits( <G>, <D> )'  silently
replaces  <D> by its  closure under <G>  and then computes the orbits. In
other words, it  computes all <G>-orbits that contain  at least one point
from the original~<D>.

We see that `a8_56'   is not primitive. This  means  of course   that the
operation  of `a8'  on  `orb[2]'  is not  primitive,  because those   two
operations are equivalent. So the stabilizer `u56' is not maximal. Let us
try to find its supergroups. We use the function `Blocks' to find a block
system. The  (optional) third  argument  in the following   example tells
`Blocks' that we want a block system where 1 and 10 lie in one block.
\beginexample
    gap> blocks := Blocks( a8_56, [1..56], [1,10] );
    [ [ 1, 10, 17, 20, 25, 33, 38 ], [ 2, 5, 6, 12, 14, 24, 36 ], 
      [ 3, 7, 15, 32, 37, 44, 48 ], [ 4, 8, 13, 23, 26, 35, 47 ], 
      [ 9, 16, 27, 28, 40, 52, 54 ], [ 11, 18, 21, 29, 39, 46, 53 ], 
      [ 19, 30, 41, 42, 49, 50, 55 ], [ 22, 31, 34, 43, 45, 51, 56 ] ]
\endexample
The result is a list  of sets, such that  `a8_56' operates on those sets.
Now we would like  the stabilizer of this  operation on the sets. Because
we  wanted to operate on   the sets we  have  to  pass `OnSets' as  third
argument.
\beginexample
    gap> u8_56 := Stabilizer( a8_56, blocks[1], OnSets );;
    gap> Index( a8_56, u8_56 );
    8
    gap> u8b := PreImages( h56, u8_56 );; Index( a8, u8b );
    8
    gap> u8 = u8b;
    false
\endexample
Here  is a *warning*:   If you specify `OnSets'  as  third argument  to a
function like  `Stabilizer', you have to  make sure that the  point (i.e.
the second argument) is  indeed a set. Otherwise you  will get a puzzling
error message or  even  wrong results! In  the above  example, the second
argument  `blocks[1]'  came from the  function  `Blocks', which returns a
list of sets, so everything was OK.

Actually there  is a third  block system of `a8_56'  that gives rise to a
third subgroup.
\beginexample
    gap> blocks := Blocks( a8_56, [1..56], [1,6] );;
    gap> u28_56 := Stabilizer( a8_56, [1,6], OnSets );;
    gap> u28 := PreImages( h56, u28_56 );;
    gap> Index( a8, u28 );
    28 
\endexample
We know that  the subgroup `u28' of index  28 is maximal, because we know
that  `a8' has no  subgroups  of index 2,  4,  or 7.  However we can also
quickly verify this by checking  that `a8_56' operates primitively on the
28 blocks.
\beginexample
    gap> IsPrimitive( a8_56, blocks, OnSets );
    true 
\endexample

`Stabilizer' is not only applicable to groups like `a8' but also to their
subgroups like  `u56'. So another  method  to find  a  new subgroup is to
compute the stabilizer of another point in `u56'. Note that `u56' already
leaves 1 and 2 fixed.
\beginexample
    gap> u336 := Stabilizer( u56, 3 );;
    gap> Index( a8, u336 );
    336 
\endexample
Other  functions  are also applicable  to  subgroups. In the following we
show that  `u336' operates regularly on the  60~triples of `[4..8]' which
contain no element twice. We  constuct the list  of these 60~triples with
the function `Orbit' (using `OnTuples'  as the natural generalization  of
`OnPairs')  and   then  pass it   as  operation domain  to   the function
`IsRegular'.  The positive result of  the regularity test means that this
operation is equivalent  to the operations of `u336'  on  its 60 elements
from the right.
\beginexample
    gap> IsRegular( u336, Orbit( u336, [4,5,6], OnTuples ), OnTuples );
    true 
\endexample
Just as we did in the  case of the  operation on the  pairs above, we now
construct a new permutation group that operates on `[1..336]' in the same
way that `a8' operates on the cosets of `u336'. But this time we let `a8'
operate  on a right   transversal, just like  `norm'  did in  the natural
homomorphism above.
\beginexample
    gap> t := RightTransversal( a8, u336 );;
    gap> a8_336 := Operation( a8, t, OnRight );;
\endexample
To find  subgroups above  `u336'  we  again  check if  the  operation  is
primitive.
\beginexample
    gap> blocks := Blocks( a8_336, [1..336], [1,43] );; blocks[1];
    [ 1, 43, 85 ]
\endexample
The subgroup of index  112 in `a8_336'  is  the union of `u336'  with its
43rd and its  85th coset.   It  is thus   the  closure of `u336' with   a
representative of the  43rd coset, which  is obtained as the 43rd element
of the transversal~`t'.
\beginexample
    gap> u112 := ClosureGroup( u336, t[43] );;
    gap> Index( a8, u112 );
    112 
\endexample
Above this subgroup of index 112 lies a  subgroup  of index 56, which  is
not conjugate to `u56'.  In fact, unlike `u56' it is  maximal.  We obtain
this subgroup in  the same way that we obtained `u112', this time forcing
two points, namely 39 and 43 into the first block.
\beginexample
    gap> blocks := Blocks( a8_336, [1..336], [1,39,43] );;
    gap> Length( blocks );
    56
    gap> u56b := ClosureGroup( u112, t[39] );; Index( a8, u56b );
    56
    gap> IsPrimitive( a8_336, blocks, OnSets );
    true 
\endexample
We  already mentioned  in the beginning   that there is another  standard
operation of permutations, namely the  conjugation. E.g., since no  other
operation is specified  in the  following example, `OrbitLength'   simply
operates via `OnPoints', and because `$<perm>_1$ ^ $<perm>_2$' is defined
as the conjugation  of  $perm_2$ on $perm_1$  we  effectively compute the
length of the conjugacy class of `(1,2)(3,4)(5,6)(7,8)'. (The length of a
conjugacy class of any  element <elm> in an  arbitrary  group <G>  can be
computed as `OrbitLength( <G>, <elm> )'. In general  however this may not
be a good idea, `Size(  ConjugacyClass( <G>, <elm> )  )' is probably more
efficient.)
\beginexample
    gap> OrbitLength( a8, (1,2)(3,4)(5,6)(7,8) );
    105
    gap> orb := Orbit( a8, (1,2)(3,4)(5,6)(7,8) );;
    gap> u105 := Stabilizer( a8, (1,2)(3,4)(5,6)(7,8) );; Index( a8, u105 );
    105 
\endexample
Of course the  last stabilizer is in  fact the centralizer of the element
`(1,2)(3,4)(5,6)(7,8)'.  `Stabilizer' notices    that and computes    the
stabilizer using the centralizer algorithm for permutation groups. In the
usual way we now look for the subgroups above `u105'.
\beginexample
    gap> blocks := Blocks( a8, orb );; Length( blocks );
    15
    gap> blocks[1];
    [ (1,2)(3,4)(5,6)(7,8), (1,3)(2,4)(5,8)(6,7), (1,4)(2,3)(5,7)(6,8),
      (1,5)(2,6)(3,8)(4,7), (1,6)(2,5)(3,7)(4,8), (1,7)(2,8)(3,6)(4,5),
      (1,8)(2,7)(3,5)(4,6) ]
\endexample
To find the subgroup of index 15 we  again use closure. Now  we must be a
little bit  careful to avoid    confusion. `u105' is the  stabilizer   of
`(1,2)(3,4)(5,6)(7,8)'. We  know  that there is  a correspondence between
the  points  of  the   orbit and  the   cosets  of  `u105'.   The   point
`(1,2)(3,4)(5,6)(7,8)' corresponds   to `u105'.  To get  the  subgroup of
index 15 we  must add to `u105' an  element of the coset that corresponds
to the   point `(1,3)(2,4)(5,7)(6,8)' (or any other   point  in the first
block).  That means   that  we must  use  an  element of `a8'  that  maps
`(1,2)(3,4)(5,6)(7,8)' to  `(1,3)(2,4)(5,7)(6,8)'.        The    function
`RepresentativeOperation'   does what we need. It   takes a group and two
points and returns an  element of the group that  maps the first point to
the   second. In fact it   also allows you  to   specify the operation as
optional fourth argument as usual,  but we do  not need this here. If  no
such element exists in the  group, i.e., if the  two points do not lie in
one orbit under the group, `RepresentativeOperation' returns `fail'.
\beginexample
    gap> rep := RepresentativeOperation( a8, (1,2)(3,4)(5,6)(7,8),
    >                                        (1,3)(2,4)(5,7)(6,8) );
    (2,3)(6,7)
    gap> u15 := ClosureGroup( u105, rep );; Index( a8, u15 );
    15 
\endexample
`u15' is of course a maximal  subgroup, because `a8'  has no subgroups of
index 3 or~5.  There is in fact  another  class of subgroups  of index 15
above `u105' that we get by adding `(2,3)(6,8)' to `u105'.
\beginexample
    gap> u15b := ClosureGroup( u105, (2,3)(6,8) );; Index( a8, u15b );
    15 
    gap> RepresentativeOperation( a8, u15, u15b );
    false 
\endexample
`RepresentativeOperation' tells us that  there is no  element <g> in `a8'
such that `u15 ^ <g> = u15b'. Because `^' also denotes the conjugation of
subgroups this tells us  that  `u15' and  `u15b' are not  conjugate.

{\bf  Summary.} In this section we  have demonstrated some functions from
the operations package. There  is a whole class of  functions that we did
not mention, namely  those that take a  single element instead of a whole
group as first argument, e.g., `Cycle' and `Permutation'. These are fully
described   in "ref:Operation  functions!for   groups"  in the  reference
manual.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group homomorphisms!by images}

We   have already  seen  examples of   group homomorphisms  in  the  last
sections,  namely natural homomorphisms  and  operation homomorphisms. In
this section we will show how to construct a  group homomorphism $G\to H$
by specifying a generating set for $G$ and the images of these generators
in~$H$. We use the function `GroupHomomorphismByImages( <G>, <H>, <gens>,
<imgs> )' where <gens> is a  generating set for <G> and  <imgs> is a list
whose $i$th entry is the image of `<gens>[ $i$ ]' under the homomorphism.
\beginexample
    gap> s4 := Group((1,2,3,4),(1,2));; s3 := Group((1,2,3),(1,2));;
    gap> hom := GroupHomomorphismByImages( s4, s3,
    >           GeneratorsOfGroup(s4), [(1,2),(2,3)] );
    [ (1,2,3,4), (1,2) ] -> [ (1,2), (2,3) ]
|_
    gap> Kernel( hom );
    Group( [ (1,2)(3,4), (1,4)(2,3) ], ... )  # the Klein four-group
|_
    gap> Image( hom, (1,2,3) );
    (1,2,3)
    gap> Image( hom, DerivedSubgroup(s4) );
    Group( [ (1,3,2), (1,2,3) ], ... )
|_
    gap> PreImage( hom, (1,2,3) );
    Error <map> must be an inj. and surj. mapping at
    Error( "<map> must be an inj. and surj. mapping" );
    Entering break read-eval-print loop, you can 'quit;' to quit to outer loop,
    or you can return to continue
    brk> quit;
|_
    gap> PreImagesRepresentative( hom, (1,2,3) );
    (2,4,3)
|_
    gap> PreImage( hom, TrivialSubgroup(s3) );
    Group( [ (1,2)(3,4), (1,4)(2,3) ], ... )  # the kernel
\endexample
This homomorphism  from $S_4$ onto  $S_3$  is well known  from elementary
group theory.  Images   of elements and  subgroups  under   `hom' can  be
calculcated with the function `Image'. But since the mapping `hom' is not
bijective, we  cannot use   the   function `PreImage' for  preimages   of
elements  (they can have   several preimages). Instead,   we have  to use
`PreImagesReprentative', which  returns  one  preimage if at    least one
exists (and would  return `fail' if none  exists, which  cannot occur for
our surjective `hom'.)  On the other hand, we  can use `PreImage' for the
preimage of a set (which always exists, even if it  is empty). So far, so
good.  But horrible things  would  have happened  if we  had mistyped the
images in the homomorphism specification.
\beginexample
    gap> hom2 := GroupHomomorphismByImages( s4, s3,
    >            GeneratorsOfGroup(s4), [(1,2,3),(2,3)] );
    [ (1,2,3,4), (1,2) ] -> [ (1,2,3), (2,3) ]
    gap> Size( Kernel(hom2) );
    24
\endexample
In  other  words, {\GAP} claims   that the kernel   is the full `s4', yet
`hom2'  obviously has some non-trivial images!   Reason: There is no such
thing  as a  homomorphism which   maps an   element of order~4   (namely,
(1,2,3,4)) to  an element of order~3 (namely,  (1,2,3)). *But  if you use
the command `GroupHomomorphismByImages', {\GAP} trusts you.*
\beginexample
    gap> IsGroupHomomorphism( hom2 );
    true
\endexample
And then it produces serious nonsense if the thing is not a homomorphism,
as seen above! If you are not sure whether such  a prescription of images
really  defines  a    homomorphism    you    should use  the      command
`GroupGeneralMappingByImages' instead, then  you can test the result with
`IsGroupHomomorphism'.
\beginexample
    gap> hom2 := GroupGeneralMappingByImages( s4, s3,
    >            GeneratorsOfGroup(s4), [(1,2,3),(2,3)] );;
    gap> IsGroupHomomorphism( hom2 );
    false
\endexample

\index{group general mapping}\index{cokernel}\index{kernel}%
\atindex{GroupHomomorphismByImages vs. GroupGeneralMappingByImages}%
{@\noexpand `GroupHomomorphismByImages' vs.\ %
\noexpand `GroupHomomorphismByImages'}%
But the  possibility of testing for being  a homomorphism is not the only
reason  why    {\GAP} offers  *group   general  mappings*.  Another (more
important?) reason is that  their existence allows ``reversal of arrows''
in a  homomorphism such   as  our original  `hom'. By   this we mean  the
`GroupHomomorphismByImages' with left and right sides exchanged, in which
case it is of course merely a `GroupGeneralMappingByImages'.
\beginexample
    gap> rev := GroupGeneralMappingByImages( s3, s4,
    >           [(1,2),(2,3)], GeneratorsOfGroup(s4) );;
\endexample
Now we      have  $a\buildrel  hom\over\longmapsto  b    \iff  b\buildrel
rev\over\longmapsto a$ for $a\in `s4'$ and  $b\in `s3'$. Since every such
$b$ has 4~preimages  under `hom', it now  has 4~images under $a$. Just as
the 4~preimages form a  coset of the kernel $V_4\le  `s4'$ of `hom', they
also form a coset of the *cokernel*  $V_4\le `s4'$ of `rev'. The cokernel
itself is the set of all images of  `One( s3 )' (it  is a normal subgroup
in the group of all images under `rev'). And  this is why {\GAP} wants to
perform such  a  reversal of  arrows:  it calculcates   the  kernel of  a
homomorphism like `hom'  as the  cokernel of  the  reversed group general
mapping (here `rev').
\beginexample
    gap> CoKernel( rev );
    Group( [ (1,4)(2,3), (1,2)(3,4) ], ... )
\endexample
\index{group general mapping!single-valued}%
\index{group general mapping!total}%
The  reason  why  `rev'   is not  a    homomorphism is  that   it is  not
single-valued  (because `hom' was   not injective). But there  is another
critical  condition: If   we   reverse the arrows   of  a  non-surjective
homomorphism,  we  obtain a group  general mapping  which  is not defined
everywhere, i.e.,  which is not total  (although it will be single-valued
if the original homomorphism is  injective). {\GAP} requires that a group
homomorphism be  both  single-valued  and total,  so  you will   run into
difficulties if you   say `GroupHomomorphismByImages( <G>,   <H>, <gens>,
<imgs> )' where <gens> does not generate <G> (even if this gives a decent
homomorphism  on   the subgroup   generated   by   <gens>).  For  a  full
description, see "ref:Homomorphisms!for groups" in the reference manual.

The last  example of this   section shows that  the  notion of kernel and
cokernel naturally extends even to the case  where neither `hom2' nor its
inverse general mapping (with arrows reversed) is a homomorphism.
\beginexample
    gap> CoKernel( hom2 );  Kernel( hom2 );
    Group( [ (2,3), (1,3,2) ], ... )
    Group( [ (3,4), (2,4,3), (1,2)(3,4) ], ... )
|_
    gap> IsGroupHomomorphism( InverseGeneralMapping( hom2 ) );
    false
\endexample

{\bf  Summary.}   In this section   we  have constructed homomorphisms by
specifying images for a set of generators. We have seen that by reversing
the direction of  the mapping, we get  group general mappings, which need
not be single-valued (unless the mapping was injective) nor total (unless
the mapping was surjective).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Nice monomorphisms}

In this  section we will construct  a matrix group   of degree~2 over the
Gaussian  rationals. Because    the  group of   all  invertible  $2\times
2$-matrices over this  field is infinite, {\GAP}  cannot be sure from the
beginning that our group is finite, even though *we*  know that it is the
quaternion group of order~8, hence finite. To investigate it, we will try
to construct a monomorphism of the matrix group into a permutation group,
which is much nicer to  work with. The  image of this *nice monomorphism*
is then  isomorphic to our matrix group,  and we can perform calculations
in the nice group and lift the results back  to the matrix group with the
nice monomorphism. (The  imaginary root of $-1$  is obtained as `E(4)', a
4th root of unity.)
\beginexample
    gap> i := E(4);; grp := Group([[i,0],[0,-i]],[[0,1],[-1,0]]);;
    gap> SetName( grp, "Q8" );
    gap> orb := Union( Orbits( grp, [ [1,0], [0,1] ] ) );
    [ [ 1, 0 ], [ E(4), 0 ], [ 0, 1 ], [ -1, 0 ], [ 0, E(4) ],
        [ 0, -E(4) ], [ -E(4), 0 ], [ 0, -1 ] ]
\endexample
The list `orb' is the union of orbits  under `grp' which contains a basis
for  the two-dimensional row vector  space  over the rationals. Therefore
the action on `orb' is  faithful on 8~points, and  hence `grp' is finite.
We  have made use here  of the possibility to  call  `Orbits' with a list
that is  not closed  under  the operation:  it  will be  replaced by  the
closure  on which the  orbits are then determined  (in our case, there is
only one orbit).
\beginexample
    gap> hom := OperationHomomorphism( grp, orb );; IsInjective( hom );
    true
    gap> p := Image( hom );
    Group( [ (1,7,6,8)(2,5,3,4), (1,2,6,3)(4,8,5,7) ], ... )
\endexample
To  demonstrate the technique  of   nice  monomorphisms, we  compute  the
conjugacy classes of the  permutation group and  lift them back into  the
matrix group with the monomorphism `hom'. Lifting  back a conjugacy class
means finding the preimage of  the representative and of the centralizer;
the latter  is   called  `StabilizerOfExternalSet'   in {\GAP}   (because
conjugacy  classes are represented as   external sets, see "ref:Conjugacy
classes!for groups" in the reference manual).
\beginexample
    gap> pcls := ConjugacyClasses( p );; gcls := [  ];;
    gap> for pc  in pcls  do
    >      gc := ConjugacyClass(grp,PreImageElm(hom,Representative(pc)));
    >      SetStabilizerOfExternalSet(gc,PreImage(hom,
    >                                 StabilizerOfExternalSet(pc)));
    >      Add( gcls, gc );
    >    od; List( gcls, Size );
    [ 1, 1, 2, 2, 2 ]
\endexample
All the steps we have made above are automatically performed by {\GAP} if
you  simply ask for `ConjugacyClasses(   grp   )', provided that   {\GAP}
already knows  that `grp' is finite, e.g.,  because  you asked `IsFinite(
grp  )' before. The reason  for this is that  a  finite matrix group like
`grp' is ``handled by a nice monomorphism''. For such groups, {\GAP} uses
the command `NiceMonomorphism' to construct a monomorphism like `hom' and
then proceeds as we have done above.
\beginexample
    gap> grp := Group([[i,0],[0,-i]],[[0,1],[-1,0]]);;
    gap> IsHandledByNiceMonomorphism( grp );
    false
|_
    gap> IsFinite( grp );
    true
    gap> IsHandledByNiceMonomorphism( grp );
    true
|_
    gap> hom := NiceMonomorphism( grp );
    <operation homomorphism>
    gap> UnderlyingExternalSet( hom ); p := Image( hom );
    [ [ 1, 0 ], [ 0, 1 ], [ E(4), 0 ], [ 0, -E(4) ], [ -1, 0 ],
      [ 0, E(4) ], [ 0, -1 ], [ -E(4), 0 ] ]
    Group( [ (1,3,5,8)(2,4,7,6), (1,2,5,7)(3,6,8,4) ], ... )
|_
    gap> ConjugacyClasses( grp ) = gcls;
    true
\endexample

\exercise (To be done after you know  about methods and method selection,
see Chapter~"Attributes and their Methods".)  Study the {\GAP} library to
find out how the finiteness of `grp' was determined in the above example.

\answer `IsFinite' delegates to  `Size' which delegates  to `Enumerator'.
This  operation finally constructs    a list of  all  group   elements by
repeated calls of   `ClosureGroupDefault', which effectively performs  an
orbit algorithm for the group acting on itself via right multiplication.

Nice monomorphisms are  not  only used  for matrix groups,  but  also for
other kinds  of groups in  which one cannot   calculate easily enough. As
another  example,   let us   show that  the    automorphism group of  the
quaternion group  of  order~8 is isomorphic  to  the  symmetric  group of
degree~4   by examining    the  ``nice   object'' associated  with   that
automorphism group.
\beginexample
    gap> aut := AutomorphismGroup( p );; niceaut := NiceObject( aut );
    Group( [ (1,5)(3,4), (2,6)(3,4), (1,3,5,4), (1,2)(3,4)(5,6) ], ... )
    gap> IsomorphismGroups( niceaut, SymmetricGroup( 4 ) );
    [ (1,5)(3,4), (2,6)(3,4), (1,3,5,4), (1,2)(3,4)(5,6) ] -> 
    [ (1,4)(2,3), (1,2)(3,4), (1,3,4,2), (2,4) ]
\endexample

\exercise The nice monomorphism associated with the automorphism group of
`p' is an operation homomorphism. What is its underlying external set?

\answer `UnderlyingExternalSet( NiceMonomorphism( aut ) )' gives the list
\begintt|nobreak
    [ (1,2,5,7)(3,6,8,4), (1,3,5,8)(2,4,7,6), (1,4,5,6)(2,8,7,3), 
      (1,6,5,4)(2,3,7,8), (1,7,5,2)(3,4,8,6), (1,8,5,3)(2,6,7,4) ]
\endtt
which contains the six elements of order~4 in `p'. The automorphism group
must permute  these elements,  and the  action  is faithful because  they
generate~`p'.

The range of  a nice monomorphism is  in most cases a permutation  group,
because  nice monomorphisms  are mostly operation  homomorphisms. In some
cases,  like in  our last example,  the  group is solvable  and you might
prefer a pc group as nice object. You cannot change the nice monomorphism
of  the automorphism  group (because it  is   the value  of the attribute
`NiceMonomorphism'), but you can compose  it with an isomorphism from the
permutation  group to  a  pc   group  to   obtain your  personal    nicer
monomorphism. If  you reconstruct  the automorphism  group,  you can even
prescribe it this nicer monomorphism as its `NiceMonomorphism', because a
newly-constructed group will not yet have a `NiceMonomorphism' set.
\beginexample
    gap> nicer := NiceMonomorphism(aut) * IsomorphismPcGroup(niceaut);;
    gap> aut2 := GroupByGenerators( GeneratorsOfGroup( aut ) );;
    gap> SetIsHandledByNiceMonomorphism( aut2, true );
    gap> SetNiceMonomorphism( aut2, nicer );
    gap> NiceObject( aut2 );
    Group( [ f4, f3, f1*f4, f2^2*f4 ], ... )  # a pc group
\endexample
The star `*' denotes composition of mappings  from the left to the right,
as we  have  seen in  "Operations!of  groups" above.   Reconstructing the
automorphism group may of course result in the  loss of other information
{\GAP} had already gathered, besides the (not-so-)nice monomorphism.

\exercise In  analogy to `IsomorphismPcGroup',  there is also the command
`IsomorphismPermGroup'.  Continuing the  first  example  of this section,
what  is the  difference    between  `IsomorphismPermGroup( grp )'    and
`NiceMonomorphism( grp )'?

\answer `IsomorphismPermGroup( grp  )'  returns a bijective   mapping, in
particular its  `Range' is a permutation  group of size~8, whereas a nice
monomorphism  which  is an operation homomorphism   has as `Range' a full
symmetric group. Also a  nice monomorphism could  be defined on a  larger
group. This is   not   the case in   the   example `grp', but   the  nice
monomorphism of a $d$-dimensional matrix group over the finite field with
$q$ elements is defined on the general linear group~$GL(d,q)$.

{\bf Summary.}  In this section we have  seen  how calculations in groups
can be carried  out in isomorphic  images in  nicer groups. We  have seen
that {\GAP}  pursues this technique  automatically for certain classes of
groups, e.g., for matrix groups that are known to be finite.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local Variables:
% mode:               text
% mode:               outline-minor
% outline-regexp:     "\\\\Chapter\\|\\\\Section\\|\\\\stars"
% paragraph-start:    "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% paragraph-separate: "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% fill-column:        73
% End:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E  group.tex . . . . . . . . . . . . . . . . . . . . . . . . . ends here
