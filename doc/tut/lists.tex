%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  lists.tex                 GAP documentation             Thomas Breuer
%W                                                         & Frank Celler
%W                                                     & Martin Schoenert
%W                                                       & Heiko Theissen
%%
%H  @(#)$Id$
%%
%Y  Copyright 1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,   Germany
%%
%%  This file contains a tutorial introduction to lists and records.
%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Lists and Records}

Modern mathematics, especially algebra, is based on set theory. When sets
are represented in a computer, they inadvertently turn into lists. That's
why we start our  survey of the various  objects {\GAP} can handle with a
description of  lists  and their  manipulation. {\GAP}  regards sets as a
special kind of lists, namely as lists without  holes or duplicates whose
entries are ordered with respect to the precedence relation~`\<'.

After  the introduction of  the basic  manipulations with lists in~"Plain
Lists", some difficulties concerning identity and mutability of lists are
discussed  in~"Identical Lists"  and~"Immutability".  Sets,  ranges, row
vectors, and matrices are introduced as special kinds of lists in~"Sets",
"Ranges", "Vectors and Matrices".   Handy list   operations are
shown in~"List Operations". Finally we explain how to use records
in~"Plain Records". 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Plain Lists}

\atindex{lists!plain}{|indexit}%
A *list* is a collection of objects separated by  commas and enclosed  in
brackets.  Let us for example construct the list `primes' of the first 10
prime numbers.
\beginexample
    gap> primes:= [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
    [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ]
\endexample
The next two primes are  31 and 37.  They may be appended to the existing
list by the function `Append' which takes  the existing list as its first
and another list as a second argument.  The  second argument  is appended
to the list `primes' and  no  value is returned.  Note that  by appending
another list the object `primes' is changed.
\beginexample
    gap> Append(primes, [31, 37]);
    gap> primes;
    [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37 ] 
\endexample
You can as well add single new elements to existing lists by the function
`Add'  which takes  the existing list  as its  first argument  and  a new
element as  its second argument.  The  new  element  is added to the list
`primes' and again no value is returned but the list `primes' is changed.
\beginexample
    gap> Add(primes, 41);
    gap> primes;
    [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41 ] 
\endexample
Single elements of a list are referred to by their position in the  list.
To get the value  of the seventh prime, that is the seventh entry in  our
list `primes', you simply type
\beginexample
    gap> primes[7];
    17 
\endexample
This value can be handled like any other value, for example multiplied by
2 or assigned to a  variable. On the other hand  this mechanism allows to
assign a value to  a position in  a  list. So the   next prime 43  may be
inserted  in the   list directly  after the  last   occupied position  of
`primes'. This  last occupied    position  is returned  by  the  function
`Length'.
\beginexample
    gap> Length(primes);
    13
    gap> primes[14]:= 43;
    43
    gap> primes;
    [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43 ] 
\endexample
Note that this operation again has changed the object `primes'.  Not only
the next position of a list is capable  of taking  a  new  value.  If you
know that 71 is the 20th prime, you can as well enter it right now in the
20th position of `primes'.   This  will result in a list with holes which
is however still a list and has length 20 now.
\beginexample
    gap> primes[20]:= 71;
    71
    gap> primes;
    [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,,,,,, 71 ]
    gap> Length(primes);
    20 
\endexample
The list itself however must  exist before a  value can be  assigned to a
position of the list.  This list may be the empty list `[ ]'.
\beginexample
    gap> lll[1]:= 2;
    Variable: 'lll' must have a value
    gap> lll:= []; lll[1]:= 2;
    [  ]
    2 
\endexample
Of course  existing entries of a list  can be  changed by this mechanism,
too. We will not do it here because `primes' then may no longer be a list
of primes. Try for yourself to change the 17 in the list into a 9.

To get the position    of 17 in  the   list  `primes' use   the  function
`Position' which takes the list as its  first argument and the element as
its second argument  and returns the position of  the first occurrence of
the element 17 in the list `primes'. `Position' will return `fail' if the
element is not contained in the list.
\beginexample
    gap> Position(primes, 17);
    7
    gap> Position(primes, 20);
    fail
\endexample
In  all  of the  above changes to  the  list `primes',  the list has been
automatically resized.  There  is no need  for you to tell {\GAP} how big
you want a list to be.  This is all done dynamically.

It is not necessary for the objects collected in a list to be of the same
type.
\beginexample
    gap> lll:= [true, "This is a String",,, 3];
    [ true, "This is a String",,, 3 ] 
\endexample
In the same way a list may be part of another  list.  A list  may even be
part of itself.
\beginexample
    gap> lll[3]:= [4,5,6];; lll;
    [ true, "This is a String", [ 4, 5, 6 ],, 3 ]
    gap> lll[4]:= lll;
    [ true, "This is a String", [ 4, 5, 6 ], ~, 3 ] 
\endexample
Now the tilde in the fourth position of `lll'  denotes the object that is
currently  printed. Note that  the result  of the  last operation is  the
actual value  of  the  object  `lll'   on  the  right  hand side  of  the
assignment. But in  fact it is  identical to the value  of the whole list
`lll' on the left hand side of the assignment.

\index{strings}\index{lists!dense}%
A *string*  is a very  special   type of  list,  which  is  printed in  a
different way.  A string  is simply  a  dense list of   characters, where
*dense* means  that the list  has no holes.   Strings are used  mainly in
filenames and   error messages. A  string  literal can either  be entered
simply as the  list of characters  or  by writing the characters  between
doublequotes `\"'.
\beginexample
    gap> s1 := ['H','a','l','l','o',' ','w','o','r','l','d','.'];
    "Hallo world."
    gap> s1 = "Hallo world.";
    true
    gap> s1[7];
    'w' 
\endexample

\exercise True or false: A dense list of  characters is always printed as
a string by {\GAP}, i.e., between doublequotes, not in square brackets.

\answer False, the  empty list  is a string,   but  it is either   always
printed `[ ]' or always `\"\"', depending on how it was entered. Also the
automatic conversion   into strings  takes   place  only on  the  ``outer
level'', not for lists inside lists.

Sublists of lists can easily be extracted and assigned using the operator
`<list>\{ <positions> \}'.
\beginexample
    gap> sl := lll{ [ 1, 2, 3 ] };
    [ true, "This is a String", [ 4, 5, 6 ] ]
    gap> sl{ [ 2, 3 ] } := [ "New String", false ];
    [ "New String", false ]
    gap> sl;
    [ true, "New String", false ] 
\endexample
This way you get  a new list that  contains at position <i> that  element
whose position is the <i>th entry of the argument in the curly braces.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Identical Lists}

\atindex{lists!identical}{|indexit}%
This second  section  about lists is dedicated  to  the subtle difference
between  *equality*  and *identity*  of lists. It is really important to
understand   this  difference in  order   to  understand how complex data
structures are  realized in {\GAP}.   This section applies  to all {\GAP}
objects  that have  subobjects,  e.g.,  to lists   and to  records. After
reading the section about records~"Plain Records" you should return to
this section and translate it into the record context.

Two  lists are *equal* if all their entries are equal.  This means that the
equality operator `=' returns `true' for the  comparison of  two lists if
and  only if these two lists are of the same length and for each position
the values in the respective lists are equal.
\beginexample
    gap> numbers := primes;; numbers = primes;
    true 
\endexample
We assigned  the  list `primes' to the variable  `numbers' and, of course
they are equal as they have  both  the same length  and the same entries.
Now we  will change the  third number to  4 and  compare the result again
with `primes'.
\beginexample
    gap> numbers[3]:= 4;; numbers = primes;
    true 
\endexample
You  see that  `numbers' and  `primes'  are still   equal, check this  by
printing the value of `primes'. The list `primes' is  no longer a list of
primes! What has  happened?  The truth is  that  the  lists  `primes' and
`numbers' are  not only equal but they are also *identical*. `primes' and
`numbers' are two variables pointing to the  same list. If you change the
value of  the subobject `numbers[3]'  of `numbers' this will  also change
`primes'.  Variables do *not* point to  a certain block of storage memory
but they do  point  to an object that  occupies  storage memory.   So the
assignment `numbers := primes' did *not* create a new list in a different
place of memory but only created the new name `numbers'  for the same old
list of primes.

From this we see that *the same object can have several names.*

If you want to change a list with the  contents of `primes' independently
from `primes'  you will have to  make a copy of  `primes' by the function
`ShallowCopy' which takes an object as its argument and returns a copy of
the argument. (We will first restore the old value of `primes'.)
\beginexample
    gap> primes[3]:= 5;; primes;
    [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,,,,,, 71 ]
    gap> numbers:= ShallowCopy(primes);; numbers = primes;
    true
    gap> numbers[3]:= 4;; numbers = primes;
    false 
\endexample
Now `numbers' is no longer equal to `primes' and `primes' still is a list
of primes.  Check this by printing the values of `numbers' and `primes'.

Lists and records can be changed this way because {\GAP} objects of these
types have subobjects.
To clarify this statement consider the following example.
\beginexample
    gap> i:= 1;; j:= i;; i:= i+1;; 
\endexample
By adding 1 to `i' the value of `i' has  changed.   What  happens to `j'?
After the second statement `j' points to the same object  as `i',  namely
to the  integer 1.  The  addition  does *not* change  the object `1'  but
creates a new object according  to the instruction `i+1'.  It is actually
the assignment that changes the value of `i'.  Therefore `j' still points
to  the object `1'.  Integers  (like permutations and  booleans)  have no
subobjects.  Objects  of these types  cannot  be  changed but can only be
replaced by other objects.   And a replacement does not change the values
of other variables.  In the above example an assignment of a new value to
the variable `numbers' would also not change the value of `primes'.

Finally try the following examples and explain the results.
\beginexample
    gap> l:= [];; l:= [l];
    [ [  ] ]
    gap> l[1]:= l;
    [ ~ ]
\endexample
Now return to Section~"Plain Lists" and find out whether the functions
`Add' and `Append' change their arguments.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Immutability}

{\GAP} has a mechanism that protects lists against  changes like the ones
that have bothered   us in    Section~"Identical Lists". The     function
`Immutable' takes as argument a list and returns an immutable copy of it,
i.e., a list  which  looks exactly like the   old one, but has  two extra
properties:
(1)~The new list is immutable, i.e.,  the list itself and its subobjects 
    cannot be changed.
(2)~In constructing the copy, every part of  the list that can be changed
    has been copied, so that changes to the  old list will not affect the
    new one.  In other words, the new  list has no  mutable subobjects in
    common with the old list.
\begintt
    gap> list := [ 1, 2, "three", [ 4 ] ];; copy := Immutable( list );;
    gap> list[3][5] := 'w';; list; copy;
    [ 1, 2, "threw", [ 4 ] ]
    [ 1, 2, "three", [ 4 ] ]
    gap> copy[3][5] := 'w';
    Lists Assignment: <list> must be a mutable list
    Entering break read-eval-print loop, you can 'quit;' to quit to outer \
    loop,
    or you can return and ignore the assignment to continue
    brk> quit;
\endtt
As a consequence of  these rules, in the  immutable copy of a list  which
contains an already immutable list as subobject, this immutable subobject
need not be copied,  because it is unchangeable. This is the idea  behind
`Immutable': it produces lists that are unchangeable. Such lists are
useful in many complex {\GAP} objects,  for example as generator lists of
groups. By  making them immutable, {\GAP}  ensures that no generators can
be added to the list, removed or exchanged. Such  changes would of course
lead  to serious inconsistencies with  other  knowledge that may already
have been calculcated for the group.

A converse function to `Immutable' is `ShallowCopy', which produces a new
mutable list  whose $i$th entry  is the $i$th entry of  the old list. The
single  entries  are not copied,  they are  just placed in  the new list.
That's why the  result is called a ``shallow  copy''. If the  old list is
immutable, and hence  the  list  entries  are immutable themselves,   the
result of `ShallowCopy' is mutable only at the top.

\indextt{StructuralCopy}%
\exercise How can  you produce  a  mutable ``deep copy'' of  an immutable
list?

\answer `StructuralCopy( list )' will copy `list' only as deep  as  it is
mutable, hence it will not copy an immutable list at all.  So you have to
iterate the effect  of `ShallowCopy', e.g.,  with the following recursive
function:
\begintt
    DeepCopy := function( old )
    local   new,  entry;
        new := [  ];  for entry  in old  do
        if IsList( entry )  then  Add( new, DeepCopy( entry ) );
                            else  Add( new, entry );  fi;  od;
        return new;
    end;
\endtt
This works only if the original list  does not contain the same subobject
(up to `IsIdenticalObj', see Section~"Objects vs. Elements") twice.
For example, the list which {\GAP} prints as `[ ~ ]' will cause this
function to recurse infinitely.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sets}

\index{lists!strictly sorted}\index{family}%
{\GAP} knows several special kinds of lists. A  very important one is the
*set*, which is a  dense list (i.e., without  holes) all of whose entries
belong to the same  *family*. (For elements to belong to the same family 
roughly means that they 
can be compared using the `\<' operator.) The crucial property of a set 
is that its  entries must  be strictly   sorted, i.e.,   entries in higher
positions   must be greater  with respect  to~`\<'. In  particular, a set
cannot have duplicates. {\GAP} calls a  set also a *strictly sorted list*
and the function `IsSSortedList' tests whether a given  list is a set. It
returns  a boolean value.  For any  list contained  in  one family  there
exists  a    corresponding set containing  the   same  elements (ignoring
repetitions).
This set is constructed by the function `Set' which takes the
list as  its argument   and returns a   set  obtained from this   list by
ignoring holes and duplicates and by sorting the elements.

The  elements  of  the  sets used  in  the  examples of this  section are
strings.
\beginexample
    gap> fruits:= ["apple", "strawberry", "cherry", "plum"];
    [ "apple", "strawberry", "cherry", "plum" ]
    gap> IsSSortedList(fruits);
    false
    gap> fruits:= Set(fruits);
    [ "apple", "cherry", "plum", "strawberry" ] 
\endexample
Note  that the  original list `fruits'  is not  changed  by the  function
`Set'.
It produces a new list which we have to assign to the variable `fruits'
in order to make it a set.

The `in' operator is  used  to test whether an  object is an element of a
set.  It returns a boolean value `true' or `false'.
\beginexample
    gap> "apple" in fruits;
    true
    gap> "banana" in fruits;
    false 
\endexample
The `in' operator may as well be applied to ordinary lists. It is however
much faster to perform  a membership test for sets  since sets are always
sorted and a binary  search can be used instead  of a linear search.  New
elements may be added to a  set by the function  `AddSet' which takes the
set `fruits' as its first argument and an  element as its second argument
and adds the element to the set if it wasn't already there. Note that the
object `fruits' is changed.
\beginexample
    gap> AddSet(fruits, "banana");
    gap> fruits;  #  The banana is inserted in the right place.
    [ "apple", "banana", "cherry", "plum", "strawberry" ]
    gap> AddSet(fruits, "apple");
    gap> fruits;  #  {\tt fruits} has not changed.
    [ "apple", "banana", "cherry", "plum", "strawberry" ] 
\endexample
Sets can be intersected by the function `Intersection'  and united by the
function `Union' which both take  two sets as their arguments  and return
the intersection resp. union of the two sets as a new object.
\beginexample
    gap> breakfast:= ["tea", "apple", "egg"];
    [ "tea", "apple", "egg" ]
    gap> Intersection(breakfast, fruits);
    [ "apple" ] 
\endexample
The arguments of the functions `Intersection' and `Union'  may as well be
ordinary lists,  while  their result is  always  a set. Note that  in the
preceding example at least one argument of  `Intersection' was not a set.
The functions `IntersectSet'  and `UniteSet'  also form the  intersection
resp.~union  of  two sets. They  will  however not return  the result but
change their first argument to be the result. Try them carefully.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Ranges}

A *range* is a finite arithmetic progression of integers. This is another
special kind   of list. A range  is  described by its minimum  (the first
entry), its second entry and its maximum, separated  by a comma respectively
two dots and enclosed in brackets. In the usual case of an ascending list of
consecutive integers the second entry may be omitted.
\beginexample
    gap> [1..999999];     #  a range of almost a million numbers
    [ 1 .. 999999 ]
    gap> [1, 2..999999];  #  this is equivalent
    [ 1 .. 999999 ]
    gap> [1, 3..999999];  #  here the step is 2
    [ 1, 3 .. 999999 ]
    gap> Length( last );
    500000
    gap> [ 999999, 999997 .. 1 ];
    [ 999999, 999997 .. 1 ]
\endexample
This compact printed representation of a fairly long  list corresponds to
a  compact internal representation.  The function `IsRange' tests whether
an object is a range.
%  If this is true for a list but the list is not yet
%represented in the compact form of a range this will be done then.
\beginexample
    gap> a:= [-2,-1,0,1,2,3,4,5];
    [ -2, -1, 0, 1, 2, 3, 4, 5 ]
    gap> IsRange(a);
    true
    gap> a = [ -2 .. 5 ];
    true
\endexample
% Note that this  change of representation does  *not* change the  value of
% the list `a'. The list `a'  still behaves in any context  in the same way
% as it would have in the long representation.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{List Operations}

There is however a more comfortable way to  compute the product of a list
of numbers or permutations.
\beginexample
    gap> Product([1..15]);
    1307674368000
    gap> Product(pp);
    (1,8,4,2,3,6,5) 
\endexample
The function  `Product'  takes a  list as  its argument and computes  the
product  of  the  elements  of the  list.   This  is possible whenever  a
multiplication of  the elements of the list is defined.  So  `Product' 
executes a loop over all elements of the list.

There are other often used loops available as functions.   Guess what the
function `Sum' does.  The function `List' may  take a list and a function
as its arguments.  It will then apply the function to each element of the
list  and return  the corresponding list of results.   A list of cubes is
produced as follows with the function `cubed' from Section~"Functions".
\beginexample
    gap> cubed:= x -> x^3;;
    gap> List([2..10], cubed);
    [ 8, 27, 64, 125, 216, 343, 512, 729, 1000 ] 
\endexample
To add all these cubes  we might apply the  function  `Sum' to  the  last
list.  But we may  as well  give the  function  `cubed' to  `Sum'  as  an
additional argument.
\beginexample
    gap> Sum(last) = Sum([2..10], cubed);
    true 
\endexample
The  primes less than 30 can  be retrieved out  of the list `primes' from
Section~"Plain Lists" by the function `Filtered'. This function takes the
list `primes' and a property as its arguments and will return the list of
those elements of `primes' which have this property. Such a property will
be represented  by  a function  that  returns  a boolean  value. In  this
example the property  of  being less than  30 can be represented  by  the
function `x  -> x \<   30' since `x \<   30' will evaluate to `true'  for
values `x' less than 30 and to `false' otherwise.
\beginexample
    gap> Filtered(primes, x-> x < 30);
    [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ] 
\endexample
We have already  mentioned the operator `\{  \}' that  forms sublists. It
takes a  list of positions  as its argument  and will return  the list of
elements from the original list corresponding to these positions.
\beginexample
    gap> primes{ [1 .. 10] };
    [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ] 
\endexample

Finally we mention the function `ForAll' that checks whether a property
holds for all elements of a list. It takes as its arguments  a list and a 
function that returns a boolean value. `ForAll' checks whether the
function returns `true' for all elements of the list.

\beginexample
    gap> list:= [ 1, 2, 3, 4 ];;
    gap> ForAll( list, x -> x > 0 );
    true
\endexample

 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Vectors and Matrices}

\index{vectors!row}\index{matrices}%
This section describes how {\GAP} uses lists to represent row vectors and
matrices. A *row vector* is a dense list of elements from a common field.
A *matrix* is a dense list of row vectors over a common field and of
equal length.
\beginexample
    gap> v:= [3, 6, 2, 5/2];;  IsRowVector(v);
    true
\endexample
Row vectors  may be  added and multiplied   by scalars from  their field.
Multiplication of   row vectors of  equal length  results in their scalar
product.
\beginexample
    gap> 2 * v;  v * 1/3;  v * v;
    [ 6, 12, 4, 5 ]
    [ 1, 2, 2/3, 5/6 ]
    # the scalar product of `v' with itself
    221/4
\endexample
Note  that   the expression `v   *  1/3' is   actually evaluated by first
multiplying `v' by 1 (which yields again `v')  and by then dividing by 3.
This  is  also an allowed scalar   operation.  The expression `v/3' would
result in  the same value.

*All  these arithmetical  operations result in immutable vectors*,
regardless of whether the operands were mutable or immutable.
So if you want to produce an immutable list with 100~entries equal to~25,
you can simply say `25  + 0 * [ 1 .. 100 ]',
because ranges are also vectors (over the rationals).

\indextt{ListWithIdenticalEntries}%
\exercise  How can  you produce  a mutable  list  with 100~entries  equal
to~25?

\answer `ShallowCopy( 25 + 0 * [ 1 .. 100 ] )' or `List(  [ 1 .. 100 ], x
->  25 )'. Since such constructions  are frequently needed, {\GAP} offers
you a shortcut: you can simply say `ListWithIdenticalEntries( 100, 25 )'.

A matrix is a dense list of row vectors of equal length.
\beginexample
    gap> m:= [[1,-1, 1],
    >         [2, 0,-1],
    >         [1, 1, 1]];
    [ [ 1, -1, 1 ], [ 2, 0, -1 ], [ 1, 1, 1 ] ]
    gap> m[2][1];
    2
\endexample
Syntactically a matrix is a list of lists. So the number  2 in the second
row  and the first  column of the matrix `m'  is referred to as the first
element of the second element of the list `m' via `m[2][1]'.

A matrix may be multiplied by scalars, row vectors and other matrices.
The row vectors and matrices involved in such a multiplication must
however have suitable dimensions.
\beginexample
    gap> [1, 0, 0, 0] * m;
    Vector *: <right> must have the same length as <left> (4)
    gap> [1, 0, 0] * m;
    [ 1, -1, 1 ]
    gap> m * [1, 0, 0, 0];
    Vector *: <right> must have the same length as <left> (3)
    gap> m * [1, 0, 0];
    [ 1, 2, 1 ]
\endexample
Note that multiplication  of a row vector with  a matrix will result in a
linear combination of the  rows of the  matrix, while multiplication of a
matrix with a row  vector results in  a linear combination of the columns
of the  matrix. In  the latter case  the  row vector is considered   as a
column vector.

A matrix  of integers can  also be multiplied with  a finite field scalar
and vice  versa. Such products result in  a matrix  over the finite field
with the integers mapped into the finite field in the obvious way. Finite
field matrices  are nicer to read when  they are  `Display'ed rather than
`Print'ed. (Here  we write `Z( q )' to denote a  primitive root of the
finite field with `q' elements.)
\beginexample
    gap> Display( m * One( GF(5) ) );
     1 4 1
     2 . 4
     1 1 1
    gap> Display( m^2 * Z(2) + m * Z(4) );
    z = Z(4)
     z^1 z^1 z^2
       1   1 z^2
     z^1 z^1 z^2
\endexample
Submatrices    can  easily     be    extracted  using    the   expression
`<mat>\{<rows>\}\{<columns>\}'. They   can also be  assigned to, provided
the big matrix  is mutable (which  it is not if it  is  the result of  an
arithmetical operation).
\beginexample
    gap> sm := m{ [ 1, 2 ] }{ [ 2, 3 ] };
    [ [ -1, 1 ], [ 0, -1 ] ]
    gap> sm{ [ 1, 2 ] }{ [2] } := [[-2],[0]];;  sm;
    [ [ -1, -2 ], [ 0, 0 ] ]
\endexample
The first curly brackets contain the selection of rows,
the second that of columns.

Matrices appear not only in linear algebra, but also as group elements,
provided they are invertible.
Here we have the opportunity to meet a group-theoretical function,
namely `Order', which computes the order of a group element.
\begintt
    gap> Order( m * One( GF(5) ) );
    8
    gap> Order( m );
    |#I  Order: warning, order of <mat> might be infinite
\endtt
Since the order  of `m' over the  rationals really is  infinite, you will
have to interrupt {\GAP} by  pressing `<ctl>-C' (followed by `<ctl>-D' or
`quit;'  to leave the   break loop). To prove  that  the order of `m'  is
infinite,  we  could look  at  the  minimal  polynomial  of `m'  over the
rationals.
\beginexample
    gap> f:=MinimalPolynomial( Rationals, m );; Factors( f );
    [ -2+x_1, 3+x_1^2 ]
\endexample
`Factors'  returns a list of  irreducible factors  of the polynomial `f'.
The first  irreducible factor $X-2$ reveals   that 2 is an  eigenvalue of
`m', hence its order cannot be finite.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Plain Records}

A record provides another way to  build new data structures.  Like a list
a record is a collection of other  objects.  In a record the elements are
not indexed by numbers but by  names (i.e., identifiers).   An entry in a
record is called a *record component*.

In  this section  you  will see how to  define  and how to  use
records.  Record objects are changed by assignments to record components.

Initially a record is defined as a comma separated list of assignments to
its record components.

\beginexample
    gap> date:= rec(year:= 1997,
    >               month:= "Jul",
    >               day:= 14);
    rec(
      year := 1997,
      month := "Jul",
      day := 14 )
\endexample

The value of a record component is accessible by  the record name and the
record  component name separated   by one dot   as  the record  component
selector.

\beginexample
    gap> date.year;
    1997
\endexample

Assignments to new record components  are possible in  the same way.  The
record is automatically resized to hold the new component.

\beginexample
    gap> date.time:= rec(hour:= 19, minute:= 23, second:= 12);
    rec(
      hour := 19,
      minute := 23,
      second := 12 )
    gap> date;
    rec(
      year := 1997,
      month := "Jul",
      day := 14,
      time := rec(
          hour := 19,
          minute := 23,
          second := 12 ) )
\endexample

Records are objects  that  may be  changed.   An assignment to  a  record
component  changes the original  object.    The remarks made in  Sections
"Identical Lists" and "Immutability" are also true for records.

Sometimes it is interesting to know which  components of a certain record
are  bound.  This information is available  from the function `RecNames',
which  takes a record as  its  argument and  returns  a list of names of
all bound components of this record as a list of strings.

\beginexample
    gap> RecNames(date);
    [ "year", "month", "day", "time" ]
\endexample

\exercise Finally try the following examples and explain the results.
\beginexample
    gap> r:= rec();
    rec(
       )
    gap> r:= rec(r:= r);
    rec(
      r := rec(
           ) )
    gap> r.r:= r;
    rec(
      r := ~ )
\endexample

\answer  The  first  assignment to `r'    creates a  record.   The second
assignment assigns a  new object to `r', namely  a record whose component
`r' contains the old record object created  in the first assignment.  The
last assignment changes the value of the record component `r' and creates
a recursive object.

Now return to Sections "Identical Lists"  and "Immutability" and find out
what these sections mean for records.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Further Reading}\null

% In this chapter you have encountered the fundamental concept of a list.
% You have seen how to construct lists, how to extend them and how to refer
% to single elements of a list.
% Moreover you have seen that lists may contain elements of different
% types, even holes (unbound  entries),
% and that a list may be an entry of itself or of one of its entries.
% 
% You have seen the difference between equal lists and identical lists.
% Since lists are objects that have subobjects, they can be mutable or
% immutable, and mutable lists can be changed.
% Changing an object will change the values of all variables that point to
% that object.
% Be careful, since one object can have several names.
% The function `ShallowCopy' creates a shallow copy of a list which is then
% a new object.
% 
You will find more about lists in Chapter~"ref:Lists",
and more about identical lists in~"ref:Identical Lists".
% 
% You have seen that sets are a special kind of list.
% There are functions to expand sets, intersect or unite sets, and there is
% the membership test with the `in' operator.
Sets are described in more detail in Chapter~"ref:Sets".
% 
% You have seen that finite arithmetic progressions of integers can be
% represented in a compact way as ranges.
Chapter~"ref:Ranges" contains a detailed description of ranges.
% 
A more detailed description of strings is contained in
Chapter~"ref:Strings and Characters".
% 
% You have met row vectors and matrices as special lists,
% and you have seen how to refer to entries of a matrix and how to multiply
% scalars, row vectors, and matrices.
% 
Fields are described in Chapter~"ref:Fields",
some known fields in {\GAP} are described in Chapters~"ref:Rationals",
"ref:Cyclotomics", "ref:Gaussians", "ref:Subfields of Cyclotomic  Fields"
and "ref:Finite Fields".
Row vectors and matrices are described in more detail in chapters
"ref:Row Vectors" and "ref:Matrices".
Vector spaces are described in Chapter~"ref:Vector Spaces",
and further matrix related structures are described in Chapters~
"ref:Matrix Rings" and~"ref:Matrix Groups".
% 
% You have learned how to loop over a list by the `for' loop and how to
% loop with respect to a logical condition with the `while' loop.
% You have seen that even the list in the loop body can be changed.

% 
% You have seen some functions which implement often used `for' loops.
% There are functions like `Product' to form the product of the elements of
% a list.
% The function `List' can apply a function to all elements of a list
% and the function `Filtered' creates a sublist of a given list.
You will find more list operations in Chapter~"ref:Lists".

Records and functions  for records are  described in  detail  in  Chapter
"ref:Records".


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local Variables:
% mode:               text
% mode:               outline-minor
% outline-regexp:     "\\\\Chapter\\|\\\\Section\\|\\\\stars"
% paragraph-start:    "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% paragraph-separate: "\\\\begin\\|\\\\end\\|\\$\\$\\|.*%\\|^$"
% fill-column:        73
% End:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E  lists.tex . . . . . . . . . . . . . . . . . . . . . . . . . ends here

