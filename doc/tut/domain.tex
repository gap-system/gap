%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  domain.tex                GAP documentation             Thomas Breuer
%W                                                         & Frank Celler
%W                                                     & Martin Schoenert
%W                                                       & Heiko Theissen
%%
%H  @(#)$Id$
%%
%Y  Copyright 1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,   Germany
%%
%%  This file contains a tutorial introduction to domains.
%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Domains}

*Domain* is {\GAP}'s name for structured sets.
We already saw examples of domains in Chapters~"Groups and Homomorphisms"
and~"Vector Spaces and Algebras":
the groups `s8' and `a8' in Section~"Permutation groups" are domains,
likewise the field `f' and the vector space `v' in
Section~"Vector Spaces" are domains.
They were constructed by functions such as `Group' and `GF',
and they could be passed as arguments to other functions such as
`DerivedSubgroup' and `Dimension'.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Domains as Sets}

First of all, a domain $D$ is a set.
If $D$ is finite then a list with the elements of this set can be
computed with the functions `AsList' and `AsSortedList'.
For infinite $D$, `Enumerator' and `EnumeratorSorted' may work,
but it is also possible that one gets an error message.

Domains can be used as arguments of set functions such as `Intersection'
and `Union'.
{\GAP} tries to return a domain in these cases,
moreover it tries to return a domain with as much structure as possible.
For example, the intersection of two groups is (either empty or) again a
group, and {\GAP} will try to return it as a group.
For `Union', the situation is different because the union of two groups
is in general not a group.

\beginexample
gap> g:= Group( (1,2), (3,4) );;
gap> h:= Group( (3,4), (5,6) );;
gap> Intersection( g, h );
Group([ (3,4) ])
\endexample

Two domains are regarded as equal w.r.t. the operator ```=''' if and only
if they are equal *as sets*, regardless of the additional structure of the
domains.

\beginexample
gap> mats:= [ [ [ 0*Z(2), Z(2)^0 ], [ Z(2)^0, 0*Z(2) ] ],
>             [ [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ] ] ];;
gap> Ring( mats ) = VectorSpace( GF(2), mats );
true
\endexample

Additionally, a domain is regarded as equal to the sorted list
of its elements.

\beginexample
gap> g:= Group( (1,2) );;
gap> l:= AsSortedList( g );
[ (), (1,2) ]
gap> g = l;
true
gap> IsGroup( l ); IsList( g );
false
false
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Algebraic Structure}

The additional structure of $D$ is constituted by the facts that $D$ is
known to be closed under certain operations such as addition or
multiplication, and that these operations have additional properties.
For example, if $D$ is a group then it is closed under multiplication
($D \times D \rightarrow D$, $(`g',`h') \mapsto `g * h'$),
under taking inverses ($D \rightarrow D$, $`g' \mapsto$ `g^-1')
and under taking the identity `g^0' of each element `g' in $D$;
additionally, the multiplication in $D$ is associative.

The same set of elements can carry different algebraic structures.
For example, a semigroup is defined as being closed under an associative
multiplication, so each group is also a semigroup.
Likewise, a monoid is defined as a semigroup $D$ in which the identity
`g^0' is defined for every element `g', so each group is a monoid,
and each monoid is a semigroup.

Other examples of domains are vector spaces, which are defined as
additive groups that are closed under (left) multiplication with elements
in a certain domain of scalars.
Also conjugacy classes in a group $D$ are domains,
they are closed under the conjugation action of $D$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Notions of Generation}

\indextt{GeneratorsOfSomething}
We have seen that a domain is closed under certain operations.
Usually a domain is constructed as the closure of some elements under
these operations.
In this situation, we say that the elements *generate* the domain.

For example, a list of matrices of the same shape over a common field
can be used to generate an additive group or a vector space over a
suitable field; if the matrices are square then we can also use the
matrices as generators of a semigroup , a ring, or an algebra. We
illustrate some of these possibilities:

\beginexample
gap> mats:= [ [ [ 0*Z(2), Z(2)^0 ],
>               [ Z(2)^0, 0*Z(2) ] ], 
>             [ [ Z(2)^0, 0*Z(2) ],
>               [ 0*Z(2), Z(2)^0 ] ] ];;
gap> Size( AdditiveMagma( mats ) );
4
gap> Size( VectorSpace( GF(8), mats ) );
64
gap> Size( Algebra( GF(2), mats ) );    
4
gap> Size( Group( mats ) );         
2
\endexample
Each combination of operations under which a domain could be closed
gives a notion of generation.
So each group has group generators, and since it is a monoid,
one can also ask for monoid generators of a group.

Note that one cannot simply ask for ``the generators of a domain'',
it is always necessary to specify what notion of generation is meant.
Access to the different generators is provided by functions with
names of the form `GeneratorsOfSomething'.
For example, `GeneratorsOfGroup' denotes group generators,
`GeneratorsOfMonoid' denotes monoid generators, and so on.
The result of `GeneratorsOfVectorSpace' is of course to be understood
relative to the field of scalars of the vector space in question.

\beginexample
gap> GeneratorsOfVectorSpace( GF(4)^2 );
[ [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ] ]
gap> v:= AsVectorSpace( GF(2), GF(4)^2 );;
gap> GeneratorsOfVectorSpace( v );
[ [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ], [ Z(2^2), 0*Z(2) ],
  [ 0*Z(2), Z(2^2) ] ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Domain Constructors}

\indextt{Something}
A group can be constructed from a list of group generators <gens> by
`Group( <gens> )',
likewise one can construct rings and algebras with the functions `Ring'
and `Algebra'.

Note that it is not always or completely checked that <gens> is in
fact a valid list of group generators, for example whether the
elements of <gens> can be multiplied or whether they are invertible.
This means that {\GAP} trusts you, at least to some extent, that the
desired domain `Something( <gens> )' does exist.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Forming Closures of Domains}

\indextt{ClosureSomething}
Besides constructing domains from generators, one can also form the
closure of a given domain with an element or another domain.
There are different notions of closure, one has to specify one
according to the desired result and the structure of the given domain.
The functions to compute closures have names such as
`ClosureSomething'.
For example, if $D$ is a group and one wants to construct the group
generated by $D$ and an element $g$ then one can use
`ClosureGroup( $D$, $g$ )'.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Changing the Structure}

\indextt{AsSomething}
The same set of elements can have different algebraic structures.
For example, it may happen that a monoid $M$ does in fact contain
the inverses of all of its elements, and thus $M$ is equal to the group
formed by the elements of $M$.

\beginexample
gap> m:= Monoid( mats );;
gap> m = Group( mats );
true
gap> IsGroup( m );
false
\endexample

The last result in the above example may be surprising.
But the monoid `m' is not regarded as a group in {\GAP},
and moreover there is no way to turn `m' into a group.
Let us formulate this as a rule:

*The set of operations under which the domain is closed is fixed
in the construction of a domain, and cannot be changed later.*

(Contrary to this, a domain *can* acquire knowledge about properties
such as whether the multiplication is associative or commutative.)

If one needs a domain with a different structure than the given one,
one can construct a new domain with the required structure.
The functions that do these constructions have names such as
`AsSomething', they return a domain that has the same elements as the
argument in question but the structure `Something'.
In the above situation, one can use `AsGroup'.

\beginexample
gap> g:= AsGroup( m );;
gap> m = g;
true
gap> IsGroup( g );
true
\endexample

If it is impossible to construct the desired domain, the `AsSomething'
functions return `fail'.

\beginexample
gap> AsVectorSpace( GF(4), GF(2)^2 );
fail
\endexample

The functions `AsList' and `AsSortedList' mentioned above do not return
domains, but they fit into the general pattern in the sense that they
forget all the structure of the argument, including the fact that it is
a domain, and return a list with the same elements as the argument has.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subdomains}

\indextt{Subsomething}\indextt{SubsomethingNC}
It is possible to construct a domain as a subset of an existing domain.
The respective functions have names such as `Subsomething',
they return domains with the structure `Something'.
(Note that the second `s' in `Subsomething' is not capitalized.)
For example, if one wants to deal with the subgroup of the domain <D>
that is generated by the elements in the list <gens>,
one can use `Subgroup( <D>, <gens> )'.
It is not required that <D> is itself a group, only that the group generated
by <gens> must be a subset of <D>.

The superset of a domain $S$ that was constructed by a `Subsomething'
function can be accessed as `Parent( $S$ )'.

\beginexample
gap> g:= SymmetricGroup( 5 );;
gap> gens:= [ (1,2), (1,2,3,4) ];;
gap> s:= Subgroup( g, gens );;
gap> h:= Group( gens );;
gap> s = h;
true
gap> Parent( s ) = g;
true
\endexample

Many functions return subdomains of their arguments, for example
the result of `SylowSubgroup( $G$ )' is a group with parent group $G$.

If you are sure that the domain `Something( <gens> )' is contained in the
domain <D> then you can also call `SubsomethingNC( <D>, <gens> )' instead
of `Subsomething( <D>, <gens> )'.
The `NC' stands for ``no check'', and the functions whose names end with
`NC' omit the check of containment.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Further Information about Domains}

More information about domains can be found in
Chapter~"ref:Domains". Many other other chapters deal with specific
types of domain such as groups, vector spaces or algebras.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

