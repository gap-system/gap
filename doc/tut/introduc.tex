\Chapter{A first session with GAP}

This tutorial introduces you to  the {\GAP}  system.  It is written  with
users in mind who have just managed to start {\GAP} for the first time on
their computer and want to learn the basic facts  about {\GAP} by playing
around with some instructive  examples. Therefore, this tutorial contains
at many  places several lines of  input  (which you  should type  on your
terminal) followed by the corresponding output  (which {\GAP} produces as
an answer to your input).
\begintt
    This ``session protocol'' is indented and printed in typwriter style
    (like this paragraph) in this tutorial and should look exactly as it
    looks on your text terminal or text window.
\endtt
This is  to encourage you to actually  run through these examples on your
computer. This will support your  feeling for {\GAP}  as a tool, which is
the leading aim of this  tutorial. Do not believe any  statement in it as
long  as you cannot verify  it for your own  version of  {\GAP}. You will
learn to distinguish  between small  deviations of  the behavior of  your
personal {\GAP} from the printed examples and serious nonsense.

Since the printing routines of {\GAP} are in some sense machine dependent
you will for instance encounter a different layout of the printed objects
in different environments.  But the  contents should always be the  same.
In case you encounter serious nonsense  it is highly recommended that you
send a bug report to `gap-trouble@dcs.st-and.ac.uk'.

The examples in this tutorial should  explain everything you have to know
in order to be able to use {\GAP}. The reference manual then gives a more
systematic  treatment of  the various types  of objects  that  {\GAP} can
manipulate.  But it  seems neither  desirable   to start this  systematic
course with  the  most elementary (and most   boring) structures, nor  to
confront you with all the complex data types before you know how they are
internally represented in terms of elementary structures. For this reason
this tutorial wants to  provide you with a  basic understanding of {\GAP}
objects, on  which the reference manual  then will rely when  it explains
everything in detail.  So  after having mastered  this tutorial, you  can
immediately  plunge   into the exciting  parts  of  {\GAP} and  only read
detailed information about elementary   things (in the reference  manual)
when you really need it.

Since this    book should  be    a  tutorial,  we  have    included  some
exercises. They interrupt the example session every now  and then and ask
something that you might   well have asked yourself   when you typed  the
examples printed here.   You should then try to   solve this question  by
typing  in  some   more examples  and   studying the  output  that {\GAP}
delivers. If you  want to  check whether  you drew the  right conclusions
from  what  you saw, you  can  look up the   answer  to every exercise in
appendix~A\null.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Starting and leaving GAP}\null

\atindex{starting GAP}{@starting {\GAP}}%
\atindex{leaving GAP}{@leaving {\GAP}}%
\atindex{quit}{@\noexpand`quit'}%
If the  program  is correctly installed then  you start {\GAP}  by simply
typing `gap'  at  the prompt  of your  operating  system  followed by the
$return$ or the $newline$ key.
\beginexample
    $ gap
\endexample
{\GAP}  answers your  request with  its beautiful  banner (which  you can
avoid with the command line option `-b') and then it shows its own prompt
`gap>' asking you for further input.
\beginexample
    gap>
\endexample
The usual  way to end a  {\GAP} session is  to type `quit;' at the `gap>'
prompt. Do not omit the semicolon!
\beginexample
    gap> quit;
    $ 
\endexample
On some systems you may as well type  $ctl$-`D' to yield the same effect.
In any situation   {\GAP} is ended by  typing  $ctl$-`C' twice  within  a
second. Here as always, a combination like  $ctl$-`D' means that you have
to press the `D' key while you hold down the $ctl$ key.

In most places *whitespace*
\index{whitespace}%
characters  (i.e. <space>s, <tab>s  and <newline>s) are insignificant for
the meaning  of {\GAP} input. Identifiers and  keywords must  however not
contain any whitespace. On   the  other hand,  sometimes there   must  be
whitespace around  identifiers and keywords   to separate them  from each
other and from numbers. We will use whitespace to format more complicated
commands for better readability.

A *comment*
\index{comments}%
in {\GAP}  starts with the symbol `\#'  and continues to  the  end of the
line. Comments are treated like whitespace by {\GAP}.

Besides of such comments which are part of the input of a {\GAP} session,
we use additional comments  which are part of the manual description, but
not  of the  respective {\GAP} session.  In the  printed version  of this
manual  these comments  will  be printed  in  a normal  font  for  better
readability, hence they start with the symbol~\#.

The examples of  {\GAP} sessions given  in any particular chapter of this
manual have been  run in one continuous   session, starting with the  two
commands
\beginexample
    gap> SizeScreen( [ 72, ] ); LogTo( "erg.log" );
\endexample
which are used to set the line length to 72 and  to save a listing of the
session on some file.  If  you choose any chapter  and rerun its examples
in the given order, you should be able to reproduce our results except of
a few lines of output which we  have edited a  little bit with respect to
blanks or line  breaks in order to  improve the readability.  However, as
soon as  random processes are involved, you  may get different results if
you extract single examples and run them separately.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The read-evaluate-print loop}\null

\atindex{read-evaluate-print loop}{|indexit}%
{\GAP}  is  an   interactive   system.    It  continuously   executes   a
read-evaluate-print loop.  Each  expression you type  at the  keyboard is
read by {\GAP}, evaluated, and then the result is printed.

The interactive nature of {\GAP} allows you to type  an expression at the
keyboard and see its value immediately.  You can  define a  function  and
apply it to arguments  to  see how  it  works.  You may  even write whole
programs containing lots  of functions and test them without leaving  the
program.

When  your program is large it  will be more  convenient to write it on a
file and then read that file  into {\GAP}. Preparing  your functions in a
file   has  several advantages.  You  can   compose  your functions  more
carefully in a  file (with your favorite  text  editor), you can  correct
errors without retyping  the whole function and you  can keep a  copy for
later use. Moreover you can write lots of comments into the program text,
which are ignored  by {\GAP}, but are   very useful for  human readers of
your program text. {\GAP} treats  input from a  file in the same way that
it treats input from the keyboard.

A simple calculation with {\GAP} is as easy as one can imagine.  You type
the problem just after the prompt, terminate it with a semicolon and then
pass the problem to the  program with the $return$ key.  For  example, to
multiply the difference between 9 and 7 by the sum of 5 and 6, that is to
calculate  $(9 - 7) \* (5 + 6)$, you type exactly this  last sequence  of
symbols followed by `;' and $return$.
\beginexample
    gap> (9 - 7) * (5 + 6);
    22
    gap> 
\endexample
Then {\GAP} echoes   the result 22 on the   next line and shows with  the
prompt  that it is ready  for the  next problem.  Henceforth,  we will no
longer print this additional prompt.

If you did omit the semicolon at the  end of  the  line but have  already
typed $return$, then {\GAP} has read everything you  typed, but does  not
know  that the command is  complete.  The  program is waiting for further
input and indicates this with a partial prompt `>'.   This little problem
is solved by  simply typing  the missing  semicolon on  the next line  of
input.  Then the result is printed and the normal prompt returns.
\beginexample
    gap> (9 - 7) * (5 + 6)
    > ;
    22 
\endexample
Whenever you see this partial prompt and you cannot decide what {\GAP} is
still  waiting for, then  you have  to type  semicolons  until the normal
prompt  returns.  In  every situation this  is the  exact meaning of  the
prompt `gap>': the program is waiting for a new problem.

Even if you mistyped the command you do not have to  type it all again as
{\GAP}  permits a lot of  command  line editing.   Maybe you mistyped  or
forgot the last closing parenthesis.  Then  your command is syntactically
incorrect and  {\GAP} will  notice it, incapable of computing the desired
result.
\beginexample
    gap> (9 - 7) * (5 + 6;
    Syntax error: ) expected
    (9 - 7) * (5 + 6;
                    ^
\endexample
Instead of the result an error message occurs  indicating the place where
an unexpected  symbol  occurred with  an arrow sign `^' under  it.  As a
computer program cannot know  what  your  intentions really were, this is
only a hint.  But  in this  case {\GAP} is right  by  claiming that there
should be a closing  parenthesis before the semicolon.  Now  you can type
$ctl$-`P' to  recover the last line of  input.  It  will be written after
the prompt with the cursor in the first position.  Type $ctl$-`E' to take
the cursor  to the end of the line, then $ctl$-`B' to move the cursor one
character  back.  The  cursor  is  now  on the position of the semicolon.
Enter  the missing  parenthesis  by simply typing `)'.  Now  the  line is
correct and may be passed to {\GAP} by  hitting  the $newline$ key.  Note
that for this action it is not necessary to move the cursor past the last
character of the input line.

Each  line  of commands you  type  is  sent to  {\GAP} for  evaluation by
pressing $newline$ regardless of the position of the cursor in that line.
We will no longer mention the $newline$ key from now on.

Sometimes a syntax error will cause {\GAP} to enter a *break loop*.  This
is indicated by the special prompt `brk>'. If another syntax error occurs
while  {\GAP} is in  a break loop, the prompt  will  change to `brk_02>',
`brk_03>' and so on. You can leave the current break loop and exit to the
next outer one by either typing `quit;' or by hitting $ctl$-`D'.

For the  definition  of the    {\GAP}  syntax see  chapter   "chapter:The
Programming Language". A complete list of command line editing facilities
is found in "Line editing". The break loop is described in "Break loops".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Constants and operators}\null

\index{constants}\index{operators}%
In an  expression like `(9  - 7) * (5 +  6)' the constants `5', `6', `7',
and `9' are being composed by the operators `+', `*' and `-' to result in
a new value.

There are  three kinds  of operators in  {\GAP}, arithmetical  operators,
comparison operators, and logical operators.  You  have already seen that
it is possible to form  the sum,  the  difference, and the product of two
integer values.  There are some  more operators applicable to integers in
{\GAP}.   Of  course integers  may  be divided  by  each other,  possibly
resulting in noninteger rational values.
\beginexample
    gap> 12345/25;
    2469/5 
\endexample
Note  that  the numerator and denominator  are divided by their  greatest
common divisor  and that the result is uniquely represented as a division
instruction.

We     haven't met negative numbers      yet.  So consider the  following
self-explanatory examples.
\beginexample
    gap> -3; 17 - 23;
    -3
    -6 
\endexample
The exponentiation   operator  is  written  as  `^'. This   operation  in
particular might lead  to  very large numbers.  This  is  no problem  for
{\GAP} as it can handle numbers of (almost) arbitrary size.
\beginexample
    gap> 3^132;
    955004950796825236893190701774414011919935138974343129836853841 
\endexample
The `mod' operator allows you to compute one value modulo another.
\beginexample
    gap> 17 mod 3;
    2 
\endexample
Note  that  there must be   whitespace around the  keyword  `mod' in this
example since `17mod3' or `17mod' would be interpreted as identifiers.

{\GAP}  knows a  precedence  between operators that may be overridden  by
parentheses.
\beginexample
    gap> (9 - 7) * 5 = 9 - 7  * 5;
    false 
\endexample
Besides these  arithmetical  operators there are comparison  operators in
{\GAP}. A comparison  results in a *boolean value*  which is another kind
of constant.  The operators  `=', `\<>', `\<',  `\<=', `>' and `>=', test
for equality, inequality, less than, less than or equal, greater than and
greater than or equal, respectively.
\beginexample
    gap> 10^5 < 10^4;
    false 
\endexample
The boolean values  `true' and   `false'  can be  manipulated via logical
operators, i.~e., the unary operator `not' and the binary operators `and'
and `or'.  Of course boolean values can be compared, too.
\beginexample
    gap> not true; true and false; true or false;
    false
    false
    true
    gap> 10 > 0 and 10 < 100;
    true 
\endexample
Another important  type of constants in   {\GAP} are *permutations*. They
are written in cycle notation and they can be multiplied.
\beginexample
    gap> (1,2,3);
    (1,2,3)
    gap> (1,2,3) * (1,2);
    (2,3) 
\endexample
The inverse of the   permutation  `(1,2,3)' is denoted   by `(1,2,3)^-1'.
Moreover the caret operator `^' is used to determine the image of a point
under a permutation and to conjugate one permutation by another.
\beginexample
    gap> (1,2,3)^-1;
    (1,3,2)
    gap> 2^(1,2,3);
    3
    gap> (1,2,3)^(1,2);
    (1,3,2) 
\endexample
The    last  type  of   constants  we  want  to introduce    here are the
*characters*, which are simply objects in {\GAP} that represent arbitrary
characters  from  the character set   of the  operating system. Character
literals can  be  entered   in  {\GAP} by  enclosing  the   character  in
*singlequotes* `{'}'.
\beginexample
    gap> 'a';
    'a'
    gap> '*';
    '*' 
\endexample
There are no  operators defined for characters except that characters can
be compared.

%%  Summary  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In this  section you  have  seen that values  may  be preceded  by  unary
operators  and combined by  binary operators placed between the operands.
There are rules for precedence which may be overridden by parentheses.  A
comparison  results in a boolean value.   Boolean values are combined via
logical operators.  Moreover you have seen that {\GAP} handles numbers of
arbitrary size.   Numbers and boolean   values are constants.   There are
other types of  constants in {\GAP} like permutations.   You are now in a
position to use {\GAP} as a simple desktop calculator.

Operators are explained in more detail in "Comparisons" and "Operations".
Moreover there are  sections about operators  and comparisons for special
types  of  objects in almost every chapter of this manual.  You will find
more information about boolean values in chapters "Booleans" and "Boolean
Lists".   Permutations  are   described  in  chapter  "Permutations"  and
characters are described in chapter "Strings and Characters".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Variables versus objects}\null

\index{variables}\index{assignment}\index{identifier}\index{objects}% The
constants described   in  the  last  section   are  specified by  certain
combinations   of digits and minus   signs (in the   case of integers) or
digits,  commas  and parentheses (in  the case  of  permutations).  These
sequences of characters  always have the same meaning  to  {\GAP}. On the
other hand, there are *variables*, specified by a sequence of letters and
digits (including at least one letter), and their meaning depends on what
has been assigned to  them.  An *assignment* is  done by a {\GAP} command
`<sequence_of_letters_and_digits> :=  <meaning>',  where the  sequence on
the left hand side is called the *identifier*  of the variable, it serves
as its name. The meaning on the right hand side can be a constant like an
integer or a  permutation,  but it can  also  be almost any  other {\GAP}
object. From now on,  we will use the term  *object* to denote  something
that can be assigned to a variable.

There must be no whitespace between the `:' and the `=' in the assignment
operator.  Also do not confuse  the  assignment operator with the  single
equality sign `=' which is in {\GAP} only used for the test of equality.
\beginexample
    gap> a:= (9 - 7) * (5 + 6);
    22
    gap> a;
    22
    gap> a * (a + 1);
    506
    gap> a:= 10;
    10
    gap> a * (a + 1);
    110 
\endexample
After an assignment the assigned object is echoed on the  next line.  The
printing of the  object of a statement may  be in every case prevented by
typing a double semicolon.
\beginexample
    gap> w:= 2;; 
\endexample
After the assignment the variable evaluates  to that object if evaluated.
Thus it is possible to  refer to that object by  the name of the variable
in any situation.

This is in fact the whole secret of an assignment. An identifier is bound
to an  object and from this moment  points to that object.  Nothing more.
This binding  is changed by the  next  assignment to that  identifier. An
identifier does not denote a block of memory as in some other programming
languages. It simply points to an object, which has  been given its place
in memory by the {\GAP} storage manager.   This place may change during a
{\GAP} session, but that doesn't  bother the identifier.  *The identifier
points to the object, not to a place in the memory.*

For the  same reason it is  not the  identifier that has   a type but the
object.  This means  on the other hand that  the identifier `a' which now
is bound to an integer object may in the  same session point to any other
object regardless of its type.

Identifiers  may be sequences  of letters and digits containing at  least
one letter.   For example  `abc' and `a0bc1'  are valid identifiers.  But
also `123a'  is  a valid identifier as  it cannot be  confused  with  any
number.  Just `1234' indicates the  number 1234 and cannot be at the same
time the name of a variable.

Since  {\GAP} distinguishes  upper and  lower  case, `a1'  and  `A1'  are
different  identifiers.   Keywords  such as `quit'  must not  be used  as
identifiers.  You will see more keywords in the following sections.

In  the remaining  part of  this manual   we  will ignore the  difference
between variables, their names  (identifiers), and the objects they point
to.  It may be useful  to think from time  to  time about what is  really
meant by terms such as the integer `w'.

There are some predefined variables coming with {\GAP}.  Many of them you
will find in the remaining  chapters of  this manual, since functions are
also referred to via identifiers.

This seems to be the  right place to state the  following rule.  The name
of  every function in the {\GAP}  library starts with a *capital letter.*
Thus if you choose  only names starting with a  small letter for your own
variables you will  not overwrite any predefined  function. But there are
some further interesting variables one of which shall be introduced now.

Whenever {\GAP} returns a  object by printing it  on  the next  line this
object is assigned to the variable `last'.  So if you computed
\beginexample
    gap> (9 - 7) * (5 + 6);
    22 
\endexample
and forgot to assign the object to the  variable `a' for further use, you
can still do it by the following assignment.
\beginexample
    gap> a:= last;
    22 
\endexample
Moreover there are variables `last2' and `last3', guess their values.

%%  Summary  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In this section you have seen how to assign  objects to variables.  These
objects can  later   be accessed through  the  name  of the  variable, its
identifier.  You have also  encountered the useful  concept of the `last'
variables storing the latest returned objects.  And  you have learned that
a double semicolon prevents the result of a statement from being printed.

Variables and assignments are described in more detail in "Variables" and
"Assignments".  A complete list of keywords is contained in "Keywords".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Objects versus elements}

In the last section  we mentioned that every object   is given a  certain
place  in memory by the  {\GAP} storage manager  (although that place may
change in the course  of  a {\GAP}  session). In  this sense, objects  at
different places in memory are never equal, and if  the object pointed to
by the  variable  `a' (to be more  precise,  the variable with identifier
`a')  is  equal to the   object pointed to by  the  variable `b', then we
should better  say that they  are not only  equal but *identical*. {\GAP}
provides the function `IsIdentical' to test whether this is the case, you
can, e.g., say `IsIdentical( a, b )'.

\exercise  `IsIdentical'   works not only  for   variables,  but also for
constants. Try  the commands  `IsIdentical(  -1, -1 )'  and `IsIdentical(
(1,2), (1,2) )' and explain the outcome.

\answer  (1)~`IsIdentical( -1,  -1  )  =  true'.  Integers  like `-1' are
constants that have a predefined place in memory  even before their first
appearance  in {\GAP}, therefore there  is only one  `-1' in every {\GAP}
session.  (Actually,   the integer is  not  really stored in  that memory
place, because  the place itself --- the  address ---  already determines
the  integer.)\quad(2)~`IsIdentical(  (1,2),  (1,2) )   =  false'. Unlike
integers, permutations are constructed and   stored in memory whenever  a
sequence of    parantheses,    digits and  commas   appears.   Here,  the
permutation $(1,2)$  is constructed  twice  and stored  in  memory twice,
i.e.,  in different   places.  (The  identity  permutation,  `()', is  an
exception, it has a  predefined memory place like  integers. On the other
hand,  integers larger than  $2^{28}$  are constructed like permutations,
hence `IsIdentical( 2^28, 2^28 ) = false'.)

If  you have done this  exercise, you  will  have experienced that {\GAP}
objects  <a>  and  <b> can  be  unequal  although they are   equal from a
mathematical point of view, i.e., although we should have `<a> = <b>'. It
may  be that the objects <a>  and <b> are  stored  in different places in
memory, or it may be that we have  an equivalence relation defined on the
set of  objects under which <a>  and <b> belong   to the same equivalence
class.  For example, if `<a>  = $x^3$' and  `<b> = $x^{-5}$' are words in
the finitely presented group $\langle  x\mid x^2=1\rangle$, we would have
`<a> = <b>' in that group.

{\GAP} uses  the   equality operator `=' to  denote   such a mathematical
equality, *not* the identity of objects. Hence we often  have `<a> = <b>'
although `IsIdentical(  <a>, <b> ) = false'.  The operator `=' defines an
equivalence relation on  the set of  all {\GAP} objects,  and we call the
corresponding   equivalence   classes  (i.e.,    the  equality   classes)
*elements*. Phrasing it differently, the  same element may be represented
by various {\GAP} objects.

Non-trivial examples of   elements   that are represented by    different
objects (objects  that really  look different,  not ones  that are merely
stored in  different  memory places)  will  occur only   when  we will be
considering composite objects such as lists or domains.

\exercise To prepare yourself for the discussion of equality and identity
of lists, assume  that a variable has been  assigned the empty list by `a
:=  [ ];' and   explain how to  assign  (1)~the same (identical)  object,
(2)~an equal  object to another variable  `b'. How can someone  else test
which alternative you chose without using `IsIdentical'?

\answer (1)~`b := a;'\quad (2)~`b := [ ];' or `b := ShallowCopy( a );' or
something similar.\quad  To test whether `b'  is identical to `a', put an
element  in the list with  `Add(  b, 1  );'  and see  if this change also
affected `a'.  The lists are then  identical if and only  if  this is the
case, i.e., if still `a = b'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Functions}

A  program  written  in  the  {\GAP} language  is  called  a  *function*.
Functions  are   special  {\GAP}  objects.   Most  of  them  behave  like
mathematical functions.  They are applied to  objects and  will return  a
new  object  depending  on  the input.   The  function  `Factorial',  for
example,  can be applied to an  integer and will  return the factorial of
this integer.
\beginexample
    gap> Factorial(17);
    355687428096000 
\endexample
Applying  a  function  to arguments  means  to  write  the  arguments  in
parentheses following the function.   Several arguments are  separated by
commas, as for the  function  `Gcd' which  computes  the greatest  common
divisor of two integers.
\beginexample
    gap> Gcd(1234, 5678);
    2 
\endexample
There are other functions that do not return an object but only produce a
side effect.   They change for  example  one of their  arguments.   These
functions are sometimes called  procedures.  The function `Print' is only
called for the side effect to print something on the screen.
\beginexample
    gap> Print(1234, "\n");
    1234 
\endexample
In order to be able to compose arbitrary text with `Print', this function
itself will not produce a line break  after printing. Thus we had another
newline character `\"\\n\"' printed to start a new line.

Some functions will both change an argument  and return an object such as
the function `Sortex'  that sorts a  list and returns the permutation  of
the list  elements that it has  performed.  You will not understand right
now what it means  to change an object.   We will return to this  subject
several times in the next sections.

A comfortable way to define a function is given by the *maps-to* operator
\index{maps-to operator}%
`->' consisting of  a minus sign and a   greater sign with  no whitespace
between them. The function  `cubed' which maps a  number  to its  cube is
defined on the following line.
\beginexample
    gap> cubed:= x -> x^3;
    function ( x ) ... end 
\endexample
After the function has been defined, it can now be applied.
\beginexample
    gap> cubed(5);
    125 
\endexample
Not every {\GAP} function can be defined in this  way.   You will see how
to write your own {\GAP} functions in a later section.

%%  Summary  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In this section you have seen {\GAP} objects of  type function.  You have
learned how to apply a function to  arguments.  This  yields as result  a
new object or a side effect.  A side effect may change an argument of the
function.   Moreover you have seen an easy  way  to define a  function in
{\GAP} with the maps-to operator.

Function  calls are described   in   "Function Calls" and in   "Procedure
Calls".  The functions of the {\GAP}  library are  described in detail in
the reference manual.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local Variables:
% mode:               text
% mode:               outline-minor
% outline-regexp:     "\\\\Chapter\\|\\\\Section"
% paragraph-start:    "\\\\\\(begin\\|[Ee]nd\\|Par\\|Thm\\)\\|^\\(.*\\$\\$.*\\)?\\s-*$"
% paragraph-separate: "\\\\\\(begin\\|[Ee]nd\\|Par\\|Thm\\)\\|^\\(.*\\(\\$\\$\\|\\\\\\\\\\).*\\)?\\s-*$"
% fill-column:        73
% End:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
