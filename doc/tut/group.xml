<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  group.tex                 GAP documentation             Thomas Breuer -->
<!-- %W                                                         & Frank Celler -->
<!-- %W                                                     & Martin Schönert -->
<!-- %W                                                       & Heiko Theißen -->
<!-- %% -->
<!-- %H  @(#)<M>Id: group.tex,v 4.42 2006/11/08 11:50:35 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1997,  Lehrstuhl D für Mathematik,  RWTH Aachen,   Germany -->
<!-- %% -->
<!-- %%  This file contains a tutorial introduction to groups. -->
<!-- %% -->
<P/>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="Groups and Homomorphisms">
<Heading>Groups and Homomorphisms</Heading>

In this chapter we will show  some computations with groups. The examples
deal mostly with permutation groups, because they are the easiest 
to input.
The functions mentioned here, like <Ref Func="Group" BookName="ref"/>,
<Ref Func="Size" BookName="ref"/> or
<Ref Func="SylowSubgroup" BookName="ref"/>, however,
are the same for all  kinds of groups, although
the algorithms which compute the information  of course will be different
in most cases.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Permutation groups">
<Heading>Permutation groups</Heading>

Permutation  groups  are so easy to  input  because their elements, i.e.,
permutations,  are  so easy to  type: they  are  entered and displayed in
disjoint cycle notation. So let's construct a permutation group:
<P/>
<Example><![CDATA[
gap> s8 := Group( (1,2), (1,2,3,4,5,6,7,8) );
Group([ (1,2), (1,2,3,4,5,6,7,8) ])
]]></Example>
<P/>
We formed the group generated by the permutations <C>(1,2)</C> and
<C>(1,2,3,4,5,6,7,8)</C>, which is well known to be the symmetric group
<M>S_8</M> on eight points, and assigned it to the identifier <C>s8</C>.
Now <M>S_8</M> contains the alternating group on eight points which can be
described in several ways, e.g., as the group of all even permutations
in <C>s8</C>, or as its derived subgroup. Once we ask &GAP; to verify that
the group is an alternating group acting in its natural permutation
representation, the system will display the group accordingly.
<P/>
<Example><![CDATA[
gap> a8 := DerivedSubgroup( s8 );
Group([ (1,2,3), (2,4,3), (2,4,5), (2,5,6,3,4), (3,7,4), (2,6)
(4,7,8,5) ])
gap> Size( a8 ); IsAbelian( a8 ); IsPerfect( a8 );
20160
false
true
gap> IsNaturalAlternatingGroup(a8);
true
gap> a8;
Alt( [ 1 .. 8 ] )
]]></Example>
<P/>
Once information about a group like <C>s8</C> or <C>a8</C> has been computed,
it is stored in the group so that  it can simply be looked  up when it is
required  again.   This holds for  all pieces   of  information in the
previous  example.  Namely,  <C>a8</C>  stores its  order and  that   it is
nonabelian and perfect, and <C>s8</C> stores its derived subgroup <C>a8</C>.
Had we computed <C>a8</C> as <C>CommutatorSubgroup( s8, s8 )</C>, however, it
would not have been stored, because it would  then have been computed
as a function of <E>two</E> arguments, and hence one could not attribute it
to just one of them.
(Of course the function <Ref Func="CommutatorSubgroup" BookName="ref"/> can
compute the commutator  subgroup  of <E>two</E> arbitrary  subgroups.)  The
situation is  a bit  different for  Sylow  <M>p</M>-subgroups: The function
<Ref Func="SylowSubgroup" BookName="ref"/> also  requires  two arguments,
namely a   group and a
prime <M>p</M>, but the result is  stored in the  group &ndash;namely together
with the prime  <M>p</M> in a  list that can be accessed with
<C>ComputedSylowSubgroups</C>, but we
won't dwell on the details here.
<P/>
<Example><![CDATA[
gap> syl2 := SylowSubgroup( a8, 2 );; Size( syl2 );
64
gap> Normalizer( a8, syl2 ) = syl2;
true
gap> cent := Centralizer( a8, Centre( syl2 ) );; Size( cent );
192
gap> DerivedSeries( cent );; List( last, Size );
[ 192, 96, 32, 2, 1 ]
]]></Example>
<P/>
We have typed double semicolons  after some commands  to avoid the output
of the  groups   (which would  be  printed  by their  generator   lists).
Nevertheless, the beginner  is  encouraged to   type  a single  semicolon
instead and study the full output. This  remark also applies for the rest
of this tutorial.
<P/>
With the next  examples, we want  to calculate a  subgroup of <C>a8</C>, then
its  normalizer and finally determine the  structure of the extension. We
begin by forming a subgroup   generated by three commuting   involutions,
i.e., a subgroup  isomorphic to the   additive group of the  vector space
<M>2^3</M>.
<P/>
<Example><![CDATA[
gap> elab := Group( (1,2)(3,4)(5,6)(7,8), (1,3)(2,4)(5,7)(6,8),
>                   (1,5)(2,6)(3,7)(4,8) );;
gap> Size( elab );
8
gap> IsElementaryAbelian( elab );
true
]]></Example>
<P/>
As usual, &GAP; prints the group by giving  all its generators. This can
be annoying, especially if there are many of them or  if they are of huge
degree. It also makes  it difficult to recognize  a particular group when
there are already several around. Note  that  although it is no problem for
<E>us</E> to    specify a particular  group to   &GAP;, by  using well-chosen
identifiers such as <C>a8</C>  and <C>elab</C>, it is  impossible for &GAP; to use
these identifiers when printing  a group for us,  because the group  does
not know which identifier(s) point  to it, in fact  there can be several.
In order to    give a name  to  the  group  itself (rather   than  to the
identifier),
you can use the function <Ref Func="SetName" BookName="ref"/>.
We do this with the
name <C>2^3</C> here which reflects  the mathematical properties of the group.
From now on,  &GAP; will use  this name when  printing the group for us,
but we still cannot use this name to specify the group to &GAP;, because
the name does  not know to which group   it was assigned (after  all, you
could assign the   same  name to several  groups).  When  talking  to the
computer, you must always use identifiers.
<P/>
<Example><![CDATA[
gap> SetName( elab, "<group of type 2^3>" ); elab;
<group of type 2^3>
gap> norm := Normalizer( a8, elab );; Size( norm );
1344
]]></Example>
<P/>
<Index Subkey="natural">homomorphism</Index>
Now that  we  have the subgroup <C>norm</C>   of order 1344   and its subgroup
<C>elab</C>, we want to look  at its factor  group. But since  we also want to
find preimages of factor group elements in <C>norm</C>, we really want to look
at the  <E>natural homomorphism</E> defined on  <C>norm</C> with  kernel <C>elab</C> and
whose image is the factor group.
<P/>
<Example><![CDATA[
gap> hom := NaturalHomomorphismByNormalSubgroup( norm, elab );
<action epimorphism>
gap> f := Image( hom );
Group([ (), (), (), (4,5)(6,7), (4,6)(5,7), (2,3)(6,7), (2,4)(3,5), 
 (1,2)(5,6) ])
gap> Size( f );
168
]]></Example>
<P/>
The factor group  is again represented as  a  permutation group
(its first three generators are trivial, meaning that the first three
generators of the preimage are in the kernel of <C>hom</C>). However,
the action domain  of this factor  group has  nothing  to do with  the
action domain of <C>norm</C>. (It only happens that both are subsets of the
natural numbers.) We can now form  images and preimages under the natural
homomorphism. The set of  preimages of an element under  <C>hom</C> is a coset
modulo <C>elab</C>.
We use the function <Ref Func="PreImages" BookName="ref"/> here because
<C>hom</C> is not
a bijection, so an  element of the range can   have several preimages  or
none at all.
<P/>
<Example><![CDATA[
gap> ker:= Kernel( hom );
<group of type 2^3>
gap> x := (1,8,3,5,7,6,2);; Image( hom, x );
(1,7,5,6,2,3,4)
gap> coset := PreImages( hom, last );
RightCoset(<group of type 2^3>,(2,8,6,7,3,4,5))
]]></Example>
<P/>
Note that &GAP; is free to choose any representative for the coset
of preimages.
Of course the quotient of two representatives lies in the kernel of
the homomorphism.
<P/>
<Example><![CDATA[
gap> rep:= Representative( coset );
(2,8,6,7,3,4,5)
gap> x * rep^-1 in ker;
true
]]></Example>
<P/>
The factor  group <C>f</C>  is  a simple  group,  i.e., it has  no non-trivial
normal subgroups. &GAP; can detect this fact,  and it can then also find
the name by which this simple group is known among group theorists. (Such
names are of course not available for non-simple groups.)
<P/>
<Example><![CDATA[
gap> IsSimple( f ); IsomorphismTypeInfoFiniteSimpleGroup( f );
true
rec( 
  name := "A(1,7) = L(2,7) ~ B(1,7) = O(3,7) ~ C(1,7) = S(2,7) ~ 2A(1,\
7) = U(2,7) ~ A(2,2) = L(3,2)", parameter := [ 2, 7 ], series := "L", 
  shortname := "L3(2)" )
gap> SetName( f, "L_3(2)" );
]]></Example>
<P/>
We give <C>f</C> the name  <C>L_3(2)</C> because the  last part of the name  string
reveals that  it is isomorphic to  the simple linear group <M>L_3(2)</M>. This
group, however, also has a  lot of other  names. Names that are connected
with a  <C>=</C> sign  are different names   for the same matrix group,  e.g.,
<C>A(2,2)</C> is the  Lie type notation for  the  classical notation <C>L(3,2)</C>.
Other pairs  of  names are  connected via <C>~</C>,  these then  specify other
classical  groups  that are isomorphic  to that  linear  group (e.g., the
symplectic group <C>S(2,7)</C>, whose Lie type notation would be <C>C(1,7)</C>).
<P/>
The group <C>norm</C> acts on the eight elements of its normal subgroup <C>elab</C>
by conjugation,  yielding  a representation   of <M>L_3(2)</M> in   <C>s8</C> which
leaves one    point  fixed  (namely  point&nbsp;<C>1</C>).
The image of this representation can be computed with the function
<Ref Func="Action" BookName="ref"/>; it is even
contained  in the group <C>norm</C> and  we can show  that <C>norm</C>  is indeed a
split extension of the elementary abelian group <M>2^3</M>  with this image of
<M>L_3(2)</M>.
<P/>
<Example><![CDATA[
gap> op := Action( norm, elab );
Group([ (), (), (), (5,6)(7,8), (5,7)(6,8), (3,4)(7,8), (3,5)(4,6), 
  (2,3)(6,7) ])
gap> IsSubgroup( a8, op ); IsSubgroup( norm, op );
true
true
gap> IsTrivial( Intersection( elab, op ) );
true
gap> SetName( norm, "2^3:L_3(2)" );
]]></Example>
<P/>
By the way, you should not try the operator <C>&lt;</C>  instead of the function
<Ref Func="IsSubgroup" BookName="ref"/>. Something like
<P/>
<Example><![CDATA[
gap> elab < a8;
false
]]></Example>
<P/>
will not cause an error, but the result does not signify anything about the
inclusion of one group in another; <C>&lt;</C> tests  which of the two groups is
less in some total order. On the other hand, the equality operator <C>=</C> in
fact does test the equality of its arguments.
<P/>
<E>Summary.</E>   In  this section   we have   used   the elementary group
functions to determine  the structure of  a normalizer. We have  assigned
names  to the involved groups which  reflect their mathematical structure
and &GAP; uses these names when printing the groups.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Actions of Groups">
<Heading>Actions of Groups</Heading>

In  order to get  another  representation  of  <C>a8</C>, we consider  another
action, namely  that on  the elements   of a  certain conjugacy  class by
conjugation.
<P/>
In the following example we temporarily increase the line length limit
from its default value 80 to 82 in order to make the long expression fit
into one line.
<P/>
<Example><![CDATA[
gap> ccl := ConjugacyClasses( a8 );; Length( ccl );
14
gap> List( ccl, c -> Order( Representative( c ) ) );
[ 1, 2, 2, 3, 6, 3, 4, 4, 5, 15, 15, 6, 7, 7 ]
gap> List( ccl, Size );
[ 1, 210, 105, 112, 1680, 1120, 2520, 1260, 1344, 1344, 1344, 3360, 
  2880, 2880 ]
]]></Example>
<P/>
Note the difference between <Ref Func="Order" BookName="ref"/>
(which means the element order),
<Ref Func="Size" BookName="ref"/>
(which means the size of the conjugacy class) and
<Ref Func="Length" BookName="ref"/> (which means the length of a list).
We choose to let <C>a8</C> operate on the class of length&nbsp;112.
<P/>
<Example><![CDATA[
gap> class := First( ccl, c -> Size(c) = 112 );;
gap> op := Action( a8, AsList( class ),OnPoints );;
]]></Example>
<P/>
We use <Ref Func="AsList" BookName="ref"/> here to convert the conjugacy
class into a list of its elements whereas we wrote
<C>Action( norm,  elab )</C> directly in the previous section.
The reason is that the elementary abelian group <C>elab</C>
can be quickly enumerated by &GAP; whereas the standard enumeration
method for conjugacy classes is slower than just explicit calculation of
the elements. However, &GAP; is reluctant to construct explicit element
lists, because for really large groups this direct method is infeasible.
<P/>
Note also the function <Ref Func="First" BookName="ref"/>,
used to find the first element in a list which passes some test.
<P/>
In this example,
we  have specified the action function <Ref Func="OnPoints" BookName="ref"/>
in this example,
which is defined as
<C>OnPoints( </C><M>d</M><C>, </C><M>g</M><C> ) = </C><M>d</M><C> ^ </C><M>g</M>.
This <Q>caret</Q>  operator denotes conjugation in  a group if  both
arguments <M>d</M> and  <M>g</M> are group elements  (contained in a common
group), but it also  denotes the natural  action  of permutations on
positive integers (and exponentiation of integers as well, of course).
It is in fact the default action and will be supplied by the system if not
given. Another common action is for example
always assumes <Ref Func="OnRight" BookName="ref"/>, which means right
multiplication, defined as <M>d</M><C> * </C><M>g</M>.
(Group actions in &GAP; are always from the right.)
<P/>
We now have a permutation representation <C>op</C> on 112 points, which we
test for primitivity. If it is not primitive, we can obtain a minimal
block system (i.e., one where the blocks have minimal length) by the
function <Ref Func="Blocks" BookName="ref"/>.
<P/>
<Example><![CDATA[
gap> IsPrimitive( op, [ 1 .. 112 ] );
false
gap> blocks := Blocks( op, [ 1 .. 112 ] );;
]]></Example>
<P/>
Note that we  must specify the domain  of the action. You  might think
that the   functions <Ref Func="IsPrimitive" BookName="ref"/> and
<Ref Func="Blocks" BookName="ref"/> could use <C>[ 1 .. 112 ]</C> as
default  domain if no  domain was  given. But  this  is not so  easy,
for example would the default domain of <C>Group(  (2,3,4)  )</C> be
<C>[ 1 .. 4 ]</C> or <C>[ 2 .. 4 ]</C>?
To avoid confusion, all action  functions  require that you
specify  the domain of action.
If we had specified <C>[ 1 .. 113 ]</C> in the
primitivity test above,  point&nbsp;113  would have been  a fixpoint  (and the
action would not even have been transitive).
<P/>
Now <C>blocks</C> is a list of blocks (i.e., a list of lists), which we do not
print  here for the  sake of saving paper (try  it for yourself). In fact
all we want to know is the size of  the blocks, or  rather how many there
are (the product of these two numbers must of course be&nbsp;112). Then we can
obtain a new  permutation group  of the  corresponding  degree by letting
<C>op</C> act on these blocks setwise.
<P/>
<Example><![CDATA[
gap> Length( blocks[1] );  Length( blocks );
2
56
gap> op2 := Action( op, blocks, OnSets );;
gap> IsPrimitive( op2, [ 1 .. 56 ] );
true
]]></Example>
<P/>
Note that we give a third argument (the action function
<Ref Func="OnSets" BookName="ref"/>) to
indicate that the action is not the default action on points but an
action on sets of elements given as sorted lists.
(Section&nbsp;<Ref Sect="Basic Actions" BookName="ref"/> lists all
actions that are pre-defined by &GAP;.)
<P/>
The action of <C>op</C> on the given block system gave us a new representation
on 56 points which is primitive, i.e., the  point stabilizer is a maximal
subgroup. We  compute its preimage in the  representation on eight points
using the   associated   action homomorphisms (which   of   course in this
case are
monomorphisms). We construct  the  composition of two  homomorphisms with
the <C>*</C> operator, reading left-to-right.
<P/>
<Example><![CDATA[
gap> ophom := ActionHomomorphism( a8, op );;
gap> ophom2 := ActionHomomorphism( op, op2 );;
gap> composition := ophom * ophom2;;
gap> stab := Stabilizer( op2, 2 );;
gap> preim := PreImages( composition, stab );
Group([ (1,2,4), (6,7,8), (3,6,8), (5,8,6), (1,2)(3,8) ])
]]></Example>
<P/>
Alternatively, it is possible to create action homomorphisms immediately
(without creating the action first) by giving the same set of arguments to 
<Ref Func="ActionHomomorphism" BookName="ref"/>.
<Example><![CDATA[
gap> nophom := ActionHomomorphism( a8, AsList(class) );
<action homomorphism>
gap> IsSurjective(nophom);
false
gap> Image(nophom,(1,2,3));
(2,43,14)(3,44,20)(4,45,26)(5,46,32)(6,47,38)(8,13,48)(9,19,53)(10,25,
58)(11,31,63)(12,37,68)(15,49,73)(16,50,74)(17,51,75)(18,52,76)(21,54,
77)(22,55,78)(23,56,79)(24,57,80)(27,59,81)(28,60,82)(29,61,83)(30,62,
84)(33,64,85)(34,65,86)(35,66,87)(36,67,88)(39,69,89)(40,70,90)(41,71,
91)(42,72,92)
]]></Example>
<P/>
In this situation, however (for performance reasons, avoiding computation
an image that might never be needed) the homomorphism is defined to be not
into the <E>Image</E> of the action, but into the <E>full symmetric
group</E>, i.e. it is not automatically surjective. Surjectivity can be
enforced by giving the string <C>"surjective"</C> as an extra last argument.
The <C>Image</C> of the action homomorphism of course is the same group in
either case.
<Example><![CDATA[
gap> Size(Range(nophom));
1974506857221074023536820372759924883412778680349753377966562950949028\
5896977181144089422435502777936659795733823785363827233491968638562181\
1850780464277094400000000000000000000000000
gap> Size(Range(ophom));
20160
gap> nophom := ActionHomomorphism( a8, AsList(class),"surjective" );
<action epimorphism>
gap> Size(Range(nophom));
20160
]]></Example>
<P/>
Continuing the example,
the normalizer of an element in the conjugacy class <C>class</C> is a group of
order 360, too. In fact, it is a conjugate of the maximal subgroup we had
found before, and a conjugating element in <C>a8</C>  is found by the function
<Ref Func="RepresentativeAction" BookName="ref"/>.
<P/>
<Example><![CDATA[
gap> sgp := Normalizer( a8, Subgroup(a8,[Representative(class)]) );;
gap> Size( sgp );
360
gap> RepresentativeAction( a8, sgp, preim );
(2,4,3)
]]></Example>
<!-- % The scalar product  of permutation characters  of two subgroups <A>U</A>, <A>V</A>, -->
<!-- % say, equals  the number  of <M>(<A>U</A>,<A>V</A>)</M>-double  cosets. For example,  the -->
<!-- % norm of  the natural permutation character of  degree  eight is two since -->
<!-- % the action of <C>a8</C> on the cosets of a point stabilizer is at least doubly -->
<!-- % transitive. We   also   compute  the   numbers  of    <M>(<C>sgp</C>,<C>sgp</C>)</M> and -->
<!-- % <M>(<C>sgp</C>,<C>stab</C>)</M> double cosets. -->
<!-- % \b eginexample -->
<!-- % gap> stab := Stabilizer( a8, 1 );; -->
<!-- % gap> Length( DoubleCosets( a8, stab, stab ) ); -->
<!-- % 2 -->
<!-- % gap> Length( DoubleCosets( a8, sgp, sgp ) ); -->
<!-- % 4 -->
<!-- % gap> Length( DoubleCosets( a8, sgp, stab ) ); -->
<!-- % 2 -->
<!-- % \e ndexample -->
<P/>
<Index Subkey="operation">homomorphism</Index>
<Index Subkey="action">homomorphism</Index>
<Index>enumerator</Index>
<Index>transversal</Index>
<Index>canonical position</Index>

One of the most prominent actions of a group is on the cosets of a subgroup.
Naïvely this can be done by constructing the cosets and acting on them
by right multiplication.
<Example><![CDATA[
gap> cosets:=RightCosets(a8,norm);;
gap> op:=Action(a8,cosets,OnRight);
Group([ (1,2,3)(4,6,5)(7,8,9)(10,12,11)(13,14,15), (1,2,3)(4,13,9)
(5,7,11)(6,10,15)(8,14,12), (1,11,6)(2,15,4)(3,9,5)(7,13,10)
(8,12,14), (1,10,12,3,13)(2,7,15,14,5)(4,6,8,9,11), (1,12,15)(2,10,5)
(3,11,8)(4,9,13)(6,14,7), (1,4,13,10)(2,15,14,3)(5,12,11,6)(7,9) ])
gap> NrMovedPoints(op);
15
]]></Example>
<P/>
A problem with this approach is that creating (and storing) all cosets can
be very memory intensive if the subgroup index gets large.
 Because of this, &GAP; provides special
objects which act like a list of elements, but do not actually store
elements but compute them on the go. Such a simulated list is called an
<E>enumerator</E>. The easiest example of this concept is the
<Ref Func="Enumerator" BookName="ref"/> of a group.
While it behaves like a list of elements, it requires far less storage, and
is applicable to potentially huge groups for which it would be completely
infeasible to write down all elements:
<Example><![CDATA[
gap> enum:=Enumerator(SymmetricGroup(20));
<enumerator of perm group>
gap> Length(enum);
2432902008176640000
gap> enum[123456789012345];
(1,4,15,3,14,11,8,17,6,18,5,7,20,13,10,9,2,12)
gap> Position(enum,(1,2,3,4,5,6,7,8,9,10));
71948729603
]]></Example>
<P/>
For the action on cosets the object of interest is the
<Ref Func="RightTransversal" BookName="ref"/> of a subgroup. Again, it does
not write out actual elements and thus can be created even for subgroups of
large index.
<Example><![CDATA[
gap> t:=RightTransversal(a8,norm);
RightTransversal(Alt( [ 1 .. 8 ] ),2^3:L_3(2))
gap> t[7];
(4,6,5)
gap> Position(t,(4,6,7,8,5));
8
gap> Position(t,(1,2,3));
fail
]]></Example>
<P/>
For the action on cosets there is the added complication that not
every group element is in the transversal (as the last example shows) but
the action on cosets of a subgroup
usually will not preserve a chosen set of coset representatives.
Because of this issue, all action functionality actually uses 
<Ref Func="PositionCanonical" BookName="ref"/> instead of 
<Ref Func="Position" BookName="ref"/>. In general, for elements contained in
a list,
<Ref Func="PositionCanonical" BookName="ref"/> returns the same as
<C>Position</C>. If the element is not contained in the list (and for
special lists, such as transversals), <C>PositionCanonical</C> returns the
list element representing the same objects, e.g. the transversal element
representing the same coset.
<Example><![CDATA[
gap> PositionCanonical(t,(1,2,3));
2
gap> t[2];
(6,7,8)
gap> t[2]/(1,2,3);
(1,3,2)(6,7,8)
gap> last in norm;
true
]]></Example>
Thus, acting on a <C>RightTransversal</C> with the <C>OnRight</C> action
will in fact (in a slight abuse of definitions)
produce the action of a group on cosets of a subgroup and is in general the
most efficient way of creating this action.
<Example><![CDATA[
gap> Action(a8,RightTransversal(a8,norm),OnRight);
Group([ (1,2,3)(4,6,5)(7,8,9)(10,12,11)(13,14,15), (1,2,3)(4,13,9)
(5,7,11)(6,10,15)(8,14,12), (1,11,6)(2,15,4)(3,9,5)(7,13,10)
(8,12,14), (1,10,12,3,13)(2,7,15,14,5)(4,6,8,9,11), (1,12,15)(2,10,5)
(3,11,8)(4,9,13)(6,14,7), (1,4,13,10)(2,15,14,3)(5,12,11,6)(7,9) ])
]]></Example>
<P/>

<E>Summary.</E> In this section we have learned  how groups can operate on
&GAP;   objects such as  integers  and   group  elements.  We  have used
<Ref Func="ActionHomomorphism" BookName="ref"/>,
among   others,   to   construct the corresponding actions and homomorphisms
and have seen how transversals can be used to create the action on cosets of
a subgroup.
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Subgroups!as Stabilizers">
<Heading>Subgroups as Stabilizers</Heading>

Action functions can also be  used without constructing external sets.
We will try to   find several subgroups  in <C>a8</C>  as stabilizers of  such
actions. One subgroup is immediately  available, namely the stabilizer
of one point. The index of the stabilizer must of course  be equal to the
length of the orbit, i.e.,&nbsp;8.
<P/>
<Example><![CDATA[
gap> u8 := Stabilizer( a8, 1 );
Group([ (2,3,4,5,6,7,8), (2,4,5,6,7,8,3) ])
gap> Index( a8, u8 );
8
gap> Orbit( a8, 1 ); Length( last );
[ 1, 3, 2, 4, 5, 6, 7, 8 ]
8
]]></Example>
<P/>
This gives us a hint how to find further  subgroups. Each subgroup is the
stabilizer of a point of an appropriate  transitive action (namely the
action  on  the cosets of that  subgroup  or another action that is
equivalent to  this action).  So the question   is how  to find  other
actions. The obvious thing is to operate  on pairs of points.
So using the function <Ref Func="Tuples" BookName="ref"/> we first generate
a list of all pairs.
<P/>
<Example><![CDATA[
gap> pairs := Tuples( [1..8], 2 );;
]]></Example>
<P/>
Now we would like to have <C>a8</C> operate on this  domain.
But we cannot use the default action <Ref Func="OnPoints" BookName="ref"/>
because powering a list by a permutation via the caret operator <C>^</C>
is not defined. So we must tell the functions from the actions package how
the group elements operate on the elements of  the domain
(here and below, the word <Q>package</Q> refers to the &GAP; functionality 
for group actions, not to a &GAP; package). In our example
we can do this by simply passing <Ref Func="OnPairs" BookName="ref"/>
as an optional last argument.
All functions from the actions package accept such an optional argument
that describes the action.
One example is <Ref Func="IsTransitive" BookName="ref"/>.
<P/>
<Example><![CDATA[
gap> IsTransitive( a8, pairs, OnPairs );
false
]]></Example>
<P/>
The action is of course not transitive, since the pairs <C>[ 1, 1 ]</C> and
<C>[ 1, 2 ]</C> cannot lie in the same orbit.
So we want to  find out what the orbits are.
The function <Ref Func="Orbits" BookName="ref"/> does that for us.
It returns a list of all the orbits.
We look at the orbit lengths and representatives for the orbits.
<P/>
<Example><![CDATA[
gap> orbs := Orbits( a8, pairs, OnPairs );; Length( orbs );
2
gap> List( orbs, Length );
[ 8, 56 ]
gap> List( orbs, o -> o[1] );
[ [ 1, 1 ], [ 1, 2 ] ]
]]></Example>
<P/>
The action of <C>a8</C>   on the first  orbit (this  is the one  containing
<C>[1,1]</C>, try <C>[1,1] in orbs[1]</C>) is of  course equivalent to the original
action, so we ignore it and work with the second orbit.
<P/>
<Example><![CDATA[
gap> u56 := Stabilizer( a8, orbs[2][1], OnPairs );; Index( a8, u56 );
56
]]></Example>
<P/>
So   now   we have  found   a  second subgroup.   To   make the following
computations a little bit easier and more efficient  we would now like to
work on the points <C>[ 1 .. 56 ]</C> instead of the list of pairs.
The function <Ref Func="ActionHomomorphism" BookName="ref"/> does what we
need.
It creates a homomorphism defined on <C>a8</C> whose image is a new group
that acts on <C>[ 1 .. 56 ]</C> in
the same way that <C>a8</C> acts on the second orbit.
<P/>
<Example><![CDATA[
gap> h56 := ActionHomomorphism( a8, orbs[2], OnPairs );;
gap> a8_56 := Image( h56 );;
]]></Example>
<P/>
We would now like to know if the subgroup <C>u56</C> of index 56 that we found
is  maximal or  not.
As we have used already in Section&nbsp;<Ref Sect="Actions of Groups"/>,
a subgroup is maximal if and only if the action on the cosets of this
subgroup is primitive.
<P/>
<Example><![CDATA[
gap> IsPrimitive( a8_56, [1..56] );
false
]]></Example>
<P/>
Remember that we can leave out the function if we mean
<Ref Func="OnPoints" BookName="ref"/>
but that we have to specify the action domain for all action functions.
<P/>
We see that <C>a8_56</C>   is not primitive. This  means  of course   that the
action  of <C>a8</C>  on  <C>orb[2]</C>  is not  primitive,  because those   two
actions are equivalent. So the stabilizer <C>u56</C> is not maximal. Let us
try to find its supergroups.
We use the function <Ref Func="Blocks" BookName="ref"/> to find a block
system. The  (optional) third  argument  in the following   example tells
<Ref Func="Blocks" BookName="ref"/> that we want a block system
where 1 and 3 lie in one block.
<P/>
<Example><![CDATA[
gap> blocks := Blocks( a8_56, [1..56], [1,3] );;
]]></Example>
<P/>
The result is a list  of sets, such that  <C>a8_56</C> acts on those sets.
Now we would like  the stabilizer of this  action on the sets.
Because we want to operate on the sets we have to pass
<Ref Func="OnSets" BookName="ref"/> as third argument.
<P/>
<Example><![CDATA[
gap> u8_56 := Stabilizer( a8_56, blocks[1], OnSets );;
gap> Index( a8_56, u8_56 );
8
gap> u8b := PreImages( h56, u8_56 );; Index( a8, u8b );
8
gap> IsConjugate( a8, u8, u8b );
true
]]></Example>
<P/>
So we have found a supergroup of <C>u56</C> that is conjugate in <C>a8</C> to <C>u8</C>.
This is not surprising, since <C>u8</C> is a point stabilizer, and <C>u56</C> is a
two point stabilizer in the natural action of <C>a8</C> on eight points.
<P/>
Here  is a <E>warning</E>:
If you specify <Ref Func="OnSets" BookName="ref"/> as third argument to a
function like <Ref Func="Stabilizer" BookName="ref"/>,
you have to  make sure that the  point (i.e.
the second argument) is  indeed a set. Otherwise you  will get a puzzling
error message or  even  wrong results!
In the above example, the second argument <C>blocks[1]</C> came from the
function <Ref Func="Blocks" BookName="ref"/>, which returns a
list of sets, so everything was OK.
<P/>
Actually there  is a third  block system of <C>a8_56</C>  that gives rise to a
third subgroup.
<P/>
<Example><![CDATA[
gap> seed:=First(AllBlocks(a8_56),x->Length(x)=2);;
gap> blocks := Blocks( a8_56, [1..56], seed);;
gap> u28_56 := Stabilizer( a8_56, seed, OnSets );;
gap> u28 := PreImages( h56, u28_56 );;
gap> Index( a8, u28 );
28
]]></Example>
<P/>
We know that  the subgroup <C>u28</C> of index  28 is maximal, because we know
that  <C>a8</C> has no  subgroups  of index 2,  4,  or 7.  However we can also
quickly verify this by checking  that <C>a8_56</C> acts primitively on the
28 blocks.
<P/>
<Example><![CDATA[
gap> IsPrimitive( a8_56, blocks, OnSets );
true
]]></Example>
<P/>
<Ref Func="Stabilizer" BookName="ref"/> is not only applicable to groups
like <C>a8</C> but also to their
subgroups like  <C>u56</C>. So another  method  to find  a  new subgroup is to
compute the stabilizer of another point in <C>u56</C>. Note that <C>u56</C> already
leaves 1 and 2 fixed.
<P/>
<Example><![CDATA[
gap> u336 := Stabilizer( u56, 3 );;
gap> Index( a8, u336 );
336
]]></Example>
<P/>
Other  functions  are also applicable  to  subgroups. In the following we
show that  <C>u336</C> acts regularly on the  60&nbsp;triples of
<C>[ 4 .. 8 ]</C> which
contain no element twice.
We construct the list of these 60&nbsp;triples with
the function <Ref Func="Orbit" BookName="ref"/>
(using <Ref Func="OnTuples" BookName="ref"/>  as the natural generalization
of <Ref Func="OnPairs" BookName="ref"/>)
and   then  pass it   as  action domain  to   the function
<Ref Func="IsRegular" BookName="ref"/>.
The positive result of  the regularity test means that this
action is equivalent  to the actions of <C>u336</C>  on  its 60 elements
from the right.
<P/>
<Example><![CDATA[
gap> IsRegular( u336, Orbit( u336, [4,5,6], OnTuples ), OnTuples );
true
]]></Example>
<P/>
Just as we did in the  case of the  action on the  pairs above, we now
construct a new permutation group that acts on <C>[ 1 .. 336 ]</C>
in the same way that <C>a8</C> acts on the cosets of <C>u336</C>.
But this time we let <C>a8</C> operate on a right transversal,
just like <C>norm</C> did in the natural homomorphism above.
<P/>
<Example><![CDATA[
gap> t := RightTransversal( a8, u336 );;
gap> a8_336 := Action( a8, t, OnRight );;
]]></Example>
<P/>
To find  subgroups above <C>u336</C> we again look for nontrivial block systems.
<P/>
<Example><![CDATA[
gap> blocks := Blocks( a8_336, [1..336] );; blocks[1];
[ 1, 43, 85 ]
]]></Example>
<P/>
We see that the union of <C>u336</C> with its 43rd and its 85th coset
is a subgroup in <C>a8_336</C>, its index is 112.
We can obtain it as the closure of <C>u336</C> with a representative
of the  43rd coset, which can be found as the 43rd element
of the transversal&nbsp;<C>t</C>.
Note that in the representation <C>a8_336</C> on 336 points,
this subgroup corresponds to the stabilizer of the block <C>[ 1, 43, 85 ]</C>.
<P/>
<Example><![CDATA[
gap> u112 := ClosureGroup( u336, t[43] );;
gap> Index( a8, u112 );
112
]]></Example>
<P/>
Above this subgroup of index 112 lies a  subgroup  of index 56, which  is
not conjugate to <C>u56</C>.  In fact, unlike <C>u56</C> it is  maximal.  We obtain
this subgroup in  the same way that we obtained <C>u112</C>, this time forcing
two points, namely 7 and 43 into the first block.
<P/>
<Example><![CDATA[
gap> blocks := Blocks( a8_336, [1..336], [1,7,43] );;
gap> Length( blocks );
56
gap> u56b := ClosureGroup( u112, t[7] );; Index( a8, u56b );
56
gap> IsPrimitive( a8_336, blocks, OnSets );
true
]]></Example>
<P/>
We  already mentioned  in Section&nbsp;<Ref Sect="Actions of Groups"/>
that there is another  standard
action of permutations, namely the  conjugation.
E.g., since no  other action is specified  in the  following example,
<Ref Func="OrbitLength" BookName="ref"/> simply acts via
<Ref Func="OnPoints" BookName="ref"/>,
and because <A>perm_1</A><C> ^ </C><A>perm_2</A> is defined as the conjugation
of <A>perm_2</A> on <A>perm_1</A>, in fact we compute the length of
the conjugacy class of <C>(1,2)(3,4)(5,6)(7,8)</C>.
<P/>
<Example><![CDATA[
gap> OrbitLength( a8, (1,2)(3,4)(5,6)(7,8) );
105
gap> orb := Orbit( a8, (1,2)(3,4)(5,6)(7,8) );;
gap> u105 := Stabilizer( a8, (1,2)(3,4)(5,6)(7,8) );; Index( a8, u105 );
105
]]></Example>
<P/>
Note that although the length of a conjugacy class of any element <M>g</M>
in any finite group <M>G</M> can be computed as
<C>OrbitLength( </C><M>G</M><C>, </C><M>g</M><C> )</C>,
the command <C>Size( ConjugacyClass( </C><M>G</M><C>, </C><M>g</M><C> ) )</C>
is probably more efficient.
<P/>
<Example><![CDATA[
gap> Size( ConjugacyClass( a8, (1,2)(3,4)(5,6)(7,8) ) );
105
]]></Example>
<P/>
Of course the stabilizer <C>u105</C> is in fact the centralizer of the element
<C>(1,2)(3,4)(5,6)(7,8)</C>.
<Ref Func="Stabilizer" BookName="ref"/> notices that and computes the
stabilizer using the centralizer algorithm for permutation groups. In the
usual way we now look for the subgroups above <C>u105</C>.
<P/>
<Example><![CDATA[
gap> blocks := Blocks( a8, orb );; Length( blocks );
15
gap> Set(blocks[1]);
[ (1,2)(3,4)(5,6)(7,8), (1,3)(2,4)(5,8)(6,7), (1,4)(2,3)(5,7)(6,8), 
  (1,5)(2,6)(3,8)(4,7), (1,6)(2,5)(3,7)(4,8), (1,7)(2,8)(3,6)(4,5), 
  (1,8)(2,7)(3,5)(4,6) ]
]]></Example>
<P/>
To find the subgroup of index 15 we  again use closure. Now  we must be a
little bit  careful to avoid    confusion. <C>u105</C> is the  stabilizer   of
<C>(1,2)(3,4)(5,6)(7,8)</C>. We  know  that there is  a correspondence between
the  points  of  the   orbit and  the   cosets  of  <C>u105</C>.   The   point
<C>(1,2)(3,4)(5,6)(7,8)</C> corresponds   to <C>u105</C>.
To get the subgroup above <C>u105</C> that has index 15 in <C>a8</C>,
we must form the closure of <C>u105</C> with an element of the coset that
corresponds to any other point in the first block.
If we choose the point <C>(1,3)(2,4)(5,8)(6,7)</C>,
we must use an element of <C>a8</C> that maps <C>(1,2)(3,4)(5,6)(7,8)</C> to
<C>(1,3)(2,4)(5,8)(6,7)</C>.
The function <Ref Func="RepresentativeAction" BookName="ref"/> does
what we need.
It takes a group and two points and returns an element of the group
that maps the first point to the second.
In fact it also allows you to specify the action as an optional fourth
argument as usual, but we do not need this here.
If no such element exists in the  group, i.e., if the two points do not
lie in one orbit under the group,
<Ref Func="RepresentativeAction" BookName="ref"/> returns <K>fail</K>.
<P/>
<Example><![CDATA[
gap> rep := RepresentativeAction( a8, (1,2)(3,4)(5,6)(7,8),
>                                        (1,3)(2,4)(5,8)(6,7) );
(1,5,7,2,8,4,3)
gap> u15 := ClosureGroup( u105, rep );; Index( a8, u15 );
15
]]></Example>
<P/>
<C>u15</C> is of course a maximal  subgroup, because <C>a8</C>  has no subgroups of
index 3 or&nbsp;5.  There is in fact  another  class of subgroups  of index 15
above <C>u105</C> that we get by adding <C>(2,3)(6,7)</C> to <C>u105</C>.
<P/>
<Example><![CDATA[
gap> u15b := ClosureGroup( u105, (2,3)(6,7) );; Index( a8, u15b );
15
gap> RepresentativeAction( a8, u15, u15b );
fail
]]></Example>
<P/>
<Ref Func="RepresentativeAction" BookName="ref"/> tells us that there is no
element <M>g</M> in <C>a8</C>
such that <C>u15 ^ </C><M>g</M><C> = u15b</C>.
Because <C>^</C> also denotes the conjugation of subgroups
this tells us that <C>u15</C> and <C>u15b</C> are not conjugate.
<P/>
<E>Summary.</E> In this section we  have demonstrated some functions from
the actions package. There  is a whole class of  functions that we did
not mention, namely  those that take a  single element instead of a whole
group as first argument, e.g., <Ref Func="Cycle" BookName="ref"/> and
<Ref Func="Permutation" BookName="ref"/>. These are fully
described  in Chapter <Ref Chap="Group Actions" BookName="ref"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Group Homomorphisms!by Images">
<Heading>Group Homomorphisms by Images</Heading>

We   have already  seen  examples of   group homomorphisms  in  the  last
sections,  namely natural homomorphisms  and  action homomorphisms.
In this section we will show how to construct a group homomorphism
<M>G \rightarrow H</M>
by specifying a generating set for <M>G</M> and the images of these generators
in&nbsp;<M>H</M>.
We use the function
<C>GroupHomomorphismByImages( <A>G</A>, <A>H</A>, <A>gens</A>,
<A>imgs</A> )</C> where <A>gens</A> is a  generating set for <A>G</A> and  <A>imgs</A> is a list
whose <M>i</M>th entry is the image of <M><A>gens</A>[i]</M> under the homomorphism.
<P/>
<Example><![CDATA[
gap> s4 := Group((1,2,3,4),(1,2));; s3 := Group((1,2,3),(1,2));;
gap> hom := GroupHomomorphismByImages( s4, s3,
>           GeneratorsOfGroup(s4), [(1,2),(2,3)] );
[ (1,2,3,4), (1,2) ] -> [ (1,2), (2,3) ]
gap> Kernel( hom );
Group([ (1,4)(2,3), (1,3)(2,4) ])
gap> Image( hom, (1,2,3) );
(1,2,3)
gap> Size( Image( hom, DerivedSubgroup(s4) ) );
3
]]></Example>
<P/>
<Log><![CDATA[
gap> PreImage( hom, (1,2,3) );
Error, <map> must be an inj. and surj. mapping called from
<function "PreImage">( <arguments> )
 called from read-eval loop at line 4 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> quit;
]]></Log>
<P/>
<Example><![CDATA[
gap> PreImagesRepresentative( hom, (1,2,3) );
(1,4,2)
gap> PreImage( hom, TrivialSubgroup(s3) );  # the kernel
Group([ (1,4)(2,3), (1,3)(2,4) ])
]]></Example>
<P/>
This homomorphism  from <M>S_4</M> onto  <M>S_3</M>  is well known  from elementary
group theory.  Images   of elements and  subgroups  under   <C>hom</C> can  be
calculated with the function <Ref Func="Image" BookName="ref"/>.
But since the mapping <C>hom</C> is  not bijective, we  cannot use the
function <Ref Func="PreImage" BookName="ref"/> for  preimages   of
elements  (they can have   several preimages). Instead,   we have  to use
<Ref Func="PreImagesRepresentative" BookName="ref"/>,
which  returns  one  preimage if at  least one
exists (and would  return <K>fail</K> if none  exists, which  cannot occur for
our surjective <C>hom</C>).
On the other hand, we  can use <Ref Func="PreImage" BookName="ref"/> for the
preimage of a set (which always exists, even if it  is empty).
<P/>
Suppose we mistype the input when trying to construct a homomorphism as below.
<P/>
<Example><![CDATA[
gap> GroupHomomorphismByImages( s4, s3,
>        GeneratorsOfGroup(s4), [(1,2,3),(2,3)] );
fail
]]></Example>
<P/>
There is no such homomorphism, hence <K>fail</K> is returned.
But note that because of this,
<Ref Func="GroupHomomorphismByImages" BookName="ref"/> must do
some checks, and this was also done for the mapping <C>hom</C> above.
One can avoid these checks if one is sure that the desired
homomorphism really exists.
For that,
the function <Ref Func="GroupHomomorphismByImagesNC" BookName="ref"/>
can be used; the <C>NC</C> stands for <Q>no check</Q>.
<P/>
But note that horrible things can happen if
<Ref Func="GroupHomomorphismByImagesNC" BookName="ref"/>
is used when the input does not describe a homomorphism.
<P/>
<Log><![CDATA[
gap> hom2 := GroupHomomorphismByImagesNC( s4, s3,
>            GeneratorsOfGroup(s4), [(1,2,3),(2,3)] );
[ (1,2,3,4), (1,2) ] -> [ (1,2,3), (2,3) ]
gap> Size( Kernel(hom2) );
24
]]></Log>
<P/>
In other words, &GAP; claims that the kernel is the full <C>s4</C>,
yet <C>hom2</C> obviously has some non-trivial images!
Clearly there is no such thing as a homomorphism
which maps an element of order&nbsp;4 (namely, (1,2,3,4))
to an element of order&nbsp;3 (namely, (1,2,3)).
<E>But if you use the command
<Ref Func="GroupHomomorphismByImagesNC" BookName="ref"/>,
&GAP; trusts you.</E>
<P/>
<Log><![CDATA[
gap> IsGroupHomomorphism( hom2 );
true
]]></Log>
<P/>
And then it produces serious nonsense if the thing is not a homomorphism,
as seen above!
<P/>
Besides the safe command
<Ref Func="GroupHomomorphismByImages" BookName="ref"/>,
which returns <K>fail</K> if the requested homomorphism does not exist,
there is the function
<Ref Func="GroupGeneralMappingByImages" BookName="ref"/>,
which returns a general mapping (that is, a possibly multi-valued
mapping) that can be tested with
<Ref Func="IsGroupHomomorphism" BookName="ref"/>.
<P/>
<Example><![CDATA[
gap> hom2 := GroupGeneralMappingByImages( s4, s3,
>            GeneratorsOfGroup(s4), [(1,2,3),(2,3)] );;
gap> IsGroupHomomorphism( hom2 );
false
]]></Example>
<P/>
<Index>group general mapping</Index><Index>cokernel</Index><Index>kernel</Index>
<Index Key="GroupHomomorphismByImages vs. GroupGeneralMappingByImages"><C>GroupHomomorphismByImages</C> vs. <C>GroupGeneralMappingByImages</C></Index>
But the  possibility of testing for being  a homomorphism is not the only
reason  why    &GAP; offers  <E>group   general  mappings</E>.  Another (more
important?) reason is that  their existence allows <Q>reversal of arrows</Q>
in a  homomorphism such   as  our original  <C>hom</C>.
By this we mean the <Ref Func="GroupHomomorphismByImages" BookName="ref"/>
with left and right sides exchanged, in which
case it is of course merely a
<Ref Func="GroupGeneralMappingByImages" BookName="ref"/>.
<P/>
<Example><![CDATA[
gap> rev := GroupGeneralMappingByImages( s3, s4,
>           [(1,2),(2,3)], GeneratorsOfGroup(s4) );;
]]></Example>
<P/>
Now <M>hom</M> maps <M>a</M> to <M>b</M> if and only if
<M>rev</M> maps <M>b</M> to <M>a</M>,
for <M>a \in</M> <C>s4</C> and <M>b \in</M> <C>s3</C>.
Since every such <M>b</M> has four preimages under <C>hom</C>,
it now has four images under <C>rev</C>.
Just as the four preimages form a coset of the kernel
<M>V_4 \leq </M><C>s4</C> of <C>hom</C>,
they also form a coset of the <E>cokernel</E> <M>V_4 \leq </M><C>s4</C> of
<C>rev</C>.
The cokernel itself is the set of all images of <C>One( s3 )</C>.
(It is a normal subgroup in the group of all images under <C>rev</C>.)
The operation <Ref Func="One" BookName="ref"/> returns the identity element
of a group.
And this is why &GAP; wants to perform such a reversal of arrows:
it calculates the kernel of a homomorphism like <C>hom</C>
as the cokernel of the reversed group general mapping (here <C>rev</C>).
<P/>
<Example><![CDATA[
gap> CoKernel( rev );
Group([ (1,4)(2,3), (1,3)(2,4) ])
]]></Example>
<P/>
<Index Subkey="single-valued">group general mapping</Index>
<Index Subkey="total">group general mapping</Index>
The reason why <C>rev</C> is not a homomorphism is that it is not
single-valued  (because <C>hom</C> was not injective). But there is another
critical condition:  If we reverse the arrows of a non-surjective
homomorphism, we obtain a group general mapping which is not defined
everywhere, i.e., which is not total (although it will be single-valued
if the original homomorphism is injective). &GAP; requires that a group
homomorphism be both single-valued and total,
so you will get <K>fail</K> if you say
<C>GroupHomomorphismByImages( <A>G</A>, <A>H</A>, <A>gens</A>, <A>imgs</A> )</C> where <A>gens</A> does
not generate <A>G</A> (even if this would give a decent homomorphism on the
subgroup generated by <A>gens</A>).  For a full description,
see Chapter <Ref Chap="Group Homomorphisms" BookName="ref"/>.
<P/>
The last  example of this   section shows that  the  notion of kernel and
cokernel naturally extends even to the case  where neither <C>hom2</C> nor its
inverse general mapping (with arrows reversed) is a homomorphism.
<P/>
<Example><![CDATA[
gap> CoKernel( hom2 );  Kernel( hom2 );
Group([ (2,3), (1,3) ])
Group([ (3,4), (2,3,4), (1,2,4) ])
gap> IsGroupHomomorphism( InverseGeneralMapping( hom2 ) );
false
]]></Example>
<P/>
<E>Summary.</E> In this section we have constructed homomorphisms by
specifying images for a set of generators. We have seen that by reversing
the direction of the mapping, we get group general mappings, which need
not be single-valued (unless the mapping was injective) nor total (unless
the mapping was surjective).

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Nice Monomorphisms">
<Heading>Nice Monomorphisms</Heading>

For some types of groups, the best method to calculate in an isomorphic
group in a <Q>better</Q> representation (say, a permutation group).
We call an injective homomorphism,
that will give such an isomorphic image a <Q>nice monomorphism</Q>.
<P/>
For example in the case of a matrix group we can take the action on the
underlying vector space (or a suitable subset) to obtain such a
monomorphism:
<P/>
<Example><![CDATA[
gap> grp:=GL(2,3);;
gap> dom:=GF(3)^2;;
gap> hom := ActionHomomorphism( grp, dom );; IsInjective( hom );
true
gap> p := Image( hom,grp );
Group([ (4,7)(5,8)(6,9), (2,7,6)(3,4,8) ])
]]></Example>
<P/>
To demonstrate the technique of nice monomorphisms, we compute the
conjugacy classes of the permutation group and lift them back into the
matrix group with the monomorphism <C>hom</C>. Lifting back a conjugacy class
means finding the preimage of the representative and of the centralizer;
the latter is called <Ref Func="StabilizerOfExternalSet" BookName="ref"/>
in &GAP; (because conjugacy classes are represented as external sets, see
Section&nbsp;<Ref Sect="Conjugacy Classes" BookName="ref"/>).
<P/>
<Example><![CDATA[
gap> pcls := ConjugacyClasses( p );; gcls := [  ];;
gap> for pc  in pcls  do
>      gc:=ConjugacyClass(grp,
>                   PreImagesRepresentative(hom,Representative(pc)));
>      SetStabilizerOfExternalSet(gc,PreImage(hom,
>                                      StabilizerOfExternalSet(pc)));
>      Add( gcls, gc );
>    od;
gap> List( gcls, Size );
[ 1, 8, 12, 1, 8, 6, 6, 6 ]
]]></Example>
<P/>
All the steps we have made above are automatically performed by &GAP;
if you simply ask for <C>ConjugacyClasses( grp )</C>,
provided that &GAP; already knows that <C>grp</C> is finite
(e.g., because you asked <C>IsFinite( grp )</C> before).
The reason for this is that a finite matrix group like <C>grp</C> is
<Q>handled by a nice monomorphism</Q>.
For such groups, &GAP; uses the command
<Ref Func="NiceMonomorphism" BookName="ref"/>
to construct a monomorphism (such as the <C>hom</C> in the previous example)
and then proceeds as we have done above.
<P/>
<Example><![CDATA[
gap> grp:=GL(2,3);;
gap> IsHandledByNiceMonomorphism( grp );
true
gap> hom := NiceMonomorphism( grp );
<action isomorphism>
gap> p :=Image(hom,grp);
Group([ (4,7)(5,8)(6,9), (2,7,6)(3,4,8) ])
gap> cc := ConjugacyClasses( grp );; ForAll(cc, x-> x in gcls); 
true
gap> ForAll(gcls, x->x in cc); # cc and gcls might be ordered differently
true
]]></Example>
<P/>
Note that a nice monomorphism might be defined on a larger group than
<C>grp</C>
&ndash;so we have to use <C>Image( hom, grp )</C> and not only
<C>Image( hom )</C>.
<P/>
Nice monomorphisms are not only used for matrix groups, but also for
other kinds of groups in which one cannot calculate easily enough. As
another example, let us show that the automorphism group of the
quaternion group of order&nbsp;8 is isomorphic to the symmetric group of
degree&nbsp;4  by examining the <Q>nice object</Q> associated with that
automorphism group.
<P/>
<Example><![CDATA[
gap> p:=Group((1,7,6,8)(2,5,3,4), (1,2,6,3)(4,8,5,7));;
gap> aut := AutomorphismGroup( p );; NiceMonomorphism(aut);;
gap> niceaut := NiceObject( aut );
Group([ (1,4,2,3), (1,5,4)(2,6,3), (1,2)(3,4), (3,4)(5,6) ])
gap> IsomorphismGroups( niceaut, SymmetricGroup( 4 ) );
[ (1,4,2,3), (1,5,4)(2,6,3), (1,2)(3,4), (3,4)(5,6) ] ->
[ (1,4,2,3), (1,2,3), (1,2)(3,4), (1,3)(2,4) ]
]]></Example>
<P/>
The range of  a nice monomorphism is  in most cases a permutation  group,
because  nice monomorphisms  are mostly action  homomorphisms. In some
cases,  like in  our last example,  the  group is solvable  and you might
prefer a pc group as nice object. You cannot change the nice monomorphism
of  the automorphism  group (because it  is   the value  of the attribute
<Ref Func="NiceMonomorphism" BookName="ref"/>),
but you can compose  it with an isomorphism from the permutation  group
to a pc group to obtain your personal nicer monomorphism.
If you reconstruct the automorphism group, you can even prescribe it
this nicer monomorphism as its <Ref Func="NiceMonomorphism" BookName="ref"/>,
because a newly-constructed group will not yet have a
<Ref Func="NiceMonomorphism" BookName="ref"/> set.
<P/>
<Example><![CDATA[
gap> nicer := NiceMonomorphism(aut) * IsomorphismPcGroup(niceaut);;
gap> aut2 := GroupByGenerators( GeneratorsOfGroup( aut ) );;
gap> SetIsHandledByNiceMonomorphism( aut2, true );
gap> SetNiceMonomorphism( aut2, nicer );
gap> NiceObject( aut2 );  # a pc group
Group([ f1*f2, f2^2*f3, f4, f3 ])
]]></Example>
<P/>
The star <C>*</C> denotes composition of mappings  from the left to the right,
as we  have  seen in  Section <Ref Sect="Actions of Groups"/> above.
Reconstructing the
automorphism group may of course result in the  loss of other information
&GAP; had already gathered, besides the (not-so-)nice monomorphism.
<P/>
<E>Summary.</E>  In this section we have  seen  how calculations in groups
can be carried  out in isomorphic  images in  nicer groups. We  have seen
that &GAP;  pursues this technique  automatically for certain classes of
groups, e.g., for matrix groups that are known to be finite.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Further Information about Groups and Homomorphisms">
<Heading>Further Information about Groups and Homomorphisms</Heading>

Groups and the functions for groups are treated in
Chapter&nbsp;<Ref Chap="Groups" BookName="ref"/>.
There are several chapters dealing with groups in specific representations,
for example Chapter&nbsp;<Ref Chap="Permutation Groups" BookName="ref"/>
on permutation groups,
<Ref Chap="Polycyclic Groups" BookName="ref"/>
on polycyclic (including finite solvable) groups,
<Ref Chap="Matrix Groups" BookName="ref"/> on matrix groups and
<Ref Chap="Finitely Presented Groups" BookName="ref"/> on
finitely presented groups.
Chapter&nbsp;<Ref Chap="Group Actions" BookName="ref"/> deals
with group actions.
Group homomorphisms are the subject of
Chapter&nbsp;<Ref Chap="Group Homomorphisms" BookName="ref"/>.

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->

