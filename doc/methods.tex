\Chapter{Intro}

This chapter describes the new concepts in {\GAP}4.
These new ideas were
motivated by the developent of computational group theory during the last
years:
On the one hand, algorithms become more and more complex. Functions like
`SylowSubgroup' that were originally called just by the user now become
a small part of an intricate algorithm. Therefore {\GAP} may not assume any
longer that the user himself will take an intelligent choice from the
available methods to solve his task. Thus {\GAP} itself has to take decisions
-- at least not too ignorant ones.

On the other hand, algorithms have to solve partial problems in other
algebraic structures more and more frequently. For example an algorithm for
permutation groups may have to deal with modules and the particular problem
is probably best solved in terms of lattices. Thus {\GAP} has to be extendable
to allow the introduction of such new structures.
(andere benutzer wollen auch strukturen?)

So the new concepts try to fulfill two aims:

{\GAP} should be less ``stupid''. It should not ignore knowledge it has about
objects but use this knowledge for further computations. For example if a
group is known to be nilpotent the $p$-Sylow subgroup can be obtained simply
from the $p$-parts of the groups generators.

On the other side it should be possible to add new algebraic structures to
{\GAP}. This requires the ability to add new categories (e.g. modules), new
representations for existing categories and domains (e.g. monomial matrices)
and new methods to {\GAP}.

We pursued these aims already two years ago. (They are mentioned already in
the old application.) But it took us more time than expected to find the
necessary concepts that made it possible to reach these goals.

The problem had been to make the concepts powerful enough to represent the
complex and intricate relations that may exist between mathematical objects
while keeping them simple enough to implement and apply them. In the words
of Albert Einstein: ``Make everything as simple as possible, but not more
simple''.

The wish to keep {\GAP} 4 compatible to {\GAP} 3 as far as possible did not make
this task easier either.

We finally introduced two essentially new concepts:

First, a significantly extended concept of types. It distinguishes what can
be done with an object, how the object is represented and what its relations
to other objects are. Additionally, the type contains information about the
knowledge one has about the object.

Secondly, a vastly extended scheme for the selection of methods.
It permits to select a
method for an operation based on the differnt parts of the types of all the
arguments (or operands).

We have implemented these concepts in {\GAP} 4. In this implementation, each
operation recalls
the argument types that occur most frequently and the method used for
them. (STIMMT DAS NOCH?)  If the operation is called again with arguments of
the same types, the needed method can be found quickly in the ``cache''.
In effect, the method selection in {\GAP} 4 is faster than in {\GAP} 3.

In the sequel we shall first state the aims more explicit (see "Aims").
Afterwards we describe the type concept (see "The Type Concept"). Then
the method selection ("Methods"). Finally we compare the
concepts to related concepts in other programming languages ("andere").

To ease the understanding of the remaining text the most important terms
will be introduced here already:

The objects that {\GAP} deals with (like the number 13, the list $[1,2]$ or a
matrix) are called {\bf objects}. Two objects that are the same (in the
sense of {\GAP} s = operation) represent the same {\bf element}. In other
words, elements are equivalence classes with respect to `='. Those objects
that represent structured sets are called {\bf domains} (for example the
group $S_{12}$ or a conjugacy class therein).

An *operation* behaves like a function, that is it gets called with
arguments and returns a result (like `Intersection(<arg1>,<arg2>)'
or `<op1>\*<op2>'). In
fact, however it consists of a multitude of functions which are called its
*methods*. Depending on the arguments a method is selected and gets
called.

The {\bf type} of an object represents the aspects which are important for
the method selection. It consists of several parts which could be imagined
as subsets of the set of all objects. The {\bf family} of an object
determines in which relation an object is to other objects (for example all
sets whose elements are permutations are a family). The {\bf categories} of
an object describe what can be done with an object (for example all monoids
are a category). The {\bf representation} of an object determines how the
object is stored in memory (for example all ``dense'' univariate polynomials
are of the same representation). Finally the type contains which attributes
or properties are known for the object and which values the properties have.

\Section{Aims}

Before describing the implementation of these new concepts in {\GAP} let us
look more closely on the aims:

\){{\rm Knowledge}}

The first aim is to have the possibility of using knowledge for further
computations. Another way of phrasing would be to make {\GAP} less ignorant.

For example there is a method (due to Baum and Clausen) for computing the
character table of a supersoluble group. This method applies to any
supersoluble group and is substantially faster than the standard method (due
to Dixon and Schneider) which is applicable to any group. If {\GAP} knows that
a group is supersoluble it should use this special method and not ignore the
knowledge it has already.

It should be emphasized that this may be {\bf obtained} knowledge. The
objective is to utilize all knowledge currently available about the relevant
objects and not only the knowledge that was known when the objects were
created.

Usually this means to consider properties (like `IsSolvable'). The
knowledge of attributes (like `Size') itself however is also a property
that can be useful for certain methods.

Finally, of course, the representation of an object may be utilized. (But 
as it is known when generating the object, this has been possible already in
{\GAP} 3).

Additionally {\GAP} should be able to draw simple conclusions. For example that
every cyclic group is abelian.

Or, to give a more complex example: Suppose we have created a permutation
group and have confirmed that it is nilpotent. Then the group is solvable as
well and so for computing the conjugacy classes a special method for
solvable groups is used.

It has not been our aim, however, to make {\GAP} ``intelligent''. That is, when
being asked for the character table of a group, {\GAP} will not try to check
first, whether it is supersoluble. The reason for this is that we have no
idea how to make the system decide which tests are worthwile and which are
not. It is possible, however, to enforce these tests for special methods
for which the potential gain in speed is that big and the test that cheap
in comparison. There are facilities, however, for a method author to enforce
this behaviour for specific methods if the test is deemed to be always
worthwile.

\){{\rm Extendability}}

The other main aim has been to permit extensions to {\GAP} without the need to
change existing code. Additionally, these extensions should embed nicely in
the existing structure. We list a few aspects:
\beginitems
New Categories&Adding Lie Algebras as a subcategory of non-associative
algebras should permit all operations for non-associative algebras to be
applicable to Lie Algebras as well. Of course we will need to add
representations for the new category as well to be able to define objects at
all.

New Representations&When adding new representations it should be
sufficient to write elementary routines to create objects in the new
representation and to allow basic manipulations. For example, for adding
sparse matrices only the new representation and methods to acess the
matrix components need to be implemented.

&Additionally one can add special operations for sparse matrices (like
`'Unsparsify'') or add new methods (like a sparse Gaussian elimination).
These can be added afterwards and don't need to be considered when
creating the new representation.

&It is also possible to specialize an existing representation (for example
monomial matrices as a special case of sparse matrices). Then every method
for sparse matrices is applicable to monomial matrices as well.

New Methods& Besides the methods needed to deal with new
operations, it is possible of course to add methods for existing operations.
For example one could add a new method to compute the character table of a
$p$-group. This method then would be selectable for a group as soon as the
group is known to be a $p$-group.
\enditems

\){{\rm Practicability}}

A main goal in the design finally was practicability. This means:

\beginitems
Usability&
Acessing special methods or new objects should be possible in a similar way
like in {\GAP} 3.

Independence& 
It must be possible to add new code with neither having to change existing
code, nor having to know about existing code. Also it should not be
necessary to basically copy code several times to add new functionality.

Reliability&
Any additions to the system should require no changes in existing code. They
also should affect only those parts of the system they directly interact
with (for example, installing a test for the nilpotence of a matrix group
should not change the behaviour of the Lie algebra routines unless they
require this test implicitely).

Efficency&
The system performance should not be diminuished by the availability of the
new features. This implies that the method selection has to be done quickly.
We are using method caching for the operations here.

There also is the possibility to replace library methods by handwritten C
code. Finally, a compiler that converts {\GAP} code into linkable C-Code is
available.

Implementability&
We had to be able to implement these features in a system. Our
research is in algorithms for group theory and not in the design or
implementation of programming languages.

\enditems

\Chapter{Problems in older versions}

{\GAP} 3 already had some of the features we desired, but there were a
couple of problems with them that led us to designing a new scheme.

\Section{Operation records}
The mechanism used in {\GAP} 3 to permit to select methods depending on
types has been operation records. Every object (which
is represented by a record) contains a component 'operation'. This
component is again a record, whose components are the actual functions which
are to be applied to the object. A dispatcher routine like 'Size' then
just called 'A.operations.Size(A)' to run the applicable method and
returned the result.

Inheritance simply works by copying of operation records. For example
'GroupOps' inherits from 'DomainOps', it overwrites some methods
(like 'Elements' which replaces an error call with a simple orbit
algorithm) and adds some new (like 'Centralizer') which are restricted
to groups.\par
Additionally to calling the routine from the operations record, dispatchers
might perform two additional tasks: The first is checking of the arguments
for applicability (like whether elements really lie in a group). The second
is storing results which are properties of the object in the object and
checking before calling the real routine whether the result is already
stored in the object.

Over the years we have learned about many difficulties with the scheme
described above. The first is the inability to cope well with multiple
arguments for which dispatching should be possible. Typical examples are
arithmetic operations. For these, the dispatcher (in the kernel) usually
dispatched after the first argument. While this works for homogeneous
situations, it becomes difficult if objects of different types are to
operated with: The routine of the left object has to know how to cope with
the right argument, that is it has to know about all possible types of the
right argument.

This becomes increasingly complicated if users implement new objects: If
they want to allow arithmetic operations with existing objects (this came
up for example when
adding algebraic extensions whose elements also should be multipliable with
polynomials), the arithmetic routines for these objects (which are probably
written by someone else, probably in the standard library and in the worst
case in the kernel) have to be changed.

The second disadvantage are problems in using different properties of an
object: The different operations form a pure tree. In some cases (like
homomorphisms from one type of group to another), however, one would like to
join different branches again at a lower point.

This can sometimes be solved by introducing new operation records.
Unfortunately, inheritance is purely linear and no provisions for
merging operation records (and probably even selecting the right routines in
each case) are provided.

A side effect of this (as well as of the first difficulty) are large numbers
of case distinctions in certain routines (like the polynomial multiplication
routines). These case distinctions are difficult to service and have been a
continuous source of nasty problems.

The third problem is mainly of administratorial nature but became almost
insolvable in some situations: The inheritance by copying not only means
that the parent classes operations have to be known to {\GAP} (so reading in
library files has to happen in the right order) but also that additions that
happen after the inheritance do not find their way to the child. This has led
to problems for example with 'SymmetricGroupOps'.

\Section{Sets that may be none}

{\GAP} represents sets by sorted lists. But if the objects in the list can
be changed, the list may suddenly be no set any longer

\beginexample
gap> l:=Set([[1,3],[3,2]]);
[ [ 1, 3 ], [ 3, 2 ] ]
gap> l[2][1]:=1;
1
gap> l=Set(l);  
false
\endexample

Of course, changing an entries entry may happen somewhere else, without the
list ever noting ist. The consequence of this behaviour is, that a list,
that contains composed objects may never store the fact that it is a set.
Each time, it is asked for this property, it has to be tested anew, whether
it is sorted.

If we actually want to keep composed objects in a set, however, to check
for example whether an object is already known, we don't gain anything from
using a ''set'' data type. Even worse: Instead of gaining from a binary
search, whenever we add an element to the set, we additionally test whether
it remained sorted.

In {\GAP} 3 this lead to substantial problems with the orbit algorithm on
vectors. The orbit algorithm keeps a set of all points it has encountered so
far. Vectors however are represented by lists, so they are composed objects.
Consequentially, the ''set'' used for testing is none. (Of course a
user could actually have provided a function for the action that
-- as a side effect -- would change existing vectors entries. So there is no
way around this problem.)

The remedy in {\GAP} 4 for problems of this type is the possibility to
''lock'' objects. By making an composed object *immutable*, one disallows
changes in its components (see "Mutability"). Lists of immutable objects
then may store a flag that they are sorted -- and thus a set -- as no
side-effects may take place.


\danger
User of other systems should note that domains
are simply objects and not a part of the typing system as for example in
Axiom.


\danger
Internally, {\GAP} carries internal bit lists (different to `Blist's) to
indicate categories, representations and so on. A filter is an interface to
these bit lists.


\danger
But you main install special methods for these operations that cross
families.


New families are created by 

\>NewFamily(<name>[,<required-fil>[,<implied-fil>]])

returns an object that represents the new family.

\beginitems
<name>&is a string, giving a name that identifies the family. It is mainly
used in error messages.

<required-fil>&is a filter that gives required categories for each object in
this family. Any attempt to create an object in this family that does not
lie in these categories leads to an error.

<implied-fil>&is a filter that gives implied categories.
Each object in the
family is automatically made an object of these categories, regardless of
whether they were given when generating the object. An example is the
category `IsPermutationSet' which is given to all sets of permutations
automatically.
If no categories are given, no are implied.
\enditems

\>CollectionsFamily(<family>)

creates a new family whose elements are collections of elements of <family>.
For example the family of $S_3$ is the collections family of the family of
permutations.

\>ElementsFamily(<family>)

returns the family of elements for a collections family. It is the reverse
operation for `CollectionsFamily'.

\danger
\label{storeinfamily}
Families themselves are component objects. They are usually the place where
to store
information needed for operations on its elements. For example the
presentation of a finitely presented group will be stored in its elements
family to permit access for the equality test.

\danger
As families are objects themselves, they also have a kind and a family.
These are the `FamilyOfFamilies' and the `KindOfFamilies'.

\Section{Categories}

A category determines what can be done with its elements. More exact: Each
operation is declared with a tuple of categories that defines to which
categories the arguments of this operation must belong. (Additionally, some
operations may demand that the families of its arguments are in certain
relations, for example equal.)

An object may belong to more than one category. A ring, for example, belongs
to the categories `IsDomain', `IsAdditiveMagma' (domains that are closed under
addition) and `IsMagma' (domains closed under multiplication).

\danger
Whenever an object is created, the categories to which the object belongs
have to be declared. However the family might imply further categories (and
these do not need to be declared explicitely when creating the object).
For example any
group of permutations belongs implicitely to the category `PermutationSets'.


With these categories and properties, we can declare vector spaces as
follows:

IsFieldNonExtLSet = \\
\ \ AdditiveMagmaWithInverses \& \\
\ \ nMagmaWithInversesAndZero \& IsAssociative \& IsCommutative

VectorSpace = \\
\ \ AdditiveMagmaWithInverses \& \\
\ \ ExtLSet \& IsExtLDistributive \& IsExtLUnital \& IsExtLAssocicative \& \\
\ \ IsExtLField

New categories are created by the function

\> NewCategory(<name>[,<super-cat>]) !{category creation}

This function returns an filter that represents the category. As it is a filter
it can also be used as an function, to test whether an object belongs to this
category and returns `true' or `false'. Therefore categories ususally are
called like `IsPiffle'.

\beginitems
<name>&is a string, giving a name to the category. It is mainly used for
debugging purposes.

<super-cat>&is a filter representing the intersection of all categories this
category is to be a subcategory of. All categories are implicitely
subcategories of `IsObject'.
\enditems


\Section{Representations}

A representation determines how objects are stored in memory.

There are three classes of objects: Internal objects (like rational numbers,
permutations or words in abstract generators), *positional objects* and
*component objects*. Positional objects behave basically like a list with
the exception that components are accessed by `<lobj>\/![<pos>]'
(with an additional `!'). Component objects behave
like records, except that components get accessed by `<robj>\/!.<component>'.

\danger
The function `Length' will not work for positional objects. The function
`RecNames' will not work for component objects. There is, however, a
function `REC_NAMES_ROBJ' that will provide the components of an component
objects for debugging purposes.

The representation of an object determines whether it is an component
object or an positional object. It also determines the component names
present in an component object.
(This is not yet supported).

An object may belong to several representations.

\danger
An object may change its representation during runtime. In general this is
only useful for mutable objects and should be used with great care.

\danger
Representations are created while the library code is read in. During runtime,
no further categories will be created.

New representations are created by 

\>NewRepresentation(<name>,<super-fil>,<components>[,<required-cat>])

This function returns a filter that represents the representation and can be
used to test membership in this representation.
Therefore representations ususally are called like `IsWoffle'.

\beginitems
<name>&is a string, giving a name to the representation. It is mainly used for
debugging purposes.

<super-fil>&is a filter, used to determine all super-representations and all 
categories implied by this representation. The super-representations
`IsPositionalObjectRep' or `IsComponentObjectRep' determine, whether it will
be a representation of positional or components objects, so one of them
should be given always (might be implicitely).

<components>&is a list of strings, giving the names of the components an
component objects may have. This field is ignored for positional objects.
If a field ends in `?' this component is facultative for component objects.
If a component name ends in `\*', all components starting this way are
permitted.

<required-cat>&VERLANGTE KATEGORIEN
\enditems

\danger
An interesting representation is the representation `WhatsItsName' used for
representing most domains. It is a subrepresentation of
`IsComponentObjectRep', having no compulsory components but permitting any.

\danger
If several representations are used to represent objects in one family, it
is often desirable to have some unified way to treat elements of all
representations. The standard way to do this in {\GAP} is via *external
representations*. These external representations are usually defined for a
family and are a list or a record that allows to present all information in
the representation. The operation 
\>ExtRepOfObj(<obj>)

then should be used to obtain the external representation of
an object. Vice versa 
\>ObjByExtRep(<family>,<ext-rep>)

will create an object in the given <family> from the external representation
<ext-rep>. If you introduce new representations you might have to write
methods for these two operations.

\danger
Categories and Representations are both filters and thus cannot be easily
distinguished. They are conceptually different but implemented by the same
means.

At this point we could explain how objects are actually made. It seems
better didactically, however, to explain first how the method selection
works (you will need this more often anyhow.) If you are curious, have a
glance at section "Kinds and Objects".


\danger
In {\GAP} 3 something slightly similar was accomplished using dispatcher
functions and operation records. But these functions only allowed to
dispatch on one argument and only on information given when the object was
created.

A new operation is created using
\>NewOperation(<name>,<argfilters>)

This command creates a new operation, whose name (used for debugging
purposes) is the string <name>.

<argfilters> is a list of filters that correspond with the operations
arguments: The operation is defined with as many arguments as <argfilters> has
entries and the arguments with which the operation is called have to fulfill
the conditions prescribed by the appropriate filter, otherwise an error is
raised. Similarly, every method installed for the operation must be at least
as restrictive as the conditions given by <argfilters>, otherwise an error
is raised.

If an operation is called with arguments for which no suitable method
is installed, an error is raised.

\danger
It is not possible to declare an operation several times for a varying
number of arguments or different argument filters. You must use
`InstallOtherMethod' in such cases.


Usually all operation declarations will be read first and all methods
installed afterwards. This permits an method to call other operations, as
all operations are known when the method is installed. To acchieve something
similar for ordinary functions, there is the command

\>NewOperationArgs(<name>)

This command just creates a pseudo-function that serves as a forward
reference for a function that will be declared elsewhere.

\Section{Attributes and Properties}


\danger
An object may also claim that it knows an attribute if computation of this
attribute would be very easy. A vector space, for example, may claim that
it knows its size once it knows its dimension and the characteristic of the
underlying field. 

Thus attributes can be considerd as sets, comprising all objects that know
this attribute. In general an object will initially not belong to any of
these sets but become a member during runtime.

\danger
Attributes are created while the library code is read in. During runtime, no
further attributes will be created.

New attributes are created by

\>NewAttribute(<name>[,<filter>])

This function returns an operation that will be used to determine the value
of this attribute. It implicitely installs one method for this operation,
namely the operation that just fetches the already known value.

\danger
This is done by implicitely installing a method, called the *system getter*
for the operation with value `SUM_FLAGS'. This number is some kind on
`'infinity'' for method valuations. Thus, once the attribute is known, this
method will be called. If you design situations, however, in
which objects will claim to posess an attribute while actually still having
to compute it (like in the vector space example above), this would lead to
*your* method (which does the computation) not being called and the system
getter complaining about not finding the attributes value. The solution is 
to install your method with the value `SUM_FLAGS+1' to give it priority
over the system getter.

<name> is again a string, used to identify the attribute.

<filter> determines, for which categories this attribute applies.
\){\fmark Tester(<attribute>)}
\){\fmark Setter(<attribute>)}

Additionally, `NewAttribute' installs a filter (the *tester*) and another
operation (the *setter*) for this attribute. The
filter determines whether the attribute is known while the operation can be
used to set the attribute to a given value (if its value is obtained
implicitely in an algorithm). A standard use is like
\beginexample
Biffle:=NewAttribute("Biffle");
HasBiffle:=Tester(Biffle);
SetBiffle:=Setter(Biffle);
\endexample

Then `HasBiffle' will test, whether the biffle of an object is known,
SetBiffle(<obj>,<value>) will set an objects biffle.

\danger
The setter in fact is again an operation which has a standard method
installed at value `SUM_FLAGS' which just stores the attribute. You can
install another method that may, for example, immediately store
dependent information. WIE BEKOMMT MAN DAS ATTRIBUT DANN GESPEICHERT?

As each attribute defines an operation, methods can be installed to compute 
the value of this attribute for certain types of objects. Any value returned
by the function will be assigned automatically to the attribute, you don't
need to call the setter.

\danger
Storing all computed attributes for an object may take substantial space. On
the other hand there might be objects that are that unimportant that you
do not want to store attributes for them. Therefore attributes will be
stored only, if the representation of the object is a subrepresentation of
`IsAttributeStoringRep'. KANN DAS POSITIONAL SEIN ?

\danger
Attributes are by standard immutable. In some situations an attribute will
be used, however, to store partial information about an object that may be
completed later. A special case of this are parametrized attributes, where
we don't want to create a new attribute for each value of the parameter.
Sylow subgroups are a good example: We cannot create an atttribute for each
prime number. Instead there is an attribute `ComputedSylowSubgroups' that is
a list, containing in its $i$-th component the $i$-Sylow subgroup (provided
$i$ is a prime). The function `SylowSubgroup' then will access this list and
compute further sylow subgroups if neccessary using the operation
`SylowSubgroupOp'. storing the result again in the list
`ComputedSylowSubgroups'.

\danger
To obtain a mutable attribute for such purposes, simply add the string 
`' `mutable' `` to the parameter list when defining the attribute with
`NewAttribute'

\danger
Another aspect of the immutability of attributes is that you usually cannot
change an attribute. Calling the setter later with a different value just
will be ignored.

\>NewProperty(<name>[,<filter>])


\danger
It must be pointed out, however, that for the purposes of method selection
the filters that return the value of a property are only fulfilled if the
value of the property is known. In other words, the method selection will
not compute the value of an property just to see whether a method is
applicable. (Such a behaviour would otherwise lead to potentially disastrous
runtime effects.) Doing such things sensibly would require a level of
intelligence which is beyond the scope of a computer program. 

\danger
If you have cases where a certain property is that beneficial that
it is actually worth to force determination of this property, you will have
to install the method without requiring this property, first test in your
function for the value of the property and if this is `false' call
`TryNextMethod()' to retreat gently.

\danger
A variation of this theme is if you have classes of objects for which
a certain attribute can be computed very cheaply. In this case you would not
require `HasPiffle' when installing the method, but add a new property
`IsPiffleObtainable'. All objects in the special class should get this
property implicitly when creating them (either directly in the `Objectify'
command or by a true or immediate method), while an implication would imply
that each object for which `HasPiffle' returns `true' actually would be
`IsPiffleObtainable' as well.

<value> is an integer value given to this function. This value determines
`'how well'' the method performs. Unless you want to acchieve a special
effect this will be 0.

How do all these arguments interlink with each other:

If an operation gets called, {\GAP} first selects all methods that are
*applicable*. That are those methods, for which the family predicate
returns `true' when applied to the families of the arguments and for which
all filters for all arguments return `true'. These methods then are sorted
according to an ``implicit value'': For each filter involved in one of the
<argflags> one point is given. That is, if we define `IsC' as `IsA and
IsB', then `IsC and IsD' gets 3 points (or even more if `IsA', `IsB' or
`IsD' are composite themselves).
To this number the installed <value> is
added.
(Actually this sorting can take place already when installing the method, so
there is no time loss for this during execution.)
Then the method with the highest value is executed and any result it returns
returned as the result of the operation.

This ``value business' allows for three aims: First, usually (nobody should
install such a method otherwise) a special method will be better than a
general one. This special method then however would have more filters in its 
<argflags>, thus get a higher implicit value and is favoured if applicable.

Second, there may be the case of concurrent methods whose specifications are
not subsets of each other. Suppose, for example we have two (simple) filters,
`IsBourbakian' and `IsLowerRegularQ' which have no relation whatsoever.
Suppose for an operation we have one method each installed for both filters.
If we now call this operation with an argument that is bourbakian and
fulfills the lower regular Q property, the method whose <value> is larger
gets selected. This allows to tell {\GAP} which filters will  lead to
especially cheap methods for certain operations.

Thirdly, giving a high value to a method permits to override decisions taken
before. If for example for test purposes a more general method should be
used, it is sufficient to install this method with a higher value than the
special one.

\danger
To speed up the process of method selection, each method caches the last 3
tuples of kinds with which it got called and the method selected for these.
This allows the selection process to proceed very swiftly in cases (like
multiplications) where the same method is called very frequently.

\danger
The list of (applicable) methods for an operation is always sorted in a way
to have newer methods coming first. Thus a method installed with the same
parameters as an existing method will supersede this. This allows to
re-install a corrected method (beware of problems here if the corrected
method calls `TryNextMethod'!).


Immediate methods can lead to substantial losses in runtime if a
method gets called too often or if the function installed actually *takes*
time. They should be used with care!

\danger
For calling immediate methods, {\GAP} actually does the following: 
Whenever a filter is set for an object, all installed immediate methods,
that need this filter to be applicable are run if the attribute is not yet
known and if they are applicable.

\danger
If you are creating objects and setting attributes in them you might want to
avoid immediate methods to be run, as you will set the immediately obtainable
attributes yourself. This can be acchieved using the variable

\){\fmark IGNORE_IMMEDIATE_METHODS}

While this variable is set to `true' (it is set to `false' by default) no
immediate methods will be called.

\Section{Tracing and profiling methods}

The implicit choices made by {\GAP} when calling a method can make it quite
difficult to find out which method is actually called. This is necessary
however, partially for debugging purposes and partially to learn which
algorithm is actually used. 

\>TraceMethods(<opr>,<opr>,...)
\>UntraceMethods(<opr>,<opr>,...)

induced {\GAP} to print information whenever one of the operations given to
trace is called. This information consists of the name of the operation
(given as the string <name>) and -- if present -- the name of the method
(given as the string <ident>)
Tracing is turned off again by `UntraceMethods'.

\beginexample
gap> TraceMethods(Size);
gap> g:=Group((1,2,3,4),(1,2));
Group( [ (1,2,3,4), (1,2) ], ... )
gap> Size(g);
#I  Size
#I  Setter(Size): system setter
#I  Size: system getter
#I  Size: system getter
24
gap> UntraceMethods(Size);
\endexample

\>MethodXArgs(<opr>,<arglist>[,<printlevel>[,<skip>]])

calls the method selection mechanism for the operation <opr>, applied to the
arguments given in <arglist> without actually applying the method, but
returning the *method* itself instead.

If <printlevel> is given, information about
the decisions of the method selection mechanism is printed:

\beginitems
1&Prints information about the selected method

2&Prints information about each method encountered on the way there (but not
chosen)

3&Prints for each of these methods the first reason why it has not been
applicable

4&Prints all reasons, why the methods not selected were not applicable.
\enditems

If <skip> is given as a positive integer, that many applicable  methods will
be skipped. This can be used to examine cases that call `TryNextMethod'.

If <skip> is a negative integer, a list of all applicable methods (sorted by
value) is returned instead.

\>ProfileOperations()
\>ProfileMethods()

UND SO WEITER.


\Section{Kinds and Objects}

Finally, we have to explain, how new objects are really made.

This section explains what a kind actually is and how the method selection
works internally. It also tells you how to make objects.
If you are not creating your own objects, you will not need to know this
for installing own methods, but it might be helpful for understanding the
innards of {\GAP} anyhow.

The type of an object is composed from its family and the filters set for
it. It can be created by

\>NewKind(<family>,<filter>)

Here <family> is the family for the kind and <filter> determines categories
and representations. Each object of this kind will belong to <family> and
all the categories and representations of <filter>.

\danger
To save memory,
{\GAP} internally keeps a list of all known kinds. NewKind actually will
only create a new kind if it is not in this list and otherwise return a
kind from
this list, if it fulfills exactly the requirements. A cache for the most
recent kinds is used to avoid long searches over the list of all kinds.

Whenever new filters are set for an object, its kind changes, if necessary
creating a new kind implicitely.

The method selection mechanism actually only looks at the kinds of the
arguments and fetches the necessary informations from them.

\danger
As kind are objects themselves, they also have a kind and a family.
These are the `FamilyOfKinds' and the `KindOfKinds'.

Usually, kinds are created just as intermediate steps to construct *objects*:

\>Objectify(<kind>,<rlobj>)

makes a new object. This object will have family, categories and
representations as prescribed by <kind>.
<rlobj> is either a record or a list (depending whether the representation
is a subclass of `IsComponentObjectRep' or `IsPositionalObjectRep') that
will be converted to a positional object or a list object to actually form
the object.

\danger
Despite the caching of kinds, if you expect to create a lot of
new objects (as, for example, when implementing new arithmetical objects,
where each infix opertion will create a new object), it can be helpful to
store the *default kinds* (the kinds with which objects will be
created) in the family to avoid calls to `NewKind' (see "storeinfamily").


\Section{Simulating Lists and Records}

{\GAP} permits objects to behave as if they were lists or records. In these
cases, components can be accessed in the usual way, while actually a
function computes the result returned. Enumerators ("Enumerators") for
example behave that way. This permits to have something like a list of
elements even for infinite objects like the integers.

This simulation for lists works via four special operations:

\){\fmark \\[\\](<obj>,<pos>)}
\index{$\backslash[\backslash]$}
\){\fmark \\[\\]\\:\\=(<obj>,<pos>,<arg>)}
\){\fmark IsBound\\[\\](<obj>,<pos>)}
\){\fmark Unbind\\[\\](<obj>,<pos>)}

These operations are defined for the category tuple
('IsList', `IsInt and IsPosRat') (respectively <IsObject> added for
$\backslash[\backslash]\backslash:\backslash=$).
<obj> is the object simulating a list, <pos> is a positive integer, giving
the list position.

They allow to simulate list access, assignments, test for boundness and
removal of list elements by the installed method. The installed methods will
respecively
return the simulated list value, assign the value, remove it or test for
boundness.

The simulation for records works via the following four special operations:

\){\fmark \\.(<obj>,<rnam>)}
\index{$\backslash\.$}
\){\fmark \\.\\:\\=(<obj>,<rnam>,<arg>)}
\){\fmark IsBound\\.(<obj>,<rnam>)}
\){\fmark Unbind\\.(<obj>,<rnam>)}

These operations are defined for the category tuple
('IsObject', `IsInt and IsPosRat') (espectively <IsObject> added for
$\backslash\.\backslash:\backslash=$).
<obj> is the object simulating a list, <rnam> is a component
identifier (see below).

The operations allow to simulate record access, assignments, test for
boundness and removal of list elements by the installed method. The 
installed methods will respectively
return the simulated record component, assign the value, remove it or test for
boundness.

\>RNamObj(<string>)
\>NameRNam(<int>)

When a record components is accessed, the components name is parsed and
replaced by a number, the <rnam>, which identifies it. This permits among
other things to
save storage space, as each record components name is stored only once in
memory. Thus, for example, it is unimportant whether a long components name
occurs frequently. 

The functions to simulate record access use this <rnam>. The function
`RNamObj' returns the <rnam> of a <string>, the function `NamRNam' returns
the string for a <rnam> number.

As the <rnam> identifiers are allocated while reading in the library,
reference should never be to absolute numbers, but using these tranlation
function. For example, the following method could be used to allow access to
a groups generators via the `<G>.generators' as has been possible in {\GAP}
3:

\beginexample
ID_NUMBER_GENERATORS:=RNamObj("generators");
InstallMethod(\.,"access to .generators",true,[IsGroup,IsPosRat and IsInt],0,
function(g,n)
  g:=GeneratorsOfGroup(g);
  if n<>ID_NUMBER_GENERATORS then
    TryNextMethod();
  fi;
  return GeneratorsOfGroup(g)l
end);
\endexample


\Section{Family Predicates}

In this section we list some common family predicates used throughout the
library.

\beginitems
`IsElmsColls(<A>,<B>)'&

`IsNotElmsColls(<A>,<B>)'&

`IsElmsCollColls(<A>,<B>,<C>)'&

`IsCollsElms(<A>,<B>)'&

`IsCollCollsElms(<A>,<B>,<C>)'&

`IsCollsElmsElms(<A>,<B>,<C>)'&

`IsCollsElmsElmsElms(<A>,<B>,<C>,<D>)'&

`IsCollsElmsElmsX(<A>,<B>,<C>,<D>)'&

`IsCollCollsElmsElms(<A>,<B>,<C>,<D>)'&

`IsCollsCollsElms(<A>,<B>,<C>)'&

`IsCollsXElms(<A>,<B>,<C>)'&

`IsFamFamXY(<A>,<B>,<C>,<D>)'&

`IsLieFamFam(<A>,<B>,<C>)'&

`IsFamLieFam(<A>,<B>,<C>)'&

`IsElmsLieColls(<A>,<B>,<C>)'&

`IsElmsCollLieColls(<A>,<B>,<C>,<D>)'&

`IsCollLieCollsElms(<A>,<B>,<C>,<D>)'&

`IsCoeffsElms(<A>,<B>)'&

`IsElmsCoeffs(<A>,<B>)'&

`FamRangeEqFamElm(<A>,<B>)'&

`FamSourceEqFamElm(<A>,<B>)'&

`CollFamRangeEqFamElms(<A>,<B>)'&

`CollFamSourceEqFamElms(<A>,<B>)'&

`FamElmEqFamRange(<A>,<B>)'&

`FamElmEqFamSource(<A>,<B>)'&

`FamSource2EqFamRange1(<A>,<B>)'&

`FamSource1EqFamRange2(<A>,<B>)'&

`FamRange1EqFamRange2(<A>,<B>)'&

`FamMapFamSourceFamRange(<A>,<B>)'&

`FamSourceRgtEqFamsLft(<A>,<B>)'&

`FamSourceNotEqFamElm(<A>,<B>)'&

`FamRangeNotEqFamElm(<A>,<B>)'&

`IsMagmaRingsRings(<A>,<B>)'&

`IsRingsMagmaRings(<A>,<B>)'&

`IsMagmasMagmaRings(<A>,<B>)'&

\enditems

