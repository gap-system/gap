%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  create.tex                GAP manual                    Thomas Breuer
%A                                                       Martin Schoenert
%%
%H  @(#)$Id$
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Creating New Objects}

The first sections of this chapter inform how filters are created,
see "Creating Categories", "Creating Representations",
"Creating Attributes", "Creating Other Filters".

The section "Creating Operations" describes how operations
are created.

Then the sections "Creating Families", "Creating Types",
and "Creating Objects" describe how families, types,
and objects are created.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Categories}

\>NewCategory( <name>, <super> )

`NewCategory' returns a new category <cat> that has the name <name> and
is a subcategory of the category <super>.
This means that every object in <cat> lies automatically also in <super>.

For example, if one wants to create a category of group elements
then <super> should be `IsMultiplicativeElementWithInverses' or a
subcategory of it.
If no specific supercategory of <cat> is known,
<super> may be `IsObject'.

The incremental rank of <cat> is 1.

Two functions that return special kinds of categories are of importance.

\>CategoryCollections( <cat> )

For a category <cat>,
`CategoryCollections' returns the *collections category* of <cat>.
This is a category in that all collections of objects in <cat> lie.

For example, a permutation lies in the category `IsPerm',
and every dense list of permutations and every domain of permutations
lies in the collections category of `IsPerm'.

\>CategoryFamily( <cat> )

For a category <cat>,
`CategoryFamily' returns the *family category* of <cat>.
This is a category in that all families lie that know from their
creation that all their elements are in the category <cat>,
see "Creating New Families".

For example, a family of tuples is in the category
`CategoryFamily( IsTuple )',
and one can distinguish such a family from others by this category.
So it is possible to install methods for operations that require one
argument to be a family of tuples.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Representations}

\>NewRepresentation( <name>, <super>, <slots> )

`NewRepresentation' returns a new representation <rep> that has the name
<name> and is a subrepresentation of the representation <super>.
This means that every object in <rep> lies automatically also in <super>.
The third argument <slots> is a list either of integers or of strings.
In the former case, <rep> must be `IsPositionalObjectRep' or a
subrepresentation of it, and <slots> tells what positions of the objects
in the representation <rep> may be bound.
In the latter case, <rep> must be `IsComponentObjectRep' or a
subrepresentation of, and <slots> lists the admissible names of
components that objects in the representation <rep> may have.
The admissible positions resp. component names of <super> need not be
be listed in <slots>.

The incremental rank of <rep> is 1.

Note that none of the positions resp. component names is compulsory for
an object in the representation <rep>.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Attributes and Properties}

\>NewAttribute( <name>, <filt> )
\>NewAttribute( <name>, <filt>, <rank> )

`NewAttribute' returns a new attribute <attr> with name <name>.
The arguments for <attr> are expected to lie in the filter <filt>,
and <filt> describes the implied filters of <attr>.
The optional third argument <rank> denotes the incremental rank of
the tester of <attr>, the default value is 1.

\>NewAttribute( <name>, <filt>, "mutable" )
\>NewAttribute( <name>, <filt>, "mutable", <rank> )

If the third argument is the string `"mutable"', the stored values of the
new attribute are not forced to be immutable.
This is useful for an attribute whose value is some partial information
that may be completed later.
For example, there is an attribute for the list of all Sylow subgroups
of a group that have been computed already,
and this list is mutable because one may want to enter groups into it
as they are computed.

\>NewProperty( <name>, <filt> )
\>NewProperty( <name>, <filt>, <rank> )

`NewProperty' returns a new property <prop> with name <name>.
The arguments for <prop> are expected to lie in the filter <filt>,
and <filt> describes the implied filters of <prop>.
The optional third argument <rank> denotes the incremental rank of
the property <prop> itself, i.e. *not* of its tester,
the default value is 1.

Each method that is installed for an attribute or a property
via `InstallMethod' must require exactly one argument,
and this must lie in the filter <filt> that was entered as second
argument of `NewAttribute' resp. `NewProperty'.

One can install methods for an argument that does not lie in <filt>
via `InstallOtherMethod',
but is impossible to install methods for more than one argument.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Other Filters}

\>NewFilter( <name> )
\>NewFilter( <name>, <rank> )

It is also possible to create a simple filter that is not a category,
a representation, or an attribute.
Such a new filter with name <name> is returned by `NewFilter'.
The optional second argument <rank> denotes the incremental rank of the
filter, the default value is 1.

Suppose <filt> is a filter returned by `NewFilter'.
Contrary to categories and representations, it is not necessary that
each object knows at the time of its creation whether or not it lies in
<filt>.
Contrary to attributes and properties, one cannot install methods to
compute the value of <filt> for an object, and also `Setter' and
`Tester' do not work for <filt>.

In order to change the value of <filt> for an object <obj>,
one can use only the functions

\>SetFilterObj( <obj>, <filt> )
\>ResetFilterObj( <obj>, <filt> )

`SetFilterObj' sets the value of <filt> for <obj> to `true',
`ResetFilterObj' sets the value of <filt> for <obj> to `false'.
The default value of <filt> for each object is `false'.

%T Categories and representations should not be operations,
%T the same for filters made by `NewFilter'!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Operations}

\>NewOperation( <name>, <args-filts> )

`NewOperation' returns an operation <opr> with name <name>.
The list <args-filts> describes requirements about the arguments
of <opr>, namely the number of arguments must be equal to the length of
<args-filts>, and the $i$-th argument must lie in the filter
`<args-filts>[$i$]'.

Each method that is installed for <opr> via `InstallMethod' must require
that the $i$-th argument lies in the filter `<args-filts>[$i$]'.

One can install methods for other arguments tuples via
`InstallOtherMethod',
this way it is also possible to install methods for a different number
of arguments than the length of <args-filts>.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Families}

\>NewFamily( <name> )
\>NewFamily( <name>, <req> )
\>NewFamily( <name>, <req>, <imp> )

`NewFamily' returns a new family <fam> with name <name>.
The argument <req>, if present, is a filter of that <fam> shall be a
subset.
If one tries to create an object in <fam> that does not lie in the filter
<req>, an error message is printed.
Also the argument <imp>, if present, is a filter of that <fam> shall be a
subset.
Any object that is created with the family <fam> will lie automatically
in the filter <imp>.

As an example, consider

\>CollectionsFamily( <fam> )

`CollectionsFamily' is an attribute that takes a family <fam> as
argument, and returns the family of all collections over <fam>,
that is, of all dense lists and domains that consist of objects in
<fam>.

The `NewFamily' call in the standard method of `CollectionsFamily'
is executed with second argument `IsCollection',
since every object in the collections family must be a collection,
and with third argument the collections categories of the involved
categories in the implied filter of <fam>.

If <fam> is a collections family then

\>ElementsFamily( <fam> )

returns the family with collections family <fam>.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Types}

\>NewType( <fam>, <filt> )
\>NewType( <fam>, <filt>, <data> )

`NewType' returns the type given by the family <fam>
and the filter <filt>.
The optional third argument <data> is any object that denotes defining
data of the desired type.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Objects}

\>Objectify( <type>, <data> )

New objects are created by `Objectify'.
<data> is a list or a record.
If <data> is a list then `Objectify' turns it into a positional object,
if <data> is a record then `Objectify' turns it into a component object.
In both cases, the object gets the type <type>.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Implementation}

In this chapter, ...

"Declaration and Implementation Part"

Section "External Representation" introduces the external representation
of objects.

Finally, a small example of the implementation of list objects is given
in Section "Example: Implementing List Objects".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Declaration and Implementation Part}

Each package of {\GAP} code consists of two parts,
the *declaration part* that defines the new categories and operations for
the objects the package deals with,
and the *implementation part* where the corresponding methods are
installed.
The declaration part should be representation independent,
representation dependent information should be dealt with in the
implementation part.

{\GAP} functions that are not operations and that are intended to be
called by users should be notified in the declaration part via

\>NewOperationArgs( <name> )

`NewOperationArgs' returns a function that serves as a placeholder
for the function that will be installed in the implementation part,
and that will print an error message if it is called.

% what anbout
% \>InstallMethodArgs( ... ) ???


Calls to the following functions belong to the declaration part.

`InstallTrueMethod'
`NewAttribute',
`NewCategory',
`NewFilter',
`NewOperation',
`NewOperationArgs',
`NewProperty'.

Calls to the following functions belong to the implementation part.

`InstallMethod'
`InstallImmediateMethod'
`InstallOtherMethod'
`NewFamily',
`NewRepresentation',
`NewType',
`Objectify'.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{External Representation}

An operation is defined for elements rather than for objects in the sense
that if the arguments are replaced by objects that are equal to the old
arguments w.r.t. the equivalence relation ```=''' then the result must be
equal to the old result w.r.t. ```='''.

But the implementation of many methods is representation dependent in the
sense that certain representation dependent subobjects are accessed.

For example, a method that implements the addition of univariate
polynomials may access coefficients lists of its arguments
only if they are really stored, 
in the case of sparsely represented polynomials a different approach is
needed.

In spite of this, for many operations one does not want to write an own
method for each tuple of representations of the arguments,
for example because there is no way to take advantage from the given
representation of objects,
or because one wants to install one representation independent method
first, and then add specific methods as they are needed to gain more
efficiency.

For this purpose,
one can define an *external representation* of objects in a given family,
install methods to compute this external representation for each
representation of the objects,
and then for other operations install methods that use only the external
representation.

The external representation of an object <obj> does in general *not* lie
in the same family as <obj>,
it only encodes the object <obj> in such a way that from this data and
the family of <obj> one can create an object that is equal to <obj>.
Usually the external representation of an object is a list or a record.
For example, a polynomial may have a suitable coefficients list as
external representation;
note that is may be necessary to have the zero coefficient as part of
the external representation of polynomials if the family of the
polynomials does not determine the zero coefficients uniquely.

To implement an external representation means to install methods for the
following two operations.

\>ExtRepOfObj( <obj> )
\>ObjByExtRep( <fam>, <data> )

`ExtRepOfObj' returns the external representation of its argument,
and `ObjByExtRep' returns an object in the family <fam> that has
external representation <data>.

Of course, `ObjByExtRep( FamilyObj( <obj> ), ExtRepOfObj( <obj> ) )'
must be equal to <obj>.
But it is *not* required that equal objects have equal external
representations.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Example: Implementing List Objects}

A list in {\GAP} is an object in the category `IsList'.
Basic operations for lists are `Length', `\\[\\]', `IsBound\\[\\]',
where the access to the position <pos> in the list <list>
via `<list>[<pos>]' is handled by the call `\\[\\]( <list>, <pos> )',
and the check whether the position <pos> of the list <list> is bound
via `IsBound( <list>[<pos>] )' is handled by the call
`IsBound\\[\\]( <list>, <pos> )'.

For mutable lists, also assignment to positions and unbinding of
positions via the operations `\\[\\]\\:\\=' and `Unbind\\[\\]'
are basic operations,
where the assignment `<list>[<pos>]:= <val>' is handled by the call
`\\[\\]\\:\\=( <list>, <pos>, <val> )',
and `Unbind( <list>[<pos>] )' is handled by the call
`Unbind\\[\\]( <list>, <pos> )'.

All other operations for lists, e.g., `Add', `Append', `Sum',
are based on these operations.
This means that it is sufficient to install methods for the basic
operations for the new list objects.

So new list objects are created as objects in the category `IsList'
for that methods for `Length', `\\[\\]', and `IsBound\\[\\]' are
installed,
and perhaps also for `\\[\\]\\:\\=' and `Unbind\\[\\]'.

One application for this is the implementation of *enumerators*
for domains.
An enumerator for the domain $D$ is a dense list whose entries are
in bijection with the elements of $D$.
If $D$ is large then it is not useful to write down all elements.
Instead one can implement such a bijection implicitly,
and this works even for infinite domains.

In this situation, one implements a new representation of the
lists that are already available in {\GAP},
especially the family of such a list is the same as the family of
the domain $D$.

But it is also possible to implement new kinds of lists that lie in
new families, and thus are not equal to lists that were available
in {\GAP} before.
An example for this is the implementation of matrices
whose multiplication via ```\\\*''' is the Lie product of matrices.

In this situation, it makes no sense to put the new matrices into the
same family as the original matrices.
Note that the product of two Lie matrices shall be defined but not the
product of an ordinary matrix and a Lie matrix.
So in this case it is possible to have two lists that have the same
entries but that are not equal w.r.t. ```=''' because they lie in
different families.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

