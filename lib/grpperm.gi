#############################################################################
##
#W  grpperm.gi                  GAP library                    Heiko Thei"sen
##
#H  @(#)$Id$
##
#Y  Copyright (C)  1996,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
Revision.grpperm_gi :=
    "@(#)$Id$";


#############################################################################
##
#M  IsFinite( <G> ) . . . . . . . . . . . . . . .  for magmas of permutations
##
#T  To tell the truth, we should ask whether the magma is finitely generated.
#T  (What would be a permutation with unbounded largest moved point?
#T  Perhaps a permutation of possibly infinite order?)
##
InstallTrueMethod( IsFinite, IsPermCollection and IsMagma );
    

#############################################################################
##
#F  CycleStructurePerm( <perm> )  . . . . . . . . .  length of cycles of perm
##
CycleStructurePerm := function ( perm )
    local   cys,    # collected cycle lengths, result
            degree, # degree of perm
            mark,   # boolean list to mark elements already processed
            i,j,    # loop variables 
            len,    # length of a cycle 
            cyc;    # a cycle of perm

    if perm = () then
        cys := [];
    else
        degree := LargestMovedPointPerm(perm);
        mark := BlistList([1..degree], []);
        cys := [];
        for i in [1..degree] do
            if not mark[i] then 
               cyc := CyclePermInt( perm, i );
               len := Length(cyc) - 1;
               if 0 < len  then
                  if IsBound(cys[len])  then
                     cys[len] := cys[len]+1;
                  else
                     cys[len] := 1;
                  fi;
               fi;
               for j in cyc do
                  mark[j] := true;
               od;
            fi;
        od;
    fi;
    return cys;
end;

#############################################################################
##
#F  RestrictedPerm(<g>,<D>)  restriction of a permutation to an invariant set
##
RestrictedPerm := function( g, D )
    local   res, d, e, max;

    # check the arguments
    if not IsPerm( g )  then
        Error("<g> must be a permutation");
    elif not IsList( D )  then
        Error("<D> must be a list");
    fi;

    # special case for the identity
    if g = ()  then return ();  fi;

    # compute the largest point that we must consider
    max := 1;
    for d  in D  do
        e := d ^ g;
        if d <> e  and max < d  then
            max := d;
        fi;
    od;

    # compute the restricted permutation <res>
    res := [ 1 .. max ];
    for d  in D  do
        e := d ^ g;
        if d <= max  then
            res[d] := e;
        fi;
    od;

    # return the restricted permutation <res>
    return PermList( res );
end;


#############################################################################
##
#F  MappingPermListList(<src>,<dst>)  permutation mapping one list to another
##
MappingPermListList := function( src, dst )

    if not IsList(src) or not IsList(dst) or Length(src) <> Length(dst)  then
       Error("usage: MappingPermListList( <lst1>, <lst2> )");
    fi;

    if IsEmpty( src )  then
        return ();
    fi;

    src := Concatenation( src, Difference( [1..Maximum(src)], src ) );
    dst := Concatenation( dst, Difference( [1..Maximum(dst)], dst ) );

    return LeftQuotient( PermList( src ), PermList( dst ) );
end;

#############################################################################
##
#F  IndependentGeneratorsAbelianPPermGroup( <P>, <p> )  . . . nice generators
##
IndependentGeneratorsAbelianPPermGroup := function ( P, p )
    local   inds,       # independent generators, result
            pows,       # their powers
            base,       # the base of the vectorspace
            size,       # the size of the group generated by <inds>
            orbs,       # orbits
            trns,       # transversal
            gens,       # remaining generators
            gens2,      # remaining generators for next round
            exp,        # exponent of <P>
            g,          # one generator from <gens>
            h,          # its power
            b,          # basepoint
            c,          # other point in orbit
            i, j, k;    # loop variables

    # initialize the list of independent generators
    inds := [];
    pows := [];
    base := [];
    size := 1;
    orbs := [];
    trns := [];

    # gens are the generators for the remaining group
    gens := GeneratorsOfGroup( P );

    # loop over the exponents
    exp := Maximum( List( gens, g -> LogInt( Order( g ), p ) ) );
    for i  in [exp,exp-1..1]  do

        # loop over the remaining generators
        gens2 := [];
        for j  in [1..Length(gens)]  do
            g := gens[j];
            h := g ^ (p^(i-1));

            # reduce <g> and <h>
            while h <> h^0
              and IsBound(trns[SmallestMovedPointPerm(h)^h])
            do
                g := g / pows[ trns[SmallestMovedPointPerm(h)^h] ];
                h := h / base[ trns[SmallestMovedPointPerm(h)^h] ];
            od;

            # if this is linear indepenent, add it to the generators
            if h <> h^0  then
                Add( inds, g );
                Add( pows, g );
                Add( base, h );
                size := size * p^i;
                b := SmallestMovedPointPerm(h);
                if not IsBound( orbs[b] )  then
                    orbs[b] := [ b ];
                    trns[b] := [ () ];
                fi;
                for c  in ShallowCopy(orbs[b])  do
                    for k  in [1..p-1]  do
                        Add( orbs[b], c ^ (h^k) );
                        trns[c^(h^k)] := Length(base);
                    od;
                od;

            # otherwise reduce and add to gens2
            else
                Add( gens2, g );

            fi;

        od;

        # prepare for the next round
        gens := gens2;
        pows := OnTuples( pows, p );

    od;

    # return the indepenent generators
    return inds;
end;

#############################################################################
##
#F  IndependentGeneratorsAbelianPermGroup( <G> )  . . . . . . nice generators
##
IndependentGeneratorsAbelianPermGroup := function ( G )
    local   inds,       # independent generators, result
            p,          # prime factor of group size
            gens,       # generators of <p>-Sylowsubgroup
            g,          # one generator
            o;          # its order

    # loop over all primes
    inds := [];
    for p  in Union( List( GeneratorsOfGroup( G ),
            g -> Factors(Order(g)) ) )  do

        # compute the generators for the <p>-Sylowsubgroup
        gens := [];
        for g  in GeneratorsOfGroup( G )  do
            o := Order(g);
            while o mod p = 0  do o := o / p; od;
            if g^o <> g^0  then Add( gens, g^o );  fi;
        od;

        # append the independent generators for the <p>-Sylowsubgroup
        Append( inds,
                IndependentGeneratorsAbelianPPermGroup(Group(gens,()),p) );
        
    od;

    # return the independent generators
    return inds;
end;

#############################################################################
##

#F  OrbitPerms( <gens>, <d> ) . . . . . . . . . . . . . orbit of permutations
##
OrbitPerms := function( gens, d )
    local   max,  orb,  new,  pnt,  img,  gen;
  
        # get the largest point <max> moved by the group <G>
        max := LargestMovedPointPerms( gens );

        # handle fixpoints
        if not d in [1..max]  then
            return [ d ];
        fi;

        # start with the singleton orbit
        orb := [ d ];
        new := BlistList( [1..max], [1..max] );
        new[d] := false;

        # loop over all points found
        for pnt  in orb  do

            # apply all generators <gen>
            for gen  in gens  do
                img := pnt ^ gen;

                # add the image <img> to the orbit if it is new
                if new[img]  then
                    Add( orb, img );
                    new[img] := false;
                fi;

            od;

        od;
        return orb;
end;

#############################################################################
##
#F  OrbitsPerms( <gens>, <D> )  . . . . . . . . . . .  orbits of permutations
##
OrbitsPerms := function( gens, D )
    local   max,  dom,  new,  orbs,  fst,  orb,  pnt,  gen,  img;
    
        # get the largest point <max> moved by the group <G>
        max := LargestMovedPointPerms( gens );
        dom := BlistList( [1..max], D );
        new := BlistList( [1..max], [1..max] );
        orbs := [];

        # repeat until the domain is exhausted
        fst := Position( dom, true );
        while fst <> fail  do

            # start with the singleton orbit
            orb := [ fst ];
            new[fst] := false;
            dom[fst] := false;

            # loop over all points found
            for pnt  in orb  do

                # apply all generators <gen>
                for gen  in gens  do
                    img := pnt ^ gen;

                    # add the image <img> to the orbit if it is new
                    if new[img]  then
                        Add( orb, img );
                        new[img] := false;
                        dom[img] := false;
                    fi;

                od;

            od;

            # add the orbit to the list of orbits and take next point
            Add( orbs, orb );
            fst := Position( dom, true, fst );

        od;

        # add the remaining points of <D>, they are fixed
        for pnt  in [ PositionSorted( D, max+1 ) .. Length(D) ]  do
            Add( orbs, [ D[pnt] ] );
        od;
        
        return orbs;
end;

#############################################################################
##
#F  SmallestMovedPointPerms( <gens> ) . . . . . . . . .  smallest moved point
##
SmallestMovedPointPerms := function( gens )
    local   min,  m,  gen;
    
    min := infinity;
    for gen  in gens  do
        if gen <> One( gen )  then
            m := SmallestMovedPointPerm( gen );
            if m < min  then
                min := m;
            fi;
        fi;
    od;
    return min;
end;

#############################################################################
##
#F  LargestMovedPointPerms( <gens> )  . . . . . . . . . . largest moved point
##
LargestMovedPointPerms := function( gens )
    local   max,  m,  gen;
    
    max := 0;
    for gen  in gens  do
        if gen <> One( gen )  then
            m := LargestMovedPointPerm( gen );
            if m > max  then
                max := m;
            fi;
        fi;
    od;
    return max;
end;

#############################################################################
##
#F  MovedPointsPerms( <gens> )  . . . . . . . .  moved points of permutations
##
MovedPointsPerms := function( gens )
    local   mov,  gen,  pnt;
    
    mov := [  ];
    for gen  in gens  do
        if gen <> One( gen )  then
            for pnt  in [ SmallestMovedPointPerm( gen ) ..
                           LargestMovedPointPerm( gen ) ]  do
                if pnt ^ gen <> pnt  then
                    mov[ pnt ] := pnt;
                fi;
            od;
        fi;
    od;
    return Set( mov );
end;

#############################################################################
##
#F  NrMovedPointsPerms( <gens> )  . . . .  nr of moved points of permutations
##
NrMovedPointsPerms := function( gens )
    local   mov,  sma,  pnt;
    
    mov := 0;
    sma := SmallestMovedPointPerms( gens );
    if sma = infinity  then
        return 0;
    fi;
    for pnt  in [ sma .. LargestMovedPointPerms( gens ) ]  do
        if ForAny( gens, gen -> pnt ^ gen <> pnt )  then
            mov := mov + 1;
        fi;
    od;
    return mov;
end;

#############################################################################
##
#M  LargestMovedPoint( <G> )  . . . . . . . . . . . . . . largest moved point
##
InstallMethod( LargestMovedPoint, true, [ IsPermGroup ], 0,
    G -> LargestMovedPointPerms( GeneratorsOfGroup( G ) ) );

#############################################################################
##
#M  SmallestMovedPoint( <G> ) . . . . . . . . . . . . .  smallest moved point
##
InstallMethod( SmallestMovedPoint, true, [ IsPermGroup ], 0,
    G -> SmallestMovedPointPerms( GeneratorsOfGroup( G ) ) );

#############################################################################
##
#M  MovedPoints( <G> )  . . . . . . . . . . . . . . . . . . . .  moved points
##
InstallMethod( MovedPoints, true, [ IsPermGroup ], 0,
    G -> MovedPointsPerms( GeneratorsOfGroup( G ) ) );

#############################################################################
##
#M  NrMovedPoints( <G> )  . . . . . . . . . . . . . . . .  nr of moved points
##
InstallMethod( NrMovedPoints, true, [ IsPermGroup ], 0,
    G -> NrMovedPointsPerms( GeneratorsOfGroup( G ) ) );

#############################################################################
##

#M  StrongGenerators( <G> ) . . . . . . . . . . . . . . . . strong generators
##
InstallMethod( StrongGenerators, true, [ IsPermGroup ], 0,
    G -> StrongGeneratorsStabChain( StabChainAttr( G ) ) );

#############################################################################
##
#M  Base( <G> ) . . . . . . . . . . . . . . . . . . base of permutation group
##
InstallMethod( Base, true, [ IsPermGroup ], 0,
    G -> BaseStabChain( StabChainAttr( G ) ) );

#############################################################################
##
#M  Size( <G> ) . . . . . . . . . . . . . . . . . . size of permutation group
##
InstallMethod( Size, true, [ IsPermGroup ], 0,
    G -> SizeStabChain( StabChainAttr( G ) ) );

#############################################################################
##
#M  Enumerator( <G> ) . . . . . . . . . . . . enumerator of permutation group
##
InstallMethod( Enumerator, true, [ IsPermGroup ], 0,
    function( G )
    return Objectify( NewKind( FamilyObj( G ), IsPermGroupEnumerator ),
                   rec( stabChain := StabChainAttr( G ) ) );
end );

InstallMethod( Length, true, [ IsPermGroupEnumerator ], 0,
    G -> SizeStabChain( G!.stabChain ) );

InstallMethod( \[\], true, [ IsPermGroupEnumerator, IsPosRat and IsInt ], 0,
    function( G, pos )
    local   elm,  S,  len;
    
    S := G!.stabChain;
    elm := S.identity;
    pos := pos - 1;
    while Length( S.genlabels ) <> 0  do
        len := Length( S.orbit );
        elm := LeftQuotient( InverseRepresentative
                       ( S, S.orbit[ pos mod len + 1 ] ), elm );
        pos := QuoInt( pos, len );
        S := S.stabilizer;
    od;
    return elm;
end );

InstallMethod( Position, true, [ IsPermGroupEnumerator, IsPerm,
        IsZeroCyc ], 0,
    function( G, elm, zero )
    local   pos,  val,  S,  img;
    
    pos := 1;
    val := 1;
    S := G!.stabChain;
    while Length( S.genlabels ) <> 0  do
        img := S.orbit[ 1 ] ^ elm;
        pos := pos + val * ( Position( S.orbit, img ) - 1 );
        val := val * Length( S.orbit );
        elm := elm * InverseRepresentative( S, img );
        S := S.stabilizer;
    od;
    if elm <> S.identity  then
        return fail;
    fi;
    return pos;
end );

InstallMethod( PrintObj, true, [ IsPermGroupEnumerator ], 0,
    function( G )
    Print( "<enumerator of perm group>" );
end );

#############################################################################
##
#M  Random( <G> ) . . . . . . . . . . . . . . . . . . . . . .  random element
##
InstallMethod( Random, true, [ IsPermGroup ], 10,
    function( G )
    local   S,  rnd;

    # go down the stabchain and multiply random representatives
    S := StabChainAttr( G );
    rnd := S.identity;
    while Length( S.genlabels ) <> 0  do
        rnd := LeftQuotient( InverseRepresentative( S,
                       Random( S.orbit ) ), rnd );
        S := S.stabilizer;
    od;

    # return the random element
    return rnd;
end );

#############################################################################
##
#M  <g> in <G>  . . . . . . . . . . . . . . . . . . . . . . . membership test
##
InstallMethod( \in, true, [ IsPerm, IsPermGroup ], 0,
    function( g, G )
    if g = One( G )  or  g in GeneratorsOfGroup( G )  then
        return true;
    else
        G := StabChainAttr( G );
        return SiftedPermutation( G, g ) = G.identity;
    fi;
end );

#############################################################################
##
#M  Order( <g> )  . . . . . . . . . . . . . . . . . .  order of a permutation
##
InstallMethod( Order, true, [ IsPerm ], 0, OrderPerm );

#############################################################################
##

#M  ClosureGroup( <G>, <gens>, <options> )  . . . . . .  closure with options
##
InstallOtherMethod( ClosureGroup, true, [ IsPermGroup,
        IsList and IsPermCollection, IsRecord ], 0,
    function( G, gens, options )
    local   C,          # closure of < <G>, <obj> >, result
            P, inpar,   # parent of the closure
            g,          # an element of gens
            chain;      # the stabilizer chain created

    # if all generators are in <G>, <G> is the closure
    gens := Filtered( gens, gen -> not gen in G );
    if IsEmpty( gens )  then
        return G;
    fi;
        
    # otherwise decide between random and deterministic methods
    P := Parent( G );
    inpar := IsSubset( P, gens );
    while not inpar  and  not IsIdentical( P, Parent( P ) )  do
        P := Parent( P );
        inpar := IsSubset( P, gens );
    od;
    if inpar  then
        CopyOptionsDefaults( P, options );
    elif not IsBound( options.random )  then
        options.random := DefaultStabChainOptions.random;
    fi;
    
    # perhaps <G> is normal in <C> with solvable factor group
    if     DefaultStabChainOptions.tryPcgs
       and ForAll( gens, gen -> ForAll( GeneratorsOfGroup( G ),
                   g -> g ^ gen in G ) )  then
        if inpar  then
            C := SubgroupNC( P,
                         Concatenation( GeneratorsOfGroup( G ), gens ) );
        else
            C := GroupByGenerators
                 ( Concatenation( GeneratorsOfGroup( G ), gens ) );
        fi;
        if IsPcgs( TryPcgsPermGroup( [ C, G ], false, false, false ) )  then
            SetStabChainOptions( C, rec( random := options.random ) );
            return C;
        fi;
    fi;
    
    # make the base of G compatible with options.base
    chain := CopyStabChain( StabChainAttr( G ) );
    if IsBound( options.base )  then
        ChangeStabChain( chain, options.base,
                IsBound( options.reduced ) and options.reduced );
    fi;
    
    if LargestMovedPointPerms( Concatenation( GeneratorsOfGroup( G ),
               gens ) ) <= 100  then
        options := ShallowCopy( options );
        options.base := BaseStabChain( chain );
        StabChainStrong( chain, gens, options );
    else
        chain := ClosureRandomPermGroup( chain, gens, options );
    fi;
    if inpar  then  C := GroupStabChain( P, chain, true );
              else  C := GroupStabChain( chain );           fi;
    SetStabChainOptions( C, rec( random := options.random ) );

    UseSubsetRelation( C, G );
    return C;
end );

InstallOtherMethod( ClosureGroup, true,
        [ IsPermGroup, IsList and IsEmpty, IsRecord ], 0,
    function( G, nogens, options )
    return G;
end );

InstallMethod( ClosureGroup, true,
        [ IsPermGroup and HasStabChain, IsObject ], 20,
    function( G, gens )
    return ClosureGroup( G, gens, rec() );
end );
InstallOtherMethod( ClosureGroup, true, [ IsPermGroup, IsPerm, IsRecord ], 0,
    function( G, g, options )
    return ClosureGroup( G, [ g ], options );
end );
InstallOtherMethod( ClosureGroup, true, [ IsPermGroup, IsPermGroup,
        IsRecord ], 0,
    function( G, H, options )
    return ClosureGroup( G, GeneratorsOfGroup( H ), options );
end );

#############################################################################
##
#M  NormalClosure( <G>, <U> ) . . . . . . . . . . . . . . . . . in perm group
##
InstallMethod( NormalClosure, true, [ IsPermGroup, IsPermGroup ], 0,
    function ( G, U )
    local   N,          # normal closure of <U> in <G>, result
            chain,      # stabilizer chain for the result
            options,    # options record for stabilizer chain construction
            gensG,      # generators of the group <G>
            genG,       # one generator of the group <G>
            gensN,      # generators of the group <N>
            genN,       # one generator of the group <N>
            cnj,        # conjugated of a generator of <U>
            random,  k, # values measuring randomness of <chain>
            param,  missing,  correct,  result,  i;

    # get a set of monoid generators of <G>
    gensG := GeneratorsOfGroup( G );

    # make a copy of the group to be closed
    N := AsSubgroup( G, U );
    SetStabChain( N, StabChainAttr( U ) );
    options := ShallowCopy( StabChainOptions( U ) );
    if IsBound( options.random )  then  random := options.random;
                                  else  random := 1000;            fi;
    options.random := 0;
    options.temp   := true;

    # make list of conjugates to be added to N
    repeat 
        gensN := [  ];
        for i  in [ 1 .. 10 ]  do 
            genG := SCRRandomSubproduct( gensG );
            cnj  := SCRRandomSubproduct( Concatenation
                            ( GeneratorsOfGroup( N ), gensN ) ) ^ genG;
            if not cnj in N  then 
                Add( gensN, cnj );
            fi;
        od;
        if not IsEmpty( gensN )  then
           N := ClosureGroup( N, gensN, options );
        fi;
    until IsEmpty( gensN );
    
    # Guarantee that all conjugates are in the normal  closure: Loop over all
    # generators of N
    gensN := ShallowCopy( GeneratorsOfGroup( N ) );
    for genN  in gensN  do

        # loop over the generators of G
        for genG  in gensG  do

            # make sure that the conjugated element is in the closure
            cnj := genN ^ genG;
            if not cnj in N  then
                N := ClosureGroup( N, [ cnj ], options );
                Add( gensN, cnj );
            fi;

        od;

    od;
    
    # Verify the stabilizer chain.
    chain := StabChainAttr( N );
    if not IsBound( chain.orbits )  then
        if IsBound( chain.aux )  then
            chain := SCRRestoredRecord( chain );
        fi;
        result := chain.identity;
    elif random = 1000  then
        missing := chain.missing;
        correct := chain.correct;
        chain   := SCRRestoredRecord( chain );
        result  := VerifySGS( chain, missing, correct );
    else
        k := First([0..14],x->(3/5)^x <= 1-random/1000);
        if IsBound(options.knownBase) then 
            param := [k,4,0,0,0,0];
        else
            param := [QuoInt(k,2),4,QuoInt(k+1,2),4,50,5];
        fi;
        if options.random <= 200 then 
            param[2] := 2;
            param[4] := 2;
        fi;
        result := SCRStrongGenTest( chain, param, chain.orbits,
                          chain.basesize, chain.base,
                          chain.correct, chain.missing );
        if result = chain.identity  and  not chain.correct  then
            result := SCRStrongGenTest2( chain, param );
        fi;
        chain := SCRRestoredRecord( chain );
    fi;
    SetStabChain( N, chain );
    if result <> chain.identity  then
        N := ClosureGroup( N, [ result ] );
    fi;
    
    # return the normal closure
    UseSubsetRelation( N, U );
    return N;
end );

#############################################################################
##
#M  ConjugateGroup( <G>, <g> )  . . . . . . . . . . . .  of permutation group
##
InstallMethod( ConjugateGroup, "<P>, <g>", true,
        [ IsPermGroup, IsPerm ], 0,
    function( G, g )
    local   H,  S;
    
    H := GroupByGenerators( OnTuples( GeneratorsOfGroup( G ), g ), One( G ) );
    S := EmptyStabChain( [  ], One( H ) );
    ConjugateStabChain( StabChainAttr( G ), S, g, g );
    SetStabChain( H, S );
    UseIsomorphismRelation( G, H );
    return H;
end );

#############################################################################
##
#M  CommutatorSubgroup( <U>, <V> )  . . . . . . . . . . . . . for perm groups
##
InstallMethod( CommutatorSubgroup, IsIdentical,
        [ IsPermGroup, IsPermGroup ], 0,
    function( U, V )
    local   C,       # the commutator subgroup
            CUV,     # closure of U,V
            doneCUV, # boolean; true if CUV is computed
            u,       # random subproduct of U.generators
            v,       # random subproduct of V.generators 
            comm,    # commutator of u,v
            list,    # list of commutators
            i;       # loop variable

    # [ <U>, <V> ] = normal closure of < [ <u>, <v> ] >.
    C := TrivialSubgroup( U );
    doneCUV := false;
    
    # if there are lot of generators, use random subproducts
    if Length( GeneratorsOfGroup( U ) ) *
       Length( GeneratorsOfGroup( V ) ) > 10  then
        repeat
           list := [];
           for i in [1..10] do
               u := SCRRandomSubproduct( GeneratorsOfGroup( U ) );
               v := SCRRandomSubproduct( GeneratorsOfGroup( V ) );
               comm := Comm( u, v );
               if not comm in C then
                   Add( list, comm ) ;
               fi;
           od;
           if Length(list) > 0 then
               C := ClosureGroup( C, list, rec( random := 0,
                                                  temp := true ) );
               if not doneCUV then
                   CUV := ClosureGroup( U, V );
                   doneCUV := true;
               fi;
               C := NormalClosure( CUV, C );
           fi;
        until IsEmpty( list );
    fi;

    # do the deterministic method; it will also check correctness 
    list := [];
    for u  in GeneratorsOfGroup( U )  do
        for v  in GeneratorsOfGroup( V )  do
           comm := Comm( u, v );
           if not comm in C then 
               Add( list, comm );
           fi;
        od;
    od;
    if not IsEmpty( list )  then
        C := ClosureGroup( C, list, rec( random := 0,
                                           temp := true ) );
        if not doneCUV then
           CUV := ClosureGroup( U, V );
           doneCUV := true;
        fi;
        C := NormalClosure( CUV, C );
    fi;

    return C;
end );

#############################################################################
##
#M  DerivedSubgroup( <G> )  . . . . . . . . . . . . . .  of permutation group
##
InstallMethod( DerivedSubgroup, true, [ IsPermGroup ], 0,
    function( G )
    local   D,          # derived subgroup of <G>, result
            g, h,       # random subproducts of generators 
            comm,       # their commutator
            list,       # list of commutators
            count,i,j;  # loop variables

    # find the subgroup generated by the commutators of the generators
    D := TrivialSubgroup( G );

    # if there are >4 generators, use random subproducts
    if Length( GeneratorsOfGroup( G ) ) > 4 then 
        repeat 
            list := [];
            for i in [1..10] do
                g := SCRRandomSubproduct( GeneratorsOfGroup( G ) );
                h := SCRRandomSubproduct( GeneratorsOfGroup( G ) );
                comm := Comm( g, h );
                if not comm in D then  
                   Add( list, comm );
                fi;
            od;
            if Length(list) > 0 then 
               D := ClosureGroup(D,list,rec( random := 0,
                                               temp := true ) );
               D := NormalClosure( G, D );
            fi;
        until list = [];
    fi;

    # do the deterministic method; it will also check random result
    list := [];
    for i in [ 2 .. Length( GeneratorsOfGroup( G ) ) ]  do
         for j  in [ 1 .. i - 1 ]  do
             comm := Comm( GeneratorsOfGroup( G )[i],
                           GeneratorsOfGroup( G )[j] );
             if not comm in D then 
                 Add( list, comm );
             fi;
         od;
    od;
    if not IsEmpty( list )  then
        D := ClosureGroup(D,list,rec( random := 0,
                                        temp := true ) );
        D := NormalClosure( G, D );
    fi;

    return D;
end );

#############################################################################
##
#M  IsSimpleGroup( <G> )  . . . . . . . test if a permutation group is simple
##
##  This  is  a most interesting function.   It  tests whether  a permutation
##  group is  simple  by testing whether the group is  perfect and then  only
##  looking at the size of the group and the degree of a primitive operation.
##  Basically  it uses  the O'Nan--Scott theorem, which gives  a pretty clear
##  description of perfect primitive groups.  This algorithm is described  in
##  William M. Kantor,
##  Finding Composition Factors of Permutation Groups of Degree $n\leq 10^6$,
##  J. Symbolic Computation, 12:517--526, 1991.
##
InstallMethod( IsSimpleGroup, true, [ IsPermGroup ], 0,
    function ( G )
    local   D,          # operation domain of <G>
            hom,        # transitive constituent or blocks homomorphism
            d,          # degree of <G>
            n, m,       # $d = n^m$
            simple,     # list of orders of simple groups
            transperf,  # list of orders of transitive perfect groups
            s, t;       # loop variables

    # if <G> is the trivial group, it is simple
    if IsTrivial( G )  then
        return true;
    fi;

    # first find a transitive representation for <G>
    D := Orbit( G, SmallestMovedPoint( G ) );
    if not IsEqualSet( MovedPoints( G ), D )  then
        hom := OperationHomomorphism( G, D );
        if Size( G ) <> Size( Image( hom ) )  then
            return false;
        fi;
        G := Image( hom );
    fi;

    # next find a primitive representation for <G>
    D := Blocks( G, MovedPoints( G ) );
    while Length( D ) <> 1  do
        hom := OperationHomomorphism( G, D, OnSets );
        if Size( G ) <> Size( Image( hom ) )  then
            return false;
        fi;
        G := Image( hom );
        D := Blocks( G, MovedPoints( G ) );
    od;

    # compute the degree $d$ and express it as $d = n^m$
    D := MovedPoints( G );
    d := Length( D );
    n := SmallestRootInt( d );
    m := LogInt( d, n );
    if 10^6 < d  then
        Error("cannot decide whether <G> is simple or not");
    fi;

    # if $G = C_p$, it is simple
    if    IsPrimeInt( Size( G ) )  then
        return true;

    # if $G = A_d$, it is simple (unless $d < 5$)
    elif  Size( G ) = Factorial( d ) / 2  then
        return 5 <= d;

    # if $G = S_d$, it is not simple (except $S_2$)
    elif  Size( G ) = Factorial( d )  then
        return 2 = d;

    # if $G$ is not perfect, it is not simple (unless $G = C_p$, see above)
    elif  Size( DerivedSubgroup( G ) ) < Size( G )  then
        return false;

    # if $\|G\| = d^2$, it is not simple (Kantor's Lemma 4)
    elif  Size( G ) = d ^ 2  then
        return false;

    # if $d$ is a prime, <G> is simple
    elif  IsPrimeInt( d )  then
        return true;

    # if $G = U(4,2)$, it is simple (operation on 27 points)
    elif  d = 27 and Size( G ) = 25920  then
        return true;

    # if $G = PSL(n,q)$, it is simple (operations on prime power points)
    elif  (  (d =      8 and Size(G) = (7^3-7)/2          )  # PSL(2,7)
          or (d =      9 and Size(G) = (8^3-8)            )  # PSL(2,8)
          or (d =     32 and Size(G) = (31^3-31)/2        )  # PSL(2,31)
          or (d =    121 and Size(G) =        237783237120)  # PSL(5,3)
          or (d =    128 and Size(G) = (127^3-127)/2      )  # PSL(2,127)
          or (d =   8192 and Size(G) = (8191^3-8191)/2    )  # PSL(2,8191)
          or (d = 131072 and Size(G) = (131071^3-131071)/2)  # PSL(2,131071)
          or (d = 524288 and Size(G) = (524287^3-524287)/2)) # PSL(2,524287)
      and IsTransitive( Stabilizer( G, D[1] ), Difference( D, [ D[1] ] ) )
    then
        return true;

    # if $d$ is a prime power, <G> is not simple (except the cases above)
    elif  IsPrimePowerInt( d )  then
        return false;

    # if we don't have at least an $A_5$ acting on the top, <G> is simple
    elif  m < 5  then
        return true;

    # otherwise we must check for some special cases
    else

        # orders of simple subgroups of $S_n$ with primitive normalizer
        simple := [ ,,,,,
          [60,360],,,,                  #  5: A(5), A(6)
          [60,360,1814400],,            # 10: A(5), A(6), A(10)
          [660,7920,95040,239500800],,  # 12: PSL(2,11), M(11), M(12), A(12)
          [1092,43589145600],           # 14: PSL(2,13), A(14)
          [360,2520,20160,653837184000] # 15: A(6), A(7), A(8), A(15)
        ];

        # orders of transitive perfect subgroups of $S_m$
        transperf := [ ,,,,
          [60],                         # 5: A(5)
          [60,360],                     # 6: A(5), A(6)
          [168,2520],                   # 7: PSL(3,2), A(7)
          [168,8168,20160]              # 8: PSL(3,2), AGL(3,2), A(8)
        ];

        # test the special cases (Kantor's Lemma 3)
        for s  in simple[n]  do
            for t  in transperf[m]  do
                if    Size( G ) mod (t * s^m) = 0
                  and (((t * (2*s)^m) mod Size( G ) = 0 and s <> 360)
                    or ((t * (4*s)^m) mod Size( G ) = 0 and s =  360))
                then
                    return false;
                fi;
            od;
        od;

        # otherwise <G> is simple
        return true;

    fi;

end );

#############################################################################
##

#M  IsNormal( <G>, <N> )  . . . . . . . . . . . . . . . . . . for perm groups
##
InstallMethod( IsNormal, true, [ IsPermGroup, IsPermGroup ], 0,
    function( G, N )
    return ForAll( GeneratorsOfGroup( N ), genN ->
                   ForAll( GeneratorsOfGroup( G ), genG ->
                           genN ^ genG in N ) );
end );

#############################################################################
##
#M  IsSolvableGroup( <G> )  . . . . . . . . . . . . . . . .  solvability test
##
InstallMethod( IsSolvableGroup, true, [ IsPermGroup ], 0,
    G -> IsPcgs( Pcgs( G ) ) );

#############################################################################
##
#M  IsNilpotentGroup( <G> ) . . . . . . . . . . . . . . . . . nilpotency test
##
InstallMethod( IsNilpotentGroup, true, [ IsPermGroup ], 0,
    G -> IsPcgs( TryPcgsPermGroup( G, true, false, false ) ) );

#############################################################################
##
#M  DerivedSeriesOfGroup( <G> ) . . . . . . . . . . . . . . .  derived series
##
InstallMethod( DerivedSeriesOfGroup, true, [ IsPermGroup ], 0,
    function( G )
    local  pcgs,  series;

    if    not DefaultStabChainOptions.tryPcgs
       or ( HasIsSolvableGroup( G )  and  not IsSolvableGroup( G ) )  then
        TryNextMethod();
    fi;
    
    pcgs := TryPcgsPermGroup( G, false, true, false );
    if not IsPcgs( pcgs )  then
        TryNextMethod();
    fi;
    series := DerivedSeriesOfGroup( pcgs );
    if not HasDerivedSubgroup( G )  then
        if Length( series ) > 1  then  SetDerivedSubgroup( G, series[ 2 ] );
                                 else  SetDerivedSubgroup( G, G );  fi;
    fi;
    return series;
end );

#############################################################################
##
#M  LowerCentralSeriesOfGroup( <G> )  . . . . . . . . .  lower central series
##
InstallMethod( LowerCentralSeriesOfGroup, true, [ IsPermGroup ], 0,
    function( G )
    local  pcgs,  series;

    if    not DefaultStabChainOptions.tryPcgs
       or HasIsNilpotentGroup( G )  and  not IsNilpotentGroup( G )  then
        TryNextMethod();
    fi;
    
    pcgs := TryPcgsPermGroup( G, true, true, false );
    if not IsPcgs( pcgs )  then
        TryNextMethod();
    fi;
    series := LowerCentralSeriesOfGroup( pcgs );
    if not HasDerivedSubgroup( G )  then
        if Length( series ) > 1  then  SetDerivedSubgroup( G, series[ 2 ] );
                                 else  SetDerivedSubgroup( G, G );  fi;
    fi;
    return series;
end );

#############################################################################
##
#M  ElementaryAbelianSeries( <G> )  . . . . . . . . elementary abelian series
##
InstallMethod( ElementaryAbelianSeries, true, [ IsPermGroup ], 0,
    function( G )
    local  pcgs;

    if    not DefaultStabChainOptions.tryPcgs
       or ( HasIsSolvableGroup( G )  and  not IsSolvableGroup( G ) )  then
        TryNextMethod();
    fi;
    
    pcgs := TryPcgsPermGroup( G, false, false, true );
    if not IsPcgs( pcgs )  then  return fail;
                           else  return ElementaryAbelianSeries( pcgs );  fi;
end );

InstallOtherMethod( ElementaryAbelianSeries, fam -> IsIdentical
        ( fam, CollectionsFamily( CollectionsFamily( PermutationsFamily ) ) ),
        [ IsList ], 0,
    function( list )
    local  pcgs;
    
    if    IsEmpty( list )
       or not DefaultStabChainOptions.tryPcgs
       or (      HasIsSolvableGroup( list[ 1 ] )
            and not IsSolvableGroup( list[ 1 ] ) )  then
        TryNextMethod();
    fi;
    
    pcgs := TryPcgsPermGroup( list, false, false, true );
    if not IsPcgs( pcgs )  then  return fail;
                           else  return ElementaryAbelianSeries( pcgs );  fi;
end );

#############################################################################
##
#M  PCentralSeries( <G>, <p> )  . . . . . . . . . . . . . .  p-central series
##
InstallMethod( PCentralSeriesOp, true, [ IsPermGroup, IsPosRat and IsInt ], 0,
    function( G, p )
    local  pcgs;

    if    not DefaultStabChainOptions.tryPcgs
       or ( HasIsNilpotentGroup( G )  and  not IsNilpotentGroup( G ) )
       or ( HasSize( G )  and  Size( G ) <> p ^ LogInt( Size( G ), p ) )  then
        TryNextMethod();
    fi;
    
    pcgs := TryPcgsPermGroup( G, true, true, p );
    if not IsPcgs( pcgs )  then  TryNextMethod();
                           else  return ElementaryAbelianSeries( pcgs );  fi;
end );

#############################################################################
##
#M  SylowSubgroup( <G>, <p> ) . . . . . . . . . . . . . .  Sylow $p$-subgroup
##
InstallMethod( SylowSubgroupOp, true, [ IsPermGroup, IsPosRat and IsInt ], 0,
    function( G, p )
    local   S;
    
    S := SylowSubgroupPermGroup( G, p );
    S := GroupStabChain( G, StabChainAttr( S ) );
    SetIsNilpotentGroup( S, true );
    return S;
end );

SylowSubgroupPermGroup := function( G, p )
    local   S,          # <p>-Sylow subgroup of <G>, result
            q,          # largest power of <p> dividing the size of <G>
            D,          # domain of operation of <G>
            O,          # one orbit of <G> in this domain
            B,          # blocks of the operation of <G> on <D>
            f,          # operation homomorphism of <G> on <O> or <B>
            T,          # <p>-Sylow subgroup in the image of <f>
            g, g2,      # one <p> element of <G>
            C, C2;      # centralizer of <g> in <G>
    
    # get the size of the <p>-Sylow subgroup
    q := 1;  while Size( G ) mod (q * p) = 0  do q := q * p;  od;

    # handle trivial subgroup
    if   q = 1  then
        return TrivialSubgroup( G );
    fi;

    # go down in stabilizers as long as possible
    S := StabChainAttr( G );
    while Length( S.orbit ) mod p <> 0  do
        S := S.stabilizer;
    od;
    G := GroupStabChain( G, S, true );

    # handle full group
    if q = Size( G )  then
        return G;
    fi;

    # handle <p>-Sylow subgroups of size <p>
    if q = p  then
        repeat g := Random( G );  until Order( g ) mod p = 0;
        g := g ^ (Order( g ) / p);
        return SubgroupNC( G, [ g ] );
    fi;

    # if the group is not transitive work with the transitive constituents
    D := MovedPoints( G );
    if not IsTransitive( G, D )  then
        S := G;
        D := ShallowCopy( D );
        while q < Size( S )  do
            O := Orbit( S, D[1] );
            f := OperationHomomorphism( S, O );
            T := SylowSubgroupPermGroup( ImagesSource( f ), p );
            S := PreImagesSet( f, T );
            SubtractSet( D, O );
        od;
        return S;
    fi;

    # if the group is not primitive work in the image first
    B := Blocks( G, D );
    if Length( B ) <> 1  then
        f := OperationHomomorphism( G, B, OnSets );
        T := SylowSubgroupPermGroup( ImagesSource( f ), p );
        if Size( T ) < Size( ImagesSource( f ) )  then
            S := SylowSubgroupPermGroup( PreImagesSet( f, T ), p );
            return S;
        fi;
    fi;

    # find a <p> element whose centralizer contains a full <p>-Sylow subgroup
    repeat g := Random( G );  until Order( g ) mod p = 0;
    g := g ^ (Order( g ) / p);
    C := Centralizer( G, g );
    while GcdInt( q, Size( C ) ) < q  do
        repeat g2 := Random( C );  until Order( g2 ) mod p = 0;
        g2 := g2 ^ (Order( g2 ) / p);
        C2 := Centralizer( G, g2 );
        if GcdInt( q, Size( C ) ) < GcdInt( q, Size( C2 ) )  then
            C := C2;  g := g2;
        fi;
    od;

    # the centralizer operates on the cycles of the <p> element
    B := List( Cycles( g, D ), Set );
    f := OperationHomomorphism( C, B, OnSets );
    T := SylowSubgroupPermGroup( ImagesSource( f ), p );
    S := PreImagesSet( f, T );
    return S;

end;

#############################################################################
##
#F  OmegaPN( <G>, <p>, <n> )  . . . . . . . . roots of unity in abelian group
##
OmegaPN := function( G, p, n )
    local   gens,  i,  ord;
    
    if not IsAbelian( G )  then
        TryNextMethod();
    fi;
    gens := IndependentGeneratorsAbelianPermGroup( G );
    for i  in [ 1 .. Length( gens ) ]  do
        ord := Order( gens[ i ] );
        if ord mod p = 0  then
            gens[ i ] := gens[ i ] ^ ( ord / p ^ n );
        fi;
    od;
    return SubgroupNC( G, gens );
end;

#############################################################################
##
#M  Socle( <G> )  . . . . . . . . . . .  socle of primitive permutation group
##
InstallMethod( Socle, true, [ IsPermGroup ], 0,
    function( G )
    local   Omega,  deg,  shortcut,  coll,  d,  m,  c,  ds,  L,  z,  ord,
            p,  i;
    
    Omega := MovedPoints( G );
    
    # Affine groups first.
    L := Earns( G, Omega );
    if L <> fail  then
        return L;
    fi;
    
    deg := Length( Omega );
    if deg >= 6103515625  then
        Print( "sorry, cannot find socle if degree >= 6 103 515 625" );
        TryNextMethod();
    elif not IsPrimitive( G, Omega )  then
        Print( "sorry, cannot find socle if <G> is imprimitive" );
        TryNextMethod();
    elif deg < 12960000  then
        shortcut := true;
        if deg >= 3125  then
            coll := Collected( FactorsInt( deg ) );
            d := Gcd( List( coll, c -> c[ 2 ] ) );
            if d mod 5 = 0  then
                m := 1;
                for c  in coll  do
                    m := m * c[ 1 ] ^ ( c[ 2 ] / d );
                od;
                if m >= 5  then
                    shortcut := false;
                fi;
            fi;
        fi;
        if shortcut  then
            ds := DerivedSeriesOfGroup( G );
            return ds[ Length( ds ) ];
        fi;
    fi;
    
    coll := Collected( FactorsInt( Size( G ) ) );
    if deg < 78125  then
        p := coll[ Length( coll ) ][ 1 ];
    else
        i := Length( coll );
        while coll[ i ][ 2 ] = 1  do
            i := i - 1;
        od;
        p := coll[ i ][ 1 ];
    fi;
    repeat
        repeat
            z := Random( G );
            ord := Order( z );
        until ord mod p = 0;
        z := z ^ ( ord / p );
    until Index( G, Centralizer( G, z ) ) mod p <> 0;
    L := NormalClosure( G, SubgroupNC( G, [ z ] ) );
    if deg >= 78125  then
        ds := DerivedSeriesOfGroup( L );
        L := ds[ Length( ds ) ];
    fi;
    if IsSemiRegular( L, Omega )  then
        L := ClosureGroup( L, Centralizer( G, L ) );
    fi;
    return L;
end );
    
#############################################################################
##
#M  FrattiniSubgroup( <G> ) . . . . . . . . . . . .  for permutation p-groups
##
InstallMethod( FrattiniSubgroup, true, [ IsPermGroup ], 0,
    function( G )
    local   fac,  p,  l,  k,  i,  j;

    fac := ListSortedList( FactorsInt( Size( G ) ) );
    if Length( fac ) > 1  then
        TryNextMethod();
    fi;
    p := fac[ 1 ];
    l := GeneratorsOfGroup( G );
    k := [ l[1]^p ];
    for i  in [ 2 .. Length(l) ]  do
        for j  in [ 1 .. i-1 ]  do
            Add(k, Comm(l[i], l[j]));
        od;
        Add(k, l[i]^p);
    od;
    return SolvableNormalClosurePermGroup( G, k );
end );
        
#############################################################################
##

#F  MinimizeExplicitTransversal( <U>, <maxmoved> )  . . . . . . . . . . local
##
MinimizeExplicitTransversal := function( U, maxmoved )
    local   explicit,  lenflock,  flock,  lenblock,  index,  s;
    
    if     IsBound( U.explicit )
       and IsBound( U.stabilizer )  then
        explicit := U.explicit;
        lenflock := U.stabilizer.index * U.lenblock / Length( U.orbit );
        flock    := U.flock;
        lenblock := U.lenblock;
        index    := U.index;
        ChangeStabChain( U, [ 1 .. maxmoved ] );
        for s  in [ 1 .. Length( explicit ) ]  do
            explicit[ s ] := MinimalElementCosetStabChain( U, explicit[ s ] );
        od;
        Sort( explicit );
        U.explicit := explicit;
        U.lenflock := lenflock;
        U.flock    := flock;
        U.lenblock := lenblock;
        U.index    := index;
    fi;
end;

#############################################################################
##
#F  RightTransversalPermGroupConstructor( <filter>, <G>, <U> )  . constructor
##
RightTransversalPermGroupConstructor := function( filter, G, U )
    local   enum,  orbs,  domain,  bpt;
    
    enum := Objectify( NewKind( FamilyObj( G ), filter ),
          rec( group := G,
            subgroup := U,
      stabChainGroup := CopyStabChain( StabChainAttr( G ) ),
   stabChainSubgroup := CopyStabChain( StabChainAttr( U ) ) ) );
    if not IsTrivial( G )  then
        orbs := ShallowCopy( Orbits( U, MovedPoints( G ) ) );
        Sort( orbs, function( o1, o2 )
            return Length( o1 ) < Length( o2 ); end );
        domain := Concatenation( orbs );
        G := enum!.stabChainGroup;
        U := enum!.stabChainSubgroup;
        while    Length( G.genlabels ) <> 0
              or Length( U.genlabels ) <> 0  do
            bpt := First( domain, p -> not IsFixedStabilizer( G, p ) );
            ChangeStabChain( G, [ bpt ], true  );  G := G.stabilizer;
            ChangeStabChain( U, [ bpt ], false );  U := U.stabilizer;
        od;
    fi;
    AddCosetInfoStabChain( enum!.stabChainGroup, enum!.stabChainSubgroup,
            LargestMovedPoint( enum!.group ) );
    MinimizeExplicitTransversal( enum!.stabChainSubgroup,
            LargestMovedPoint( enum!.group ) );
    return enum;
end;

#############################################################################
##
#F  RightTransversalByBaseImages( <G>, <U> )  . . . . . . . .  by base images
##
IsRightTransversalByBaseImages := NewRepresentation
    ( "IsRightTransversalByBaseImages", IsRightTransversalPermGroup, [  ] );

RightTransversalByBaseImages := function( G, U )
    return RightTransversalPermGroupConstructor
           ( IsRightTransversalByBaseImages, G, U );
end;

InstallMethod( \[\], true, [ IsRightTransversalByBaseImages,
        IsPosRat and IsInt ], 0,
    function( cs, num )
    return CosetNumber( cs!.stabChainGroup, cs!.stabChainSubgroup, num,
                   BaseStabChain( cs!.stabChainGroup ) );
end );

InstallMethod( PositionCanonical, true,
        [ IsRightTransversalByBaseImages, IsObject ], 0,
    function( cs, elm )
    local   S,  rep,  i;
    
    S := cs!.stabChainGroup;
    rep := S.identity;
    for i  in [ 1 .. Length( elm ) ]  do
        rep := LeftQuotient( InverseRepresentative( S, elm[ i ] / rep ), rep );
        S := S.stabilizer;
    od;
    return NumberCoset( cs!.stabChainGroup, cs!.stabChainSubgroup, rep );
end );

#############################################################################
##
#M  RightTransversal( <G>, <U> )  . . . . . . . . . . . . . . for perm groups
##
InstallMethod( RightTransversal, IsIdentical,
        [ IsPermGroup, IsPermGroup ], 0,
    function( G, U )
    return RightTransversalPermGroupConstructor( IsRightTransversalPermGroup,
                   G, U );
end );

InstallMethod( \[\], true, [ IsRightTransversalPermGroup,
        IsPosRat and IsInt ], 0,
    function( cs, num )
    return CosetNumber( cs!.stabChainGroup, cs!.stabChainSubgroup, num );
end );

InstallMethod( PositionCanonical, true,
        [ IsRightTransversalPermGroup, IsPerm ], 0,
    function( cs, elm )
    return NumberCoset( cs!.stabChainGroup,
                        cs!.stabChainSubgroup,
                        elm );
end );

#############################################################################
##
#F  AddCosetInfoStabChain( <G>, <U>, <maxmoved> ) . . . . . .  add coset info
##
MAX_SIZE_TRANSVERSAL := 100000;

AddCosetInfoStabChain := function( G, U, maxmoved )
    local   orb,  pimg,  img,  vert,  s,  t,  index,
            block,  B,  blist,  pos,  sliced,  lenflock,  i,  j,
            ss,  tt,  explicit,  flock;
    
    if IsEmpty( G.genlabels )  then
        U.index    := 1;
        U.explicit := [ U.identity ];
        U.lenflock := 1;
        U.flock    := U.explicit;
    else
        AddCosetInfoStabChain( G.stabilizer, U.stabilizer, maxmoved );
        
        # U.index := [G_1:U_1];
        U.index := U.stabilizer.index * Length( G.orbit ) / Length( U.orbit );
        
        # block := 1 ^ <U,G_1>; is a block for G.
        block := OrbitPerms( Concatenation( U.generators,
                 G.stabilizer.generators ), G.orbit[ 1 ] );
        U.lenblock := Length( block );
        lenflock := Length( G.orbit ) / U.lenblock;

        # For small indices,  permutations   are multiplied,  so  we  need  a
        # multiplied transversal.
        if     IsBound( U.stabilizer.explicit )
           and U.lenblock * maxmoved <= MAX_SIZE_TRANSVERSAL
           and U.index    * maxmoved <= MAX_SIZE_TRANSVERSAL * lenflock  then
            U.explicit := [  ];
            U.flock    := [ G.identity ];
            tt := [  ];  tt[ G.orbit[ 1 ] ] := G.identity;
            for t  in G.orbit  do
                tt[ t ] := tt[ t ^ G.transversal[ t ] ] /
                           G.transversal[ t ];
            od;
        fi;
        
        # flock := { G.transversal[ B[1] ] | B in block system };
        blist := BlistList( G.orbit, block );
        pos := Position( blist, false );
        while pos <> fail  do
            img := G.orbit[ pos ];
            B := block{ [ 1 .. U.lenblock ] };
            sliced := [  ];
            while img <> G.orbit[ 1 ]  do
                Add( sliced, G.transversal[ img ] );
                img := img ^ G.transversal[ img ];
            od;
            for i  in Reversed( [ 1 .. Length( sliced ) ] )  do
                for j  in [ 1 .. Length( B ) ]  do
                    B[ j ] := B[ j ] / sliced[ i ];
                od;
            od;
            Append( block, B );
            if IsBound( U.explicit )  then
                Add( U.flock, tt[ B[ 1 ] ] );
            fi;
            UniteBlist( blist, BlistList( G.orbit, B ) );
            pos := Position( blist, false, pos );
        od;
        G.orbit := block;
        
        # Let <s> loop over the transversal elements in the stabilizer.
        U.repsStab := List( [ 1 .. U.lenblock ], x ->
                           BlistList( [ 1 .. U.stabilizer.index ], [  ] ) );
        U.repsStab[ 1 ] := BlistList( [ 1 .. U.stabilizer.index ],
                                      [ 1 .. U.stabilizer.index ] );
        index := U.stabilizer.index * lenflock;
        s := 1;
        
        # For  large  indices, store only   the  numbers of  the  transversal
        # elements needed.
        if not IsBound( U.explicit )  then

            # If  the   stabilizer   is the   topmost  level   with  explicit
            # transversal, this must contain minimal coset representatives.
            MinimizeExplicitTransversal( U.stabilizer, maxmoved );
            
            orb := G.orbit{ [ 1 .. U.lenblock ] };
            pimg := [  ];
            while index < U.index  do
                pimg{ orb } := CosetNumber( G.stabilizer, U.stabilizer, s,
                                       orb );
                t := 2;
                while t <= U.lenblock  and  index < U.index  do
                    
                    # For this point  in the  block,  find the images  of the
                    # earlier points under the representative.
                    vert := G.orbit{ [ 1 .. t - 1 ] };
                    img := G.orbit[ t ];
                    while img <> G.orbit[ 1 ]  do
                        vert := OnTuples( vert, G.transversal[ img ] );
                        img  := img           ^ G.transversal[ img ];
                    od;
            
                    # If $Ust = Us't'$ then $1t'/t/s in 1U$. Also if $1t'/t/s
                    # in 1U$ then $st/t' =  u.g_1$ with $u  in U, g_1 in G_1$
                    # and $g_1  =  u_1.s'$ with $u_1  in U_1,  s' in S_1$, so
                    # $Ust = Us't'$.
                    if ForAll( [ 1 .. t - 1 ], i -> not IsBound
                       ( U.translabels[ pimg[ vert[ i ] ] ] ) )  then
                        U.repsStab[ t ][ s ] := true;
                        index := index + lenflock;
                    fi;
                    
                    t := t + 1;
                od;
                s := s + 1;
            od;
            
        # For small indices, store a transversal explicitly.
        else
            for ss  in U.stabilizer.flock  do
                Append( U.explicit, U.stabilizer.explicit * ss );
            od;
            while index < U.index  do
                t := 2;
                while t <= U.lenblock  and  index < U.index  do
                    ss := U.explicit[ s ] * tt[ G.orbit[ t ] ];
                    if ForAll( [ 1 .. t - 1 ], i -> not IsBound
                           ( U.translabels[ G.orbit[ i ] / ss ] ) )  then
                        U.repsStab[ t ][ s ] := true;
                        Add( U.explicit, ss );
                        index := index + lenflock;
                    fi;
                    t := t + 1;
                od;
                s := s + 1;
            od;
            Unbind( U.stabilizer.explicit );
            Unbind( U.stabilizer.flock    );
        fi;
                    
    fi;
end;

#############################################################################
##
#F  NumberCoset( <G>, <U>, <r> )  . . . . . . . . . . . . . . coset to number
##
NumberCoset := function( G, U, r )
    local   num,  b,  t,  u,  g1,  pnt,  bpt;
    
    if IsEmpty( G.genlabels )  or  U.index = 1  then
        return 1;
    fi;
    
    # Find the block number of $r$.
    bpt := G.orbit[ 1 ];
    b := QuoInt( Position( G.orbit, bpt ^ r ) - 1, U.lenblock );
        
    # For small indices, look at the explicit transversal.
    if IsBound( U.explicit )  then
        return b * U.lenflock + Position( U.explicit,
               MinimalElementCosetStabChain( U, r / U.flock[ b + 1 ] ) );
    fi;
        
    pnt := G.orbit[ b * U.lenblock + 1 ];
    while pnt <> bpt  do
        r   := r   * G.transversal[ pnt ];
        pnt := pnt ^ G.transversal[ pnt ];
    od;
    
    # Now $r$ stabilises the block. Find the first $t in G/G_1$ such that $Ur
    # = Ust$ for $s in G_1$. In this code, G.orbit[ <t> ] = bpt ^ $t$.
    num := b * U.stabilizer.index * U.lenblock / Length( U.orbit );
             # \_________This is [<U,G_1>:U] = U.lenflock_________/
    t := 1;
    pnt := G.orbit[ t ] / r;
    while not IsBound( U.translabels[ pnt ] )  do
        num := num + SizeBlist( U.repsStab[ t ] );
        t := t + 1;
        pnt := G.orbit[ t ] / r;
    od;
        
    # $r/t = u.g_1$ with $u in U, g_1 in G_1$, hence $t/r.u = g_1^-1$.
    u := U.identity;
    while pnt ^ u <> bpt  do
        u := u * U.transversal[ pnt ^ u ];
    od;
    g1 := LeftQuotient( u, r );  # Now <g1> = $g_1.t = u mod r$.
    while bpt ^ g1 <> bpt  do
        g1 := g1 * G.transversal[ bpt ^ g1 ];
    od;
                
    # The number of $r$  is the number of $g_1$  plus an offset <num> for
    # the earlier values of $t$.
    return num + SizeBlist( U.repsStab[ t ]{ [ 1 ..
                   NumberCoset( G.stabilizer, U.stabilizer, g1 ) ] } );

end;

#############################################################################
##
#F  CosetNumber( <arg> )  . . . . . . . . . . . . . . . . . . number to coset
##
CosetNumber := function( arg )
    local   G,  U,  num,  tup,  b,  t,  rep,  pnt,  bpt,  index,  len,  i;

    # Get the arguments.
    G := arg[ 1 ];  U := arg[ 2 ];  num := arg[ 3 ];
    if Length( arg ) > 3  then  tup := arg[ 4 ];
                          else  tup := false;     fi;

    if num = 1  then
        if tup = false  then  return G.identity;
                        else  return tup;         fi;
    fi;
    
    # Find the block $b$ addressed by <num>.
    if IsBound( U.explicit )  then
        index := U.lenflock;
    else
        index := U.stabilizer.index * U.lenblock / Length( U.orbit );
               # \_________This is [<U,G_1>:U] = U.lenflock_________/
    fi;
    b := QuoInt( num - 1, index );
    num := ( num - 1 ) mod index + 1;
        
    # For small indices, look at the explicit transversal.
    if IsBound( U.explicit )  then
        if tup = false  then
            return U.explicit[ num ] * U.flock[ b + 1 ];
        else
            return List( tup, t -> t / U.flock[ b + 1 ] / U.explicit[ num ] );
        fi;
    fi;
        
    # Otherwise, find the point $t$ addressed by <num>.
    t := 1;
    len := SizeBlist( U.repsStab[ t ] );
    while num > len  do
        num := num - len;
        t := t + 1;
        len := SizeBlist( U.repsStab[ t ] );
    od;
    if len < U.stabilizer.index  then
        num := PositionNthTrueBlist( U.repsStab[ t ], num );
    fi;
        
    # Find the representative $s$ in   the stabilizer addressed by <num>  and
    # return $st$.
    rep := G.identity;
    bpt := G.orbit[ 1 ];
    if tup = false  then
        pnt := G.orbit[ b * U.lenblock + 1 ];
        while pnt <> bpt  do
            rep := rep * G.transversal[ pnt ];
            pnt := pnt ^ G.transversal[ pnt ];
        od;
        pnt := G.orbit[ t ];
        while pnt <> bpt  do
            rep := rep * G.transversal[ pnt ];
            pnt := pnt ^ G.transversal[ pnt ];
        od;
        return CosetNumber( G.stabilizer, U.stabilizer, num ) / rep;
    else
        pnt := G.orbit[ b * U.lenblock + 1 ];
        while pnt <> bpt  do
            tup := OnTuples( tup, G.transversal[ pnt ] );
            pnt := pnt ^ G.transversal[ pnt ];
        od;
        pnt := G.orbit[ t ];
        while pnt <> bpt  do
            tup := OnTuples( tup, G.transversal[ pnt ] );
            pnt := pnt ^ G.transversal[ pnt ];
        od;
        return CosetNumber( G.stabilizer, U.stabilizer, num, tup );
    fi;
end;

#############################################################################
##

#F  AutomorphismByConjugation( <Omega>, <d>, <e> )  .  do auto by conjugation
##
AutomorphismByConjugation := function( Omega, d, e )
    local   G,  bpt,  aut,  D1,  E1,  fix,  Imega,  sliced,  pnt;
    
    G := SymmetricGroup( Omega[ Length( Omega ) ] );
    aut := GroupGeneralMappingByImages( G, G, d, e );
    if not IsTransitive( PreImagesRange( aut ), Omega )  then
        Error( "<d> and <e> must generate transitive subgroups of <G>" );
    elif not IsTransitive( ImagesSource( aut ), Omega )  then
        return fail;
    fi;
    
    bpt := Omega[ 1 ];
    D1 := Stabilizer( PreImagesRange( aut ), bpt );
    E1 := ImagesSet( aut, D1 );
    if NrMovedPoints( E1 ) = Length( Omega )  then
        return fail;
    fi;
    fix := First( Omega, p -> ForAll( GeneratorsOfGroup( E1 ),
                   gen -> p ^ gen = p ) );
    
    # The automorphism <aut> maps <d>_bpt to <e>_fix, so permutes the points.
    # Find an element in <G> with the same action.
    Imega := [  ];
    for pnt  in Omega  do
        sliced := [  ];
        while pnt <> bpt  do
            Add( sliced, StabChainAttr( aut ).transimages[ pnt ] );
            pnt := pnt ^ StabChainAttr( aut ).transversal[ pnt ];
        od;
        Add( Imega, PreImageWord( fix, sliced ) );
    od;
    
    return MappingPermListList( Omega, Imega );
end;

#############################################################################
##

#M  AllBlocks . . . Representatives of all block systems
##
InstallMethod(AllBlocks,"generic",true,[IsPermGroup],0,
function(g)
local dom,DoBlocks,pool;

  DoBlocks:=function(b)
  local bl,bld,i,t,n;
    bld:=Difference(dom,b);
    bl:=[];
    if not IsPrime(Length(dom)/Length(b)) then
      for i in bld do
	t:=Union(b,[i]);
	n:=Blocks(g,dom,t);
	if Length(n)>1 and #ok durch pool:ForAll(Difference(n[1],t),j->j>i) and
	   not n[1] in pool then
	  t:=n[1];
	  Add(pool,t);
	  bl:=Concatenation(bl,[t],DoBlocks(t));
	fi;
      od;
    fi;
    return bl;
  end;

  dom:=MovedPoints(g);
  pool:=[];
  return DoBlocks(dom{[1]});
end);

#############################################################################
##
#F  SignPermGroup
##
SignPermGroup := function(g)
  if ForAll(GeneratorsOfGroup(g),i->SignPerm(i)=1) then
    return 1;
  else
    return -1;
  fi;
end;

CreateAllCycleStructures := function(n)
local i,j,l,m;
  l:=[];
  for i in Partitions(n) do
    m:=[];
    for j in i do
      if j>1 then
        if IsBound(m[j-1]) then
          m[j-1]:=m[j-1]+1;
        else 
          m[j-1]:=1;
        fi;
      fi;
    od;
    Add(l,m);
  od;
  return l;
end;

#############################################################################
##
#F  CycleStructuresGroup(G)  list of all cyclestructures occ. in a perm group
##
CycleStructuresGroup := function(g)
local c,l,m,i;
  l:=CreateAllCycleStructures(Length(MovedPoints(g)));
  m:=List([1..Length(l)-1],i->0);
  for i in ConjugacyClasses(g) do
    if Representative(i)<>() then
      m[Position(l,CycleStructurePerm(Representative(i)))-1]:=1;
    fi;
  od;
  return m;
end;

#############################################################################
##
#M  SmallGeneratingSet(<G>) 
##
InstallMethod(SmallGeneratingSet,"random and generators subset, randsims",true,
  [IsPermGroup],0,
function (G)
local  i, j, U, gens;

  # try pc methods first
  if IsSolvableGroup(G) then
    i:=IsomorphismPcGroup(G);
    U:=Image(i,G);
    gens:=MinimalGeneratingSet(U);
    return List(gens,j->PreImagesRepresentative(i,j));
  fi;

  gens := Set(GeneratorsOfGroup(G));
  if Length(gens)>2 then
    i:=2;
    while i<=3 and i<Length(gens) do
      # try to find a small generating system by random search
      j:=1;
      while j<=5 and i<Length(gens) do
	U:=Subgroup(G,List([1..i],j->Random(G)));
	StabChain(U,rec(random:=1));
	if Size(U)=Size(G) then
	  gens:=Set(GeneratorsOfGroup(U));
	fi;
        j:=j+1;
      od;
      i:=i+1;
    od;
  fi;
  i := 1;
  if not IsAbelian(G) then
    i:=i+1;
  fi;
  while i < Length(gens)  do
    # random did not improve much, try subsets
    U:=Subgroup(G,gens{Difference([1..Length(gens)],[i])});
    if Size(U)<Size(G) then
      i:=i+1;
    else
      gens:=Set(GeneratorsOfGroup(U));
    fi;
  od;
  return gens;
end);

#############################################################################
##
#M  GeneratorsSmallest(<G>) . . . . . . . . . . . . . for permutation groups
##
GeneratorsSmallestStab := function ( S )
    local   gens,       # smallest generating system of <S>, result
            gen,        # one generator in <gens>
            orb,        # basic orbit of <S>
            pnt,        # one point in <orb>
            T;          # stabilizer in <S>

    # handle the anchor case
    if Length(S.generators) = 0  then
        return [];
    fi;

    # now get the smallest generating system of the stabilizer
    gens := GeneratorsSmallestStab( S.stabilizer );

    # get the sorted orbit (the basepoint will be the first point)
    orb := Set( S.orbit );
    SubtractSet( orb, [S.orbit[1]] );

    # handle the other points in the orbit
    while Length(orb) <> 0  do

        # take the smallest point (coset) and one representative
        pnt := orb[1];
        gen := S.identity;
        while S.orbit[1] ^ gen <> pnt  do
           gen := LeftQuotient( S.transversal[ pnt / gen ], gen );
        od;

        # the next generator is the smallest element in this coset
        T := S.stabilizer;
        while Length(T.generators) <> 0  do
            pnt := Minimum( OnTuples( T.orbit, gen ) );
            while T.orbit[1] ^ gen <> pnt  do
                gen := LeftQuotient( T.transversal[ pnt / gen ], gen );
            od;
            T := T.stabilizer;
        od;

        # add this generator to the generators list and reduce orbit
        Add( gens, gen );
        SubtractSet( orb, Orbit( Group( gens, () ), S.orbit[1] ) );

    od;

    # return the smallest generating system
    return gens;
end;

InstallMethod(GeneratorsSmallest,"perm group via minimal stab chain",true,
  [IsPermGroup],0,
function(G)
local gens;
  # call the recursive function to do the work
  return GeneratorsSmallestStab(MinimalStabChain(G));
end);

InstallMethod(KnowsHowToDecompose,"perm group: always true",IsIdentical,
  [IsPermGroup,IsList],0,ReturnTrue);

InstallOtherMethod(KnowsHowToDecompose,"perm group: always true",true,
  [IsPermGroup],0,ReturnTrue);

#############################################################################
##
##  Local Variables:
##  mode:             outline-minor
##  outline-regexp:   "#[WCROAPMFVE]"
##  fill-column:      77
##  End:

#############################################################################
##
#E  grpperm.gi  . . . . . . . . . . . . . . . . . . . . . . . . . . ends here

