#############################################################################
##
#W  algebra.gi                  GAP library                     Thomas Breuer
#W                                                        and Willem de Graaf
##
#H  @(#)$Id$
##
#Y  Copyright (C)  1996,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
##  This file contains generic methods for algebras and unital algebras.
##
Revision.algebra_gi :=
    "@(#)$Id$";


#############################################################################
##
#V  InfoAlgebra
##
InfoAlgebra := NewInfoClass( "InfoAlgebra" );


#############################################################################
##
#M  Representative( <A> ) . . . . . . . . one element of a left operator ring
##
InstallMethod( Representative,
    "method for left operator ring with known generators",
    true,
    [ IsLeftOperatorRing and HasGeneratorsOfLeftOperatorRing ], 0,
    RepresentativeFromGenerators( GeneratorsOfLeftOperatorRing ) );


#############################################################################
##
#M  Representative( <A> ) . . . .  one element of a left operator unital ring
##
InstallMethod( Representative,
    "method for left operator unital ring with known generators",
    true,
    [ IsLeftOperatorUnitalRing and HasGeneratorsOfLeftOperatorUnitalRing ],
    0,
    RepresentativeFromGenerators( GeneratorsOfLeftOperatorUnitalRing ) );


#############################################################################
##
#M  FLMLORByGenerators( <R>, <gens> ) . . . .  <R>-FLMLOR generated by <gens>
#M  FLMLORByGenerators( <R>, <gens>, <zero> )
##
InstallMethod( FLMLORByGenerators, true,
    [ IsRing, IsCollection ], 0,
    function( R, gens )
    local A;
    A:= Objectify( NewKind( FamilyObj( gens ),
                            IsFLMLOR and IsAttributeStoringRep ),
                   rec() );
    SetLeftActingDomain( A, R );
    SetGeneratorsOfLeftOperatorRing( A, AsList( gens ) );
    return A;
    end );

InstallOtherMethod( FLMLORByGenerators, true,
    [ IsRing, IsEmpty, IsRingElement ], 0,
    function( R, gens, zero )
    local A;
    A:= Objectify( NewKind( CollectionsFamily( FamilyObj( zero ) ),
                            IsFLMLOR and IsAttributeStoringRep ),
                   rec() );
    SetLeftActingDomain( A, R );
    SetGeneratorsOfLeftOperatorRing( A, AsList( gens ) );
    SetZero( A, Immutable( zero ) );
    return A;
    end );

InstallOtherMethod( FLMLORByGenerators, true,
    [ IsRing, IsCollection, IsRingElement ], 0,
    function( R, gens, zero )
    local A;
    A:= Objectify( NewKind( CollectionsFamily( FamilyObj( zero ) ),
                            IsFLMLOR and IsAttributeStoringRep ),
                   rec() );
    SetLeftActingDomain( A, R );
    SetGeneratorsOfLeftOperatorRing( A, AsList( gens ) );
    SetZero( A, Immutable( zero ) );
    return A;
    end );


#T #############################################################################
#T ##
#T #M  FLMLORByGenerators( <F>, <gens> ) . . . . <F>-algebra generated by <gens>
#T #M  FLMLORByGenerators( <F>, <gens>, <zero> )
#T ##
#T InstallMethod( FLMLORByGenerators, true,
#T     [ IsDivisionRing, IsCollection ], 0,
#T     function( F, gens )
#T     local A;
#T     A:= Objectify( NewKind( FamilyObj( gens ),
#T                             IsAlgebra and IsAttributeStoringRep ),
#T                    rec() );
#T     SetLeftActingDomain( A, F );
#T     SetGeneratorsOfLeftOperatorRing( A, AsList( gens ) );
#T     return A;
#T     end );
#T 
#T InstallOtherMethod( FLMLORByGenerators, true,
#T     [ IsDivisionRing, IsEmpty, IsRingElement ], 0,
#T     function( F, gens, zero )
#T     local A;
#T     A:= Objectify( NewKind( CollectionsFamily( FamilyObj( zero ) ),
#T                             IsAlgebra and IsAttributeStoringRep ),
#T                    rec() );
#T     SetLeftActingDomain( A, F );
#T     SetGeneratorsOfLeftOperatorRing( A, AsList( gens ) );
#T     SetZero( A, Immutable( zero ) );
#T     return A;
#T     end );
#T 
#T InstallOtherMethod( FLMLORByGenerators, true,
#T     [ IsDivisionRing, IsCollection, IsRingElement ], 0,
#T     function( F, gens, zero )
#T     local A;
#T     A:= Objectify( NewKind( CollectionsFamily( FamilyObj( zero ) ),
#T                             IsAlgebra and IsAttributeStoringRep ),
#T                    rec() );
#T     SetLeftActingDomain( A, F );
#T     SetGeneratorsOfLeftOperatorRing( A, AsList( gens ) );
#T     SetZero( A, Immutable( zero ) );
#T     return A;
#T     end );


#############################################################################
##
#F  Algebra( <F>, <gens> )
#F  Algebra( <F>, <gens>, <zero> )
#F  Algebra( <F>, <gens>, "basis" )
#F  Algebra( <F>, <gens>, <zero>, "basis" )
##
FLMLOR := function( arg )

    local A;

    # ring and list of generators
    if Length( arg ) = 2 and IsRing( arg[1] )
                         and IsList( arg[2] ) and 0 < Length( arg[2] ) then
      A:= FLMLORByGenerators( arg[1], arg[2] );

    # ring, list of generators plus zero
    elif Length( arg ) = 3 and IsRing( arg[1] )
                           and IsList( arg[2] ) then
      if arg[3] = "basis" then
        A:= FLMLORByGenerators( arg[1], arg[2] );
        UseBasis( A, arg[2] );
      else
        A:= FLMLORByGenerators( arg[1], arg[2], arg[3] );
      fi;

    # ring, list of generators plus zero
    elif Length( arg ) = 4 and IsRing( arg[1] )
                           and IsList( arg[2] )
                           and arg[4] = "basis" then
      A:= FLMLORByGenerators( arg[1], arg[2], arg[3] );
      UseBasis( A, arg[2] );

    # no argument given, error
    else
      Error( "usage: FLMLOR( <F>, <gens> ), ",
             "FLMLOR( <F>, <gens>, <zero> )" );
    fi;

    # Return the result.
    return A;
end;

Algebra := FLMLOR;


#############################################################################
##
#F  Subalgebra( <A>, <gens> ) . . . . . subalgebra of <A> generated by <gens>
#F  Subalgebra( <A>, <gens>, "basis" )
##
SubFLMLOR := function( arg )
    local S;
    if    Length( arg ) <= 1
       or not IsFLMLOR( arg[1] )
       or not IsHomogeneousList( arg[2] ) then
      Error( "first argument must be a FLMLOR,\n",
             "second argument must be a list of generators" );

    elif IsEmpty( arg[2] ) then

      return SubFLMLORNC( arg[1], arg[2] );

    elif     IsIdentical( FamilyObj( arg[1] ),
                          FamilyObj( arg[2] ) )
         and ForAll( arg[2], v -> v in arg[1] ) then

      S:= FLMLORByGenerators( LeftActingDomain( arg[1] ), arg[2] );
      SetParent( S, arg[1] );
      if Length( arg ) = 3 and arg[3] = "basis" then
        UseBasis( S, arg[2] );
      fi;
      return S;

    fi;
    Error( "usage: SubFLMLOR( <V>, <gens> [, \"basis\"] )" );
end;

Subalgebra := SubFLMLOR;
#T !!


#############################################################################
##
#F  SubalgebraNC( <A>, <gens>, "basis" )
#F  SubalgebraNC( <A>, <gens> )
##
SubFLMLORNC := function( arg )
    local S;
    if IsEmpty( arg[2] ) then
      S:= Objectify( NewKind( FamilyObj( arg[1] ),
                                  IsFLMLOR
                              and IsTrivial
                              and IsAttributeStoringRep ),
                     rec() );
      SetLeftActingDomain( S, LeftActingDomain( arg[1] ) );
      SetGeneratorsOfLeftOperatorRing( S, AsList( arg[2] ) );
    else
      S:= FLMLORByGenerators( LeftActingDomain( arg[1] ), arg[2] );
      if Length( arg ) = 3 and arg[3] = "basis" then
        UseBasis( S, arg[2] );
      fi;
    fi;
    SetParent( S, arg[1] );
    return S;
end;

SubalgebraNC := SubFLMLORNC;


#############################################################################
##
#F  UnitalAlgebra( <F>, <gens> )
#F  UnitalAlgebra( <F>, <gens>, <zero> )
#F  UnitalAlgebra( <F>, <gens>, "basis" )
#F  UnitalAlgebra( <F>, <gens>, <zero>, "basis" )
##
UnitalFLMLOR := function( arg )

    local A;

    # ring and list of generators
    if Length( arg ) = 2 and IsRing( arg[1] )
                         and IsList( arg[2] ) and 0 < Length( arg[2] ) then
      A:= UnitalFLMLORByGenerators( arg[1], arg[2] );

    # ring, list of generators plus zero
    elif Length( arg ) = 3 and IsRing( arg[1] )
                           and IsList( arg[2] ) then
      if arg[3] = "basis" then
        A:= UnitalFLMLORByGenerators( arg[1], arg[2] );
        UseBasis( A, arg[2] );
      else
        A:= UnitalFLMLORByGenerators( arg[1], arg[2], arg[3] );
      fi;

    # ring, list of generators plus zero
    elif Length( arg ) = 4 and IsRing( arg[1] )
                           and IsList( arg[2] )
                           and arg[4] = "basis" then
      A:= UnitalFLMLORByGenerators( arg[1], arg[2], arg[3] );
      UseBasis( A, arg[2] );

    # no argument given, error
    else
      Error( "usage: UnitalFLMLOR( <F>, <gens> ), ",
             "UnitalFLMLOR( <F>, <gens>, <zero> )" );
    fi;

    # Return the result.
    return A;
end;

UnitalAlgebra := UnitalFLMLOR;


#############################################################################
##
#F  UnitalSubalgebra( <A>, <gens> ) . .  unital subalg. of <A> gen. by <gens>
##
UnitalSubFLMLOR := function( arg )
    local S;
    if Length( arg ) <= 1 or not IsFLMLOR( arg[1] )
                          or not IsHomogeneousList( arg[2] ) then

      Error( "first argument must be a FLMLOR,\n",
             "second argument must be a list of generators" );

    elif IsEmpty( arg[2] ) then

      return UnitalSubFLMLORNC( arg[2], arg[2] );

    elif     IsIdentical( FamilyObj( arg[1] ),
                          FamilyObj( arg[2] ) )
         and ForAll( arg[2], v -> v in arg[1] )
         and ( IsUnitalFLMLOR( arg[1] ) or One( arg[1] ) <> fail ) then
      S:= UnitalFLMLORByGenerators( LeftActingDomain( arg[1] ), arg[2] );
      SetParent( S, arg[1] );
      if Length( arg ) = 3 and arg[3] = "basis" then
        UseBasis( S, arg[2] );
      fi;
      return S;
    fi;
    Error( "usage: UnitalSubFLMLOR( <V>, <gens> [, \"basis\"] )" );
end;

UnitalSubalgebra := UnitalSubFLMLOR;


#############################################################################
##
#F  UnitalSubalgebraNC( <A>, <gens> )
##
UnitalSubFLMLORNC := function( arg )
    local S, gens;
    if IsEmpty( arg[2] ) then

      # Note that 'S' is not trivial,
      # and if we call 'Objectify' here then 'S' does not get a special
      # representation (e.g., as a matrix algebra).
      # So the argument that special methods would catch this case
      # does not hold!
      gens:= [ One( arg[1] ) ];
      S:= UnitalFLMLORByGenerators( LeftActingDomain( arg[1] ), gens );
      UseBasis( S, gens );

    else

      S:= UnitalFLMLORByGenerators( LeftActingDomain( arg[1] ), arg[2] );
      if Length( arg ) = 3 and arg[3] = "basis" then
        UseBasis( S, arg[2] );
      fi;

    fi;

    SetParent( S, arg[1] );
    return S;
end;

UnitalSubalgebraNC := UnitalSubFLMLORNC;


#############################################################################
##
#F  LieAlgebra( <A> )
#F  LieAlgebra( <F>, <gens> )
#F  LieAlgebra( <F>, <gens>, <zero> )
#F  LieAlgebra( <F>, <gens>, "basis" )
#F  LieAlgebra( <F>, <gens>, <zero>, "basis" )
##
LieAlgebra := function( arg )

#T check that the families have the same characteristic?
#T 'CharacteristicFamily' ?
    local A;

    # In the case of one domain argument,
    # construct the isomorphic Lie algebra.
    if Length( arg ) = 1 and IsDomain( arg[1] ) then
      A:= LieAlgebraByDomain( arg[1] );

    # division ring and list of generators
    elif Length( arg ) = 2 and IsDivisionRing( arg[1] )
                           and IsList( arg[2] ) and 0 < Length( arg[2] ) then
      A:= LieAlgebraByGenerators( arg[1], arg[2] );

    # division ring, list of generators plus zero
    elif Length( arg ) = 3 and IsDivisionRing( arg[1] )
                           and IsList( arg[2] ) then
      if arg[3] = "basis" then
        A:= LieAlgebraByGenerators( arg[1], arg[2] );
        UseBasis( A, arg[2] );
      else
        A:= LieAlgebraByGenerators( arg[1], arg[2], arg[3] );
      fi;

    # division ring, list of generators plus zero
    elif Length( arg ) = 4 and IsDivisionRing( arg[1] )
                           and IsList( arg[2] )
                           and arg[4] = "basis" then
      A:= LieAlgebraByGenerators( arg[1], arg[2], arg[3] );
      UseBasis( A, arg[2] );

    # no argument given, error
    else
      Error( "usage: LieAlgebra( <F>, <gens> ), ",
             "LieAlgebra( <F>, <gens>, <zero> ), LieAlgebra( <D> )");
    fi;

    # Return the result.
    return A;
end;


#T #############################################################################
#T ##
#T #F  AlgebraString( <A>, <name> )  . . . . . . . .  algebra information string
#T ##
#T AlgebraString := function( A, name )
#T     if   IsBound( A.name )  then
#T       if   IsBound( A.dimension )  then
#T         return Concatenation( A.name, " (dimension ",
#T                               StringInt( A.dimension ), ")" );
#T       elif IsBound( A.size )  then
#T         return Concatenation( A.name, " (size ", StringInt( A.size ), ")" );
#T       else
#T         return A.name;
#T       fi;
#T     elif IsBound( A.dimension )  then
#T       return Concatenation( "<", name, "> (",
#T                             StringInt(Length(GeneratorsOfAlgebra(A))),
#T                             " gens, dimension ", StringInt( A.dimension ),
#T                             ")" );
#T     elif IsBound( A.size )  then
#T       return Concatenation( "<", name, "> (",
#T                             StringInt(Length(GeneratorsOfAlgebra(A))),
#T                             " gens, size ", StringInt( A.size ), ")" );
#T     else
#T       return Concatenation( "<", name, "> (",
#T                             StringInt(Length(GeneratorsOfAlgebra(A))),
#T                             " gens)" );
#T     fi;
#T     end;


#############################################################################
##
#F  EmptySCTable( <dim>, <zero> )
#F  EmptySCTable( <dim>, <zero>, \"symmetric\" )
#F  EmptySCTable( <dim>, <zero>, \"antisymmetric\" )
##
EmptySCTable := function( arg )

    local dim, T, entry, i;

    if     2 <= Length( arg )
       and IsInt( arg[1] ) and IsZero( arg[2] )
       and ( Length( arg ) = 2 or IsString( arg[3] ) ) then

      dim:= arg[1];
      T:= [];
      entry:= Immutable( [ [], [] ] );
      for i in [ 1 .. dim ] do
        T[i]:= List( [ 1 .. dim ], x -> entry );
      od;

      # Store the symmetry flag.
      if Length( arg ) = 3 then
        if   arg[3] = "symmetric" then
          Add( T, 1 );
        elif arg[3] = "antisymmetric" then
          Add( T, -1 );
        else
          Error("third argument must be \"symmetric\" or \"antisymmetric\"");
        fi;
      else
        Add( T, 0 );
      fi;
        
      # Store the zero coefficient.
      Add( T, arg[2] );

    else
      Error( "usage: EmptySCTable( <dim>, <zero> [,\"symmetric\"] )" );
    fi;

    return T;
end;


#############################################################################
##
#F  SetEntrySCTable( <T>, <i>, <j>, <list> )
##
SetEntrySCTable := function( T, i, j, list )

    local range, zero, Fam, entry, k;

    # Check that 'i' and 'j' are admissible.
    range:= [ 1 .. Length( T ) - 2 ];
    if not i in range then
      Error( "<i> must lie in ", range );
    fi;
    if not j in range then
      Error( "<j> must lie in ", range );
    fi;

    # Check that the entry may be set.
    if not IsEmpty( T[i][j][1] ) then
      Error( "entry has already been set, ",
             "use 'ChangeEntrySCTable' to overwrite" );
    fi;

    # Check the list, and construct the table entry.
    zero:= T[ Length( T ) ];
    Fam:= FamilyObj( zero );
    entry:= [ [], [] ];
    for k in [ 1, 3 .. Length( list ) -1 ] do
      if FamilyObj( list[k] ) <> Fam then
        Error( "list entry ", list[k], " does not fit to zero element" );
      elif not list[k+1] in range then
        Error( "list entry ", list[k+1], " must lie in ", range );
      elif list[k+1] in entry[1] then
        Error( "position ", list[k+1],
               " must occur at most once in <list>" );
      elif list[k] <> zero then
        Add( entry[1], list[ k+1 ] );
        Add( entry[2], list[  k  ] );
      fi;
    od;

    # Set the table entry.
    SortParallel( entry[1], entry[2] );
    T[i][j]:= Immutable( entry );

    # Add the value 'T[j][i]' in the case of (anti-)symmetric tables.
    if   T[ Length(T) - 1 ] =  1 then
      T[j][i]:= T[i][j];
    elif T[ Length(T) - 1 ] = -1 then
      T[j][i]:= Immutable( [ entry[1], -entry[2] ] );
    fi;
end;


#############################################################################
##
#F  GapInputSCTable( <T>, <varnam> )
##
GapInputSCTable := function( T, varnam )
    local dim, str, lower, i, j, entry, k;

    # Initialize.
    dim:= Length( T ) - 2;
    str:= Concatenation( varnam, ":= EmptySCTable( ",
                         String( dim ), ", ", String( T[ Length( T ) ] ) );
    if   T[ dim+1 ] =  1 then
      Append( str, ", \"symmetric\"" );
    elif T[ dim+1 ] = -1 then
      Append( str, ", \"antisymmetric\"" );
    fi;
    Append( str, " );\n" );

    # Set the ranges for the loops.
    if T[ dim+1 ] <> 0 then
      lower:= List( [ 1 .. dim ], i -> i+1 );
    else
      lower:= List( [ 1 .. dim ], i -> 1 );
    fi;

    # Fill up the table.
    for i in [ 1 .. dim ] do
      for j in [ 1 .. dim ] do
        entry:= T[i][j];
        if not IsEmpty( entry[1] ) then
          Append( str, "SetEntrySCTable( " );
          Append( str, varnam );
          Append( str, ", " );
          Append( str, String(i) );
          Append( str, ", " );
          Append( str, String(j) );
          Append( str, ", [" );
          for k in [ 1 .. Length( entry[1] )-1 ] do
            Append( str, String( entry[2][k] ) );
            Add( str, ',' );
            Append( str, String( entry[1][k] ) );
            Add( str, ',' );
          od;
          k:= Length( entry[1] );
          Append( str, String( entry[2][k] ) );
          Add( str, ',' );
          Append( str, String( entry[1][k] ) );
          Append( str, "] );\n" );
        fi;
      od;
    od;

    ConvertToStringRep( str );
    return str;
end;


#############################################################################
##
#F  IdentityFromSCTable( <T> )
##
IdentityFromSCTable := function( T )

    local n,       # dimension of the underlying algebra
          equ,     # equation system to solve
          zero,    # zero of the field
          zerovec, # zero vector
          vec,     # right hand side of the equation system
          one,     # identity of the field
          i, j, k, # loop over rows of 'equ'
          row,     # one row of the equation system
          Tpos,    #
          Tval,    #
          p,       #
          sol,
          sum;

    n:= Length( T ) - 2;

    # Set up the equation system,
    # in row $i$ and column $(k-1)*n + j$ we have $c_{ijk}$.
    equ:= [];
    zero:= T[ Length( T ) ];
    zerovec:= List( [ 1 .. n^2 ], x -> zero );
    vec:= ShallowCopy( zerovec );
    one:= One( zero );

    for i in [ 1 .. n ] do
      row:= ShallowCopy( zerovec );
      for j in [ 1 .. n ] do
        Tpos:= T[i][j][1];
        Tval:= T[i][j][2];
        p:= (j-1)*n;
        for k in [ 1 .. Length( Tpos ) ] do
          row[ p + Tpos[k] ]:= Tval[k];
        od;
      od;
      Add( equ, row );
      vec[ (i-1)*n + i ]:= one;
    od;

    sol:= SolutionMat( equ, vec );
    if sol <> fail then

      # Check whether the solution acts trivially from the right.
      for j in [ 1 .. n ] do
        for k in [ 1 .. n ] do
          sum:= zero;
          for i in [ 1 .. n ] do
            Tpos:= T[j][i];
            p:= Position( Tpos[1], k );
#T cheaper !!!
            if p <> fail then
              sum:= sum + sol[i] * Tpos[2][p];
            fi;
          od;
          if ( j = k and sum <> one ) or ( j <> k and sum <> zero ) then
            return fail;
          fi;
        od;
      od;

    fi;

    # Return the result.
    return sol;
end;


#############################################################################
##
#F  QuotientFromSCTable( <T>, <num>, <den> )
##
##  We solve the equation system $<num> = x <den>$.
##  If no solution exists, 'fail' is returned.
##
##  In terms of the basis $B$ with vectors $b_1, \ldots, b_n$ this means
##  for $<num> = \sum_{i=1}^n a_i b_i$,
##      $<den> = \sum_{i=1}^n c_i b_i$,
##      $x     = \sum_{i=1}^n x_i b_i$ that
##  $a_k = \sum_{i,j} c_i x_j c_{ijk}$ for all $k$.
##  Here $c_{ijk}$ denotes the structure constants w.r.t. $B$.
##  This means $a = x M$ with $M_{ik} = \sum_{j=1}^n c_{ijk} c_j$.
##
QuotientFromSCTable := function( T, x, c )

    local M,        # matrix of the equation system
          n,        # dimension of the algebra
          zero,     # zero vector
          i, j,     # loop variables
          row,      # one row of 'M'
          entry,    #
          val;      #

    M:= [];
    n:= Length( c );
    zero:= [ 1 .. n ] * T[ Length( T ) ];
    for i in [ 1 .. n ] do
      row:= ShallowCopy( zero );
      for j in [ 1 .. n ] do
        entry:= T[i][j];
        val:= c[j];
        row{ entry[1] }:= row{ entry[1] } + val * entry[2];
#T better!
      od;
      Add( M, row );
    od;

    # Return the quotient, or 'fail'.
    return SolutionMat( M, x );
end;


#############################################################################
##
#F  TestJacobi( <T> )
##
##  We check whether for all $1 \leq m \leq n$ the equality
##  $\sum_{l=1}^n c_{jkl} c_{ilm} + c_{kil} c_{jlm} + c_{ijl} c_{klm} = 0$
##  holds.
##
TestJacobi := function( T )

    local zero,           # the zero of the field
          n,              # dimension of the algebra
          i, j, k, m,     # loop variables
          cij, cki, cjk,  # structure constant vectors
          sum,
          t;

    zero:= T[ Length( T ) ];
    n:= Length( T ) - 2;
  
    for i in [ 1 .. n ] do
      for j in [ i+1 .. n ] do
        cij:= T[i][j];
        for k in [ j+1 .. n ] do
          cki:= T[k][i];
          cjk:= T[j][k];
          for m in [ 1 .. n ] do
            sum:= zero;
            for t in [ 1 .. Length( cjk[1] ) ] do
              sum:= sum + cjk[2][t] * SCTableEntry( T, i, cjk[1][t], m );
            od;
            for t in [ 1 .. Length( cki[1] ) ] do
              sum:= sum + cki[2][t] * SCTableEntry( T, j, cki[1][t], m );
            od;
            for t in [ 1 .. Length( cij[1] ) ] do
              sum:= sum + cij[2][t] * SCTableEntry( T, k, cij[1][t], m );
            od;
            if sum <> zero then
              return [ i, j, k ];
            fi;
          od;
        od;
      od;
    od;
        
    return true;
end;


#############################################################################
##
#M  MultiplicativeNeutralElement( <A> )
##
##  is the multiplicative neutral element of <A> if this exists,
##  otherwise is 'fail'.
##
##  Let $(b_1, b_2, \ldots, b_n)$ be a basis of $A$, and $e$ the result of
##  'MultiplicativeNeutralElement( <A> )'.
##  Then $e = \sum_{i=1}^n a_i b_i$, and for $1 \leq k \leq n$ we have
##  $e \cdot b_j = b_j$, or equivalently
##  $\sum_{i=1}^n a_i b_i \cdot b_j = b_j$.
##  Define the structure constants by
##  $b_i \cdot b_j = \sum_{k=1}^n c_{ijk} b_k$.
##
##  Then $\sum_{i=1}^n a_i c_{ijk} = \delta_{jk}$ for $1 \leq k \leq n$.
##
##  This yields $n^2$ linear equations for the $n$ indeterminates $a_i$,
##  and a solution is a left identity.
##  For this we have to test whether it is also a right identity.
##
InstallMethod( MultiplicativeNeutralElement, true,
    [ IsFLMLOR and IsFiniteDimensional ], 0,
    function( A )

    local B,       # basis of 'A'
          one;     # result

    B:= BasisOfDomain( A );
    one:= IdentityFromSCTable( StructureConstantsTable( B ) );
    if one <> fail then
      one:= LinearCombination( B, one );
    fi;
    return one;
    end );


#############################################################################
##
#M  IsAssociative( <A> )
##
##  We check whether the vectors of a basis satisfy the associativity law.
##  (Bilinearity of the multiplication is of course assumed.)
##
##  If $b_i \cdot b_j = \sum_{l=1}^n c_{ijl} b_l$ then we have 
##  $b_i \cdot ( b_j \cdot b_k ) = ( b_i \cdot b_j ) \cdot b_k$
##  if and only if
##  $\sum_{l=1}^n c_{jkl} c_{ilm} = \sum_{l=1}^n c_{ijl} c_{lkm}$ for all
##  $1 \leq m \leq n$.
##
##  We check this equality for all $1 \leq i, j, k \leq n$.
##  
InstallMethod( IsAssociative,
    "generic method for a (finite dimensional) FLMLOR",
    true, [ IsFLMLOR ], 0,
    function( A )

    local T,            # structure constants table w.r.t. a basis of 'A'
          zero,
          range,
          i, j, k, l, m,
          Ti,
          Tj,
          cijpos,
          cijval,
          cjkpos,
          cjkval,
          sum,
          x,
          pos;

    if not IsFiniteDimensional( A ) then
      TryNextMethod();
    fi;

    T:= StructureConstantsTable( BasisOfDomain( A ) );
    zero:= Zero( LeftActingDomain( A ) );
    range:= [ 1 .. Length( T[1] ) ];
    for i in range do
      Ti:= T[i];
      for j in range do
        cijpos:= Ti[j][1];
        cijval:= Ti[j][2];
        Tj:= T[j];
        for k in range do
          cjkpos:= Tj[k][1];
          cjkval:= Tj[k][2];
          for m in range do
            sum:= zero;
            for l in [ 1 .. Length( cjkpos ) ] do
              x:= Ti[ cjkpos[l] ];
              pos:= Position( x[1], m );
              if pos <> fail then
                sum:= sum + cjkval[l] * x[2][ pos ];
              fi;
            od;
            for l in [ 1 .. Length( cijpos ) ] do

              x:= T[ cijpos[l] ][k];
              pos:= Position( x[1], m );
              if pos <> fail then
                sum:= sum - cijval[l] * x[2][ pos ];
              fi;
            od;
            if sum <> zero then
              # $i, j, k$ fail
              Info( InfoAlgebra, 2,
                    "IsAssociative fails for i = ", i, ", j = ", j,
                    ", k = ", k );
              return false;
            fi;
          od;
        od;
      od;
    od;
    return true;
    end );


##############################################################################
##
#M  IsAnticommutative( <A> )
##
##  is 'true' if the multiplication in <A> is anticommutative,
##  and 'false' otherwise.
## 
InstallMethod( IsAnticommutative,
    "generic method for a (finite dimensional) FLMLOR",
    true, [ IsFLMLOR ], 0,
    function( A )

    local n,      # dimension of 'A'
          T,      # table of structure constants for 'A'
          zero,   # zero coefficient
          i, j;   # loop over rows and columns ot 'T'

    if not IsFiniteDimensional( A ) then
      TryNextMethod();
    fi;

    n:= Dimension( A );
    T:= StructureConstantsTable( BasisOfDomain( A ) );
    zero:= T[ n+2 ];
    for i in [ 2 .. n ] do
      for j in [ 1 .. i-1 ] do
        if    T[i][j][1] <> T[j][i][1]
           or ( not IsEmpty( T[i][j][1] )
                and PositionNot( T[i][j][2] + T[j][i][2], zero )
                        <= Length( T[i][j][2] ) ) then
          return false;
        fi;
      od;
    od;

    if Characteristic( A ) <> 2 then

      # The values on the diagonal must be zero.
      for i in [ 1 .. n ] do
        if not IsEmpty( T[i][i][1] ) then
          return false;
        fi;
      od;

    fi;

    return true;
    end );


#############################################################################
##
#M  IsCommutative( <A> )  . . . . . . . . . . . for finite dimensional FLMLOR
##
##  Check whether every basis vector commutes with every basis vector.
##
InstallMethod( IsCommutative,
    "generic method for a finite dimensional FLMLOR",
    true, [ IsFLMLOR ], 0,
    IsCommutativeFromGenerators( GeneratorsOfVectorSpace ) );
#T use structure constants!


#############################################################################
##
#M  IsCommutative( <A> )  . . . . . . . . . . . . . for an associative FLMLOR
##
##  If <A> is associative then we can restrict the check to a smaller
##  equation system than that for arbitrary algebras, since we have to check
##  $x a = a x$ only for algebra generators $a$ and $x$, not for all vectors
##  of a basis.
##
InstallMethod( IsCommutative,
    "method for an associative FLMLOR",
    true, [ IsFLMLOR and IsAssociative ], 0,
    IsCommutativeFromGenerators( GeneratorsOfAlgebra ) );

InstallMethod( IsCommutative,
    "method for an associative unital FLMLOR",
    true, [ IsUnitalFLMLOR and IsAssociative ], 0,
    IsCommutativeFromGenerators( GeneratorsOfUnitalAlgebra ) );


#############################################################################
##
#M  IsZeroSquaredRing( <A> )  . . . . . . . . for a finite dimensional FLMLOR
##
InstallMethod( IsZeroSquaredRing,
    "method for a finite dimensional FLMLOR",
    true,
    [ IsFLMLOR ], 0,
    function( A )

    if not IsAnticommutative( A ) then

      # Every zero squared ring is anticommutative.
      return false;

    elif ForAny( BasisVectors( BasisOfDomain( A ) ),
                 x -> not IsZero( x*x ) ) then

      # If not all basis vectors are zero squared then we return 'false'.
      return false;

    elif IsCommutative( LeftActingDomain( A ) ) then

      # If otherwise the left acting domain is commutative then we return
      # 'true' because we know that <A> is anticommutative and the basis
      # vectors are zero squared.
      return true;

    else

      # Otherwise we give up.
      TryNextMethod();

    fi;
    end );
    

#############################################################################
##
#M  Centre( <A> )  . . . . . . . . . . . . . centre of an associative algebra
##
##  We can restrict the check to a smaller equation system than that for
##  arbitrary algebras, since we have to check $x a = a x$ only for algebra
##  generators $a$, not for all vectors of a basis.
##
#T use/compute structure constants ?
##
InstallMethod( Centre,
    "method for a finite dimensional associative FLMLOR",
    true, [ IsFLMLOR and IsAssociative ], 0,
    function( A )

    local   C,      # centre of <A>, result
            B,      # a basis of 'A'
            M;      # matrix of the equation system

    if not IsFiniteDimensional( A ) then
      TryNextMethod();
    fi;

    # Make sure that the FLMLOR is written over a commutative ring.
    if not IsCommutative( LeftActingDomain( A ) ) then
      A:= AsFLMLOR( Centre( LeftActingDomain( A ) ), A );
    fi;

    # Construct the equation system.
    B:= BasisOfDomain( A );
    M:= List( BasisVectors( B ), bi ->
              Concatenation( List( GeneratorsOfAlgebra( A ),
                             a -> Coefficients( B, bi * a - a * bi ) ) ) );

    # Solve the equation system.
    M:= NullspaceMat( M );

    # Get the generators from the coefficient vectors.
    M:= List( M, x -> LinearCombination( B, x ) );

    # Construct the centre.
    C:= SubFLMLOR( A, M, "basis" );

    # Return the centre.
    return C;
    end );


#############################################################################
##
#M  IsJacobianRing( <A> )
##
InstallMethod( IsJacobianRing,
    "method for a (finite dimensional) FLMLOR",
    true, [ IsFLMLOR ], 0,
    function( A )

    local n,   # dimension of 'A'
          T,   # table of structure constants for 'A'
          i;   # loop over the diagonal of 'T'

    if not IsFiniteDimensional( A ) then
      TryNextMethod();
    fi;

    # In characteristic 2 we have to make sure that $a \* a = 0$.
    T:= StructureConstantsTable( BasisOfDomain( A ) );
    if Characteristic( A ) = 2 then
      n:= Dimension( A );
      for i in [ 1 .. n ] do
        if not IsEmpty( T[i][i][1] ) then
          return false;
        fi;
      od;
    fi;

    # Check the Jacobi identity $[a,[b,c]] + [b,[c,a]] + [c,[a,b]] = 0$.
    return TestJacobi( T ) = true;
    end );


#T #############################################################################
#T ##
#T #M  FpAlgebra( <K>, <A> ) . . . . . . . . . . . .  f.p. algebra of an algebra
#T ##
#T ##  Construct the free nonassociative algebra $F$ on a basis of <A>,
#T ##  and factor out the two-sided ideal $I$ spanned by the structure relators.
#T ##  Then clearly the kernel of the homomorphism from $F$ to <A> contains $I$,
#T ##  on the other hand any expression in the kernel can be reduced to a sum
#T ##  of generators modulo the structure relators of <A>, and this must be
#T ##  trivial since the images of generators were assumed to be linearly
#T ##  independent.
#T ##
#T InstallMethod( FpAlgebra, true, [ IsDivisionRing, IsAlgebra ], 0,
#T     function( K, A )
#T 
#T     local T,         # structure constants table w.r. to a basis of 'A'
#T           F,         # free algebra
#T           rels,      # relators list
#T           Fgens,     # algebra generators of 'F'
#T           Tijpos,    # positions of nonzero coefficients in 'T[i][j]'
#T           Tijval,    # nonzero coefficients in 'T[i][j]'
#T           rhs,       # right hand side of a relation
#T           i, j, k;   # loop over basis vectors
#T 
#T     if LeftActingDomain( A ) <> K then
#T       return FpAlgebra( AsAlgebra( K, A ) );
#T     fi;
#T 
#T     T     := StructureConstantsTable( BasisOfDomain( A ) );
#T     F     := FreeAlgebra( K, Dimension( A ) );
#T     rels  := [];
#T     Fgens := GeneratorsOfAlgebra( F );
#T 
#T     for i in [ 1 .. Dimension( A ) ] do
#T       for j in [ 1 .. Dimension( A ) ] do
#T         Tijpos:= T[i][j][1];
#T         Tijval:= T[i][j][2];
#T         rhs:= Zero( F );
#T         for k in [ 1 .. Length( Tijpos ) ] do
#T           rhs:= rhs + Tijval[k] * Fgens[ Tijpos[k] ];
#T         od;
#T         Add( rels, Fgens[i] * Fgens[j] - rhs );
#T       od;
#T     od;
#T 
#T     return F / rels;
#T     end );


#############################################################################
##
#M  FpAlgebra( <K>, <A> ) . . . . . .  f.p. algebra of an associative algebra
##
##  Construct this algebra $F$ on a basis of <A>,
##  and factor out the ideal $I$ spanned by the structure relators.
##  Then clearly the kernel of the homomorphism from $F$ to <A> contains $I$,
##  on the other hand any expression in the kernel can be reduced to a sum
##  of generators modulo the structure relators of <A>, and this must be
##  trivial since the images of generators were assumed to be linearly
##  independent.
##
#T use/compute structure constants?
##
InstallMethod( FpAlgebra,
    "method for division ring and fin. dim. associative algebra",
    true, [ IsDivisionRing, IsAlgebra and IsAssociative ], 0,
    function( K, A )

    local B,         # basis of 'A'
          dim,       # dimension of 'A'
          vectors,   # basis vectors of 'B'
          F,         # free algebra
          Fgens,     # algebra generators of 'F'
          rels,      # relators list
          coeff,     # coefficients of one product
          rhs,       # right hand side of a relation
          i, j, k;   # loop over 'B'

    if not IsFiniteDimensional( A ) or One( A ) = fail then
      TryNextMethod();
    fi;

    B       := BasisOfDomain( A );
    dim     := Dimension( A );
    vectors := BasisVectors( B );
    F       := FreeAssociativeAlgebra( K, Dimension( A ) );
    Fgens   := GeneratorsOfUnitalAlgebra( F );
    rels    := [];

    for i in [ 1 .. dim ] do
      for j in [ 1 .. dim ] do
        coeff:= Coefficients( B, vectors[i] * vectors[j] );
        rhs:= Zero( F );
        for k in [ 1 .. dim ] do
          rhs:= rhs + coeff[k] * Fgens[k];
        od;
        Add( rels, Fgens[i] * Fgens[j] - rhs );
      od;
    od;
    return F / rels;
    end );


#############################################################################
##
#M  Intersection2( <A1>, <A2> ) . . . . . . . .  intersection of two algebras
##
InstallMethod( Intersection2,
    "generic method for two FLMLORs",
    IsIdentical, [ IsFLMLOR, IsFLMLOR ], 0,
    Intersection2Spaces( AsFLMLOR, SubFLMLORNC, FLMLOR ) );


#############################################################################
##
#M  Intersection2( <A1>, <A2> ) . . . . . intersection of two unital algebras
##
InstallMethod( Intersection2,
    "generic method for two unital FLMLORs",
    IsIdentical, [ IsUnitalFLMLOR, IsUnitalFLMLOR ], 0,
    Intersection2Spaces( AsUnitalFLMLOR, UnitalSubFLMLORNC, UnitalFLMLOR ) );


#############################################################################
##
#M  \/( <A>, <I> )  . . . . . . . . . . . .  factor of an algebra by an ideal
#M  \/( <A>, <relators> ) . . . . . . . . .  factor of an algebra by an ideal
##
##  is the factor algebra of the finite dimensional algebra <A> modulo
##  the ideal <I> or the list of ideal generators <relators>.
##  
##  Factor algebras are represented as s.c. algebras in the generic case.
##
InstallOtherMethod( \/,
    "method for FLMLOR and collection",
    IsIdentical, [ IsFLMLOR, IsCollection ], 0,
    function( A, relators )
    return A / IdealByGenerators( A, relators );
    end );

#T InstallOtherMethod( \/,
#T     "generic method for two finite dimensional FLMLORs",
#T     IsIdentical, [ IsFLMLOR, IsFLMLOR ], 0,
#T     function( A, I )
#T 
#T     local Igens,    # list of ideal generators
#T           B,        # a basis of 'A'
#T           VA,
#T           VI,
#T           hom,
#T           VB,
#T           reps,
#T           zero,
#T           empty,
#T           n,
#T           T,
#T           i, j,
#T           prod,
#T           coeff,
#T           pos,
#T           F;
#T 
#T     # Check the arguments.
#T     if not IsFiniteDimensional( A ) then
#T       TryNextMethod();
#T     elif not IsIdeal( A, I ) then
#T       Error( "<I> must be an ideal in <A>" );
#T     fi;
#T     Igens:= GeneratorsOfVectorSpace( I );
#T 
#T     # Construct a complementary basis.
#T     B:= BasisOfDomain( A );
#T     VA:= FullRowSpace( LeftActingDomain( A ), Dimension( A ) );
#T     VI:= Subspace( VA, List( Igens, x -> Coefficients( B, x ) ) );
#T     hom:= NaturalHomomorphism( VA, VA / VI );
#T     VB:= BasisOfDomain( Range( hom ) );
#T     reps:= List( VB!.vectorsrepresentatives, x -> LinearCombination( B, x ) );
#T #T !!
#T 
#T     # Compute the structure constants of the quotient algebra.
#T     zero:= Zero( LeftActingDomain( A ) );
#T     empty:= [ [], [] ];
#T     n:= Length( BasisVectors( VB ) );
#T     T:= [];
#T     for i in [ 1 .. Length( reps ) ] do
#T       T[i]:= [];
#T       for j in [ 1 .. Length( reps ) ] do
#T         prod:= Image( hom, Coefficients( B, reps[i] * reps[j] ) );
#T         coeff:= Coefficients( VB, prod );
#T         pos:= Filtered( [ 1 .. n ], i -> coeff[i] <> zero );
#T         if not IsEmpty( pos ) then
#T           T[i][j]:= [ pos, coeff{ pos } ];
#T         else
#T           T[i][j]:= empty;
#T         fi;
#T       od;
#T     od;
#T     T[ Length( T ) + 1 ]:= 0;
#T     T[ Length( T ) + 1 ]:= zero;
#T 
#T     # Construct the image algebra.
#T     F:= AlgebraByStructureConstants( LeftActingDomain( A ), T );
#T 
#T     # Add the components that make it into a generic factor structure.
#T     SetFactorNum( F, A );
#T     SetFactorDen( F, I );
#T 
#T     # Add the information needed to compute the natural homomorphism.
#T     F!.hominfo:= rec(
#T #T !!
#T                      basisimage          := CanonicalBasis( F ),
#T                      preimagesbasisimage := reps 
#T                     );
#T     F!.hominfo.basissource       := A.basis;
#T     F!.hominfo.imagesbasissource := List( BasisVectors( CanonicalBasis( VA ) ),
#T            x -> LinearCombination( F.canonicalBasis,
#T                       Coefficients( VB, Image( hom, x ) ) ) );
#T 
#T     # Return the factor algebra.
#T     return F;
#T     end );


#############################################################################
##
#M  NaturalHomomorphism( <V>, <W> )
##
##  is the natural homomorphism from the algebra <V> to the algebra <W>.
##  <V> must be a subalgebra or a subspace of 'FactorNum( <W> )'.
##
#T InstallMethod( NaturalHomomorphism, true,
#T     [ IsVectorSpace, IsAlgebra and HasFactorNum ], 0,
#T     function( V, W )

#T InstallMethod( NaturalHomomorphism, true,
#T     [ IsAlgebra, IsAlgebra and HasFactorNum ], 0,
#T     function( V, W )
#T 
#T     local   hom;        # natural homomorphism from <V> onto <W>, result
#T 
#T     # Make the algebra homomorphism.
#T     hom:= rec(
#T                isGeneralMapping := true,
#T                domain           := Mappings,
#T                source           := V,
#T                range            := W,
#T            
#T                # enter useful information
#T                isMapping        := true,
#T                isHomomorphism   := true,
#T                isAlgebraHomomorphism   := true,
#T                isEndomorphism   := false,
#T                isAutomorphism   := false
#T               );
#T 
#T     hom.preImage:= hom.source;
#T 
#T     if V = W.factorNum then
#T       hom.isInjective     := IsTrivial( W.factorDen );
#T       hom.isSurjective    := true;
#T       hom.isBijection     := hom.isInjective;
#T       hom.isMonomorphism  := hom.isInjective;
#T       hom.isEpimorphism   := true;
#T       hom.isIsomorphism   := hom.isInjective;
#T       hom.image           := hom.range;
#T       hom.kernel          := W.factorDen;
#T     fi;
#T 
#T     # Enter the operations record.
#T     hom.operations        := NaturalHomomorphismAlgebraOps;
#T 
#T     # Enter the defining information.
#T     if not IsBound( W.hominfo ) then
#T       Error( "need the 'hominfo' component" );
#T     elif V = W.factorNum then
#T       hom.basissource         := W.hominfo.basissource;
#T       hom.imagesbasissource   := W.hominfo.imagesbasissource;
#T       hom.basisimage          := W.hominfo.basisimage;
#T       hom.preimagesbasisimage := W.hominfo.preimagesbasisimage;
#T     else
#T       hom.basissource         := BasisOfDomain( V );
#T       hom.imagesbasissource   := List( BasisVectors( hom.basissource ),
#T                 x -> LinearCombination( W.hominfo.imagesbasissource,
#T                              Coefficients( W.hominfo.basissource, x ) ) );
#T       hom.image               := Subalgebra( hom.range,
#T                                              hom.imagesbasissource );
#T       hom.basisimage          := BasisOfDomain( hom.image );
#T       hom.preimagesbasisimage := List( BasisVectors( hom.basisimage ),
#T                 x -> LinearCombination( W.hominfo.preimagesbasisimage,
#T                              Coefficients( W.hominfo.basisimage, x ) ) );
#T     fi;
#T 
#T     # Return the homomorphism.
#T     return hom;
#T     end );


#############################################################################
##
#M  IsFinite( <A> ) . . . . . . . . . . . .  check whether a FLMLOR is finite
##
InstallMethod( IsFinite,
    "generic method for a FLMLOR",
    true, [ IsFLMLOR ], 0,
    A ->   ( IsFiniteDimensional( A ) and IsFinite( LeftActingDomain( A ) ) )
         or ForAll( GeneratorsOfLeftOperatorRing( A ), IsZero ) );


#############################################################################
##
#M  IsFinite( <A> ) . . . . . . . . . check whether a unital FLMLOR is finite
##
InstallMethod( IsFinite,
    "generic method for a FLMLOR",
    true, [ IsUnitalFLMLOR ], 0,
    A -> IsFiniteDimensional( A ) and IsFinite( LeftActingDomain( A ) ) );


#T#############################################################################
#T##
#T#M  Size( <A> ) . . . . . . . . . . . . . . . . . . . . . .  size of a FLMLOR
#T##
#TInstallMethod( Size,
#T    "generic method for a FLMLOR",
#T    true, [ IsFLMLOR ], 0,
#T    function( A )
#T    if not (    IsFinite( LeftActingDomain( A ) )
#T             or IsFiniteDimensional( A ) ) then
#T      return infinity;
#T    else
#T      return Size( LeftActingDomain( A ) ) ^ Dimension( A );
#T    fi;
#T    end );
#T
#T
#############################################################################
##
#M  TrivialSubalgebra( <A> )  . . . . . . .  trivial subalgebra of an algebra
##
InstallMethod( TrivialSubFLMLOR,
    "method for a FLMLOR",
    true, [ IsFLMLOR ], 0,
    A -> SubFLMLORNC( A, [] ) );
#T should be an ideal


#############################################################################
##
#M  TrivialSubspace( <A> )  . . . . . . . . . .  trivial subspace of a FLMLOR
##
##  We want that this knows to be a FLMLOR.
#T should know to be an ideal (in its parent?), too!
##
InstallMethod( TrivialSubspace,
    "method for a FLMLOR",
    true, [ IsFLMLOR ], 0,
    TrivialSubFLMLOR );


#############################################################################
##
#M  AsAlgebra( <F>, <C> )  view a collection as an algebra over the field <F>
##
InstallMethod( AsFLMLOR,
    "method for a ring and a collection",
    true, [ IsRing, IsCollection ], 0,
    function( F, D )
    local A, L;

    D:= AsListSorted( D );
    L:= ShallowCopy( D );
    A:= TrivialSubFLMLOR( AsFLMLOR( F, D ) );
    SubtractSet( L, AsListSorted( A ) );
    while 0 < Length(L)  do
      A:= ClosureLeftOperatorRing( A, L[1] );
#T call explicit function that maintains an elements list?
      SubtractSet( L, AsListSorted( A ) );
    od;
    if Length( AsList( A ) ) <> Length( D )  then
      Error( "the elements of <D> must form a FLMLOR" );
    fi;
    A:= FLMLOR( F, GeneratorsOfLeftOperatorRing( A ), Zero( D[1] ) );
    SetAsListSorted( A, D );
    SetSize( A, Length( D ) );
    SetIsFinite( A, true );
#T ?

    # Return the algebra.
    return A;
    end );


#############################################################################
##
#M  AsAlgebra( <F>, <V> ) .  view a left module as algebra over the field <F>
##
##  is an algebra over <F> that is equal (as set) to <V>.
##  For that, perhaps the field of <A> has to be changed before
##  getting the correct list of generators.
##
InstallMethod( AsFLMLOR,
    "method for a division ring and a free left module",
    true, [ IsDivisionRing, IsFreeLeftModule ], 0,
    function( F, V )

    local L, A;

    if   LeftActingDomain( V ) = F then

      A:= FLMLOR( F, GeneratorsOfLeftModule( V ) );
      if A <> V then
        Error( "<V> is not a FLMLOR" );
      fi;
      if HasBasisOfDomain( V ) then
        SetBasisOfDomain( A, BasisOfDomain( V ) );
      fi;

    elif IsTrivial( V ) then

      # We need the zero.
      A:= FLMLOR( F, [], Zero( V ) );

    elif IsSubset( LeftActingDomain( V ), F ) then

      # Make sure that the field change does not change the elements.
      L:= BasisVectors( BasisOfDomain( AsField( F, LeftActingDomain( V ) ) ) );
      L:= Concatenation( List( L, x -> List( GeneratorsOfLeftModule( V ),
                                             y -> x * y ) ) );
      A:= FLMLOR( F, L );
      if A <> V then
        Error( "<V> is not a FLMLOR" );
      fi;

    elif IsSubset( F, LeftActingDomain( V ) ) then

      # Make sure that the field change does not change the elements.
      L:= BasisVectors( BasisOfDomain( AsField( LeftActingDomain( V ), F ) ) );
      if ForAny( L, x -> ForAny( GeneratorsOfLeftModule( V ),
                                 y -> not x * y in V ) ) then
        Error( "field change leads out of <V>" );
      fi;
      A:= FLMLOR( F, GeneratorsOfLeftModule( V ) );
      if A <> V then
        Error( "<V> is not a FLMLOR" );
      fi;

    else

      V:= AsFLMLOR( Intersection( F, LeftActingDomain( V ) ), V );
      return AsFLMLOR( F, V );

    fi;

    RunIsomorphismImplications( V, A );
    RunSubsetImplications( V, A );

    return A;
    end );


#############################################################################
##
#M  AsAlgebra( <F>, <A> ) . . . view an algebra as algebra over the field <F>
##
##  is an algebra over <F> that is equal (as set) to <D>.
##  For that, perhaps the field of <A> has to be changed before
##  getting the correct list of generators.
##
InstallMethod( AsFLMLOR,
    "method for a division ring and an algebra",
    true, [ IsDivisionRing, IsFLMLOR ], 0,
    function( F, D )

    local L, A;

    if   LeftActingDomain( D ) = F then

      return D;

    elif IsTrivial( D ) then

      # We need the zero.
      A:= FLMLOR( F, [], Zero( D ) );

    elif IsSubset( LeftActingDomain( D ), F ) then

      # Make sure that the field change does not change the elements.
      L:= BasisVectors( BasisOfDomain( AsField( F, LeftActingDomain( D ) ) ) );
      L:= Concatenation( List( L, x -> List( GeneratorsOfAlgebra( D ),
                                             y -> x * y ) ) );
      A:= FLMLOR( F, L );

    elif IsSubset( F, LeftActingDomain( D ) ) then

      # Make sure that the field change does not change the elements.
      L:= BasisVectors( BasisOfDomain( AsField( LeftActingDomain( D ), F ) ) );
      if ForAny( L, x -> ForAny( GeneratorsOfAlgebra( D ),
                                 y -> not x * y in D ) ) then
        Error( "field change leads out of <D>" );
      fi;
      A:= FLMLOR( F, GeneratorsOfAlgebra( D ) );

    else

      D:= AsFLMLOR( Intersection( F, LeftActingDomain( D ) ), D );
      return AsFLMLOR( F, D );

    fi;

    RunIsomorphismImplications( D, A );
    RunSubsetImplications( D, A );
    return A;
    end );


#############################################################################
##
#M  AsUnitalAlgebra( <F>, <D> ) . . . . . .  view a coll. as a unital algebra
##
InstallMethod( AsUnitalFLMLOR,
    "method for a ring and a collection",
    true,
    [ IsRing, IsCollection ], 0,
    function( F, D )
    return AsUnitalFLMLOR( AsFLMLOR( F, D ) );
    end );


#############################################################################
##
#M  AsUnitalAlgebra( <F>, <V> ) . . .  view a left module as a unital algebra
##
InstallMethod( AsUnitalFLMLOR,
    "method for a division ring and a free left module",
    true,
    [ IsDivisionRing, IsFreeLeftModule ], 0,
    function( F, V )

    local L, A;

    # Check that 'V' contains the identity.
    if One( V ) = fail then

      return fail;

    elif LeftActingDomain( V ) = F then

      A:= UnitalFLMLOR( F, GeneratorsOfLeftModule( V ) );
      if A <> V then
        Error( "<V> is not a unital FLMLOR" );
      fi;
      if HasBasisOfDomain( V ) then
        SetBasisOfDomain( A, BasisOfDomain( V ) );
      fi;

    elif IsSubset( LeftActingDomain( V ), F ) then

      # Make sure that the field change does not change the elements.
      L:= BasisVectors( BasisOfDomain( AsField( F, LeftActingDomain( V ) ) ) );
      L:= Concatenation( List( L, x -> List( GeneratorsOfLeftModule( V ),
                                             y -> x * y ) ) );
      A:= UnitalFLMLOR( F, L );
      if A <> V then
        Error( "<V> is not a unital FLMLOR" );
      fi;

    elif IsSubset( F, LeftActingDomain( V ) ) then

      # Make sure that the field change does not change the elements.
      L:= BasisVectors( BasisOfDomain( AsField( LeftActingDomain( V ), F ) ) );
      if ForAny( L, x -> ForAny( GeneratorsOfLeftModule( V ),
                                 y -> not x * y in V ) ) then
        Error( "field change leads out of <V>" );
      fi;
      A:= UnitalFLMLOR( F, GeneratorsOfLeftModule( V ) );
      if A <> V then
        Error( "<V> is not a unital FLMLOR" );
      fi;

    else

      V:= AsUnitalAlgebra( Intersection( F, LeftActingDomain( V ) ), V );
      return AsUnitalAlgebra( F, V );

    fi;

    RunIsomorphismImplications( V, A );
    RunSubsetImplications( V, A );
    return A;
    end );


#############################################################################
##
#M  AsUnitalAlgebra( <F>, <D> ) . . . . . view an algebra as a unital algebra
##
InstallMethod( AsUnitalFLMLOR,
    "method for a division ring and an algebra",
    true, [ IsDivisionRing, IsFLMLOR ], 0,
    function( F, D )

    local L, A;

    # Check that 'D' contains the identity.
    if One( D ) = fail then

      return fail;

    elif LeftActingDomain( D ) = F then

      A:= UnitalFLMLOR( F, GeneratorsOfLeftOperatorRing( D ) );

    elif IsSubset( LeftActingDomain( D ), F ) then

      # Make sure that the field change does not change the elements.
      L:= BasisVectors( BasisOfDomain( AsField( F, LeftActingDomain( D ) ) ) );
      L:= Concatenation( List( L, x -> List( GeneratorsOfAlgebra( D ),
                                             y -> x * y ) ) );
      A:= UnitalFLMLOR( F, L );

    elif IsSubset( F, LeftActingDomain( D ) ) then

      # Make sure that the field change does not change the elements.
      L:= BasisVectors( BasisOfDomain( AsField( LeftActingDomain( D ), F ) ) );
      if ForAny( L, x -> ForAny( GeneratorsOfAlgebra( D ),
                                 y -> not x * y in D ) ) then
        Error( "field change leads out of <D>" );
      fi;
      A:= UnitalFLMLOR( F, GeneratorsOfLeftOperatorRing( D ) );

    else

      D:= AsUnitalAlgebra( Intersection( F, LeftActingDomain( D ) ), D );
      return AsUnitalAlgebra( F, D );

    fi;

    RunIsomorphismImplications( D, A );
    RunSubsetImplications( D, A );
    return A;
    end );


#############################################################################
##
#M  AsUnitalAlgebra( <F>, <D> ) . . view a unital algebra as a unital algebra
##
InstallMethod( AsUnitalFLMLOR,
    "method for a division ring and a unital algebra",
    true, [ IsDivisionRing, IsUnitalFLMLOR ], 0,
    function( F, D )

    local L, A;

    if   LeftActingDomain( D ) = F then

      return D;

    elif IsSubset( LeftActingDomain( D ), F ) then

      # Make sure that the field change does not change the elements.
      L:= BasisVectors( BasisOfDomain( AsField( F, LeftActingDomain( D ) ) ) );
      L:= Concatenation( List( L, x -> List( GeneratorsOfAlgebra( D ),
                                             y -> x * y ) ) );
      A:= UnitalAlgebra( F, L );

    elif IsSubset( F, LeftActingDomain( D ) ) then

      # Make sure that the field change does not change the elements.
      L:= BasisVectors( BasisOfDomain( AsField( LeftActingDomain( D ), F ) ) );
      if ForAny( L, x -> ForAny( GeneratorsOfAlgebra( D ),
                                 y -> not x * y in D ) ) then
        Error( "field change leads out of the algebra" );
      fi;
      A:= UnitalAlgebra( F, GeneratorsOfAlgebra( D ) );

    else

      D:= AsUnitalAlgebra( Intersection( F, LeftActingDomain( D ) ), D );
      return AsUnitalAlgebra( F, D );

    fi;

    RunIsomorphismImplications( D, A );
    RunSubsetImplications( D, A );
    return A;
    end );


#############################################################################
##
#M  ClosureLeftOperatorRing( <A>, <a> ) . . . . . . . closure with an element
##
InstallMethod( ClosureLeftOperatorRing,
    "method for a FLMLOR and a ring element",
#T why not a general function for any left operator ring?
#T (need 'LeftOperatorRingByGenerators' ?)
    IsCollsElms,
    [ IsFLMLOR, IsRingElement ], 0,
    function( A, a )

    # if possible test if the element lies in the ring already,
    if     HasGeneratorsOfLeftOperatorRing( A )
       and a in GeneratorsOfLeftOperatorRing( A ) then
      return A;

    # otherwise make a new left operator ring
    else
      return FLMLOR( LeftActingDomain( A ),
                 Concatenation( GeneratorsOfLeftOperatorRing( A ), [ a ] ) );
    fi;
    end );

InstallMethod( ClosureLeftOperatorRing,
    "method for an FLMLOR with basis, and a ring element",
    IsCollsElms, [ IsFLMLOR and HasBasisOfDomain, IsRingElement ], 0,
    function( A, a )

    # if possible test if the element lies in the FLMLOR already,
    if (     HasGeneratorsOfLeftOperatorRing( A )
         and a in GeneratorsOfLeftOperatorRing( A ) )
       or a in A then
      return A;

    # otherwise make a new FLMLOR
    else
      return FLMLOR( LeftActingDomain( A ),
#T FLMLORByGenerators?
                 Concatenation( BasisVectors( BasisOfDomain( A ) ), [ a ] ),
                 "basis" );
    fi;
    end );

InstallMethod( ClosureLeftOperatorRing,
    "method for a unital FLMLOR and a ring element",
    IsCollsElms,
    [ IsUnitalFLMLOR, IsRingElement ], 0,
    function( A, a )

    # if possible test if the element lies in the ring already,
    if a in GeneratorsOfLeftOperatorUnitalRing( A ) then
      return A;

    # otherwise make a new left operator unital ring
    else
      return FLMLOR( LeftActingDomain( A ),
                 Concatenation( GeneratorsOfLeftOperatorUnitalRing( A ),
                                [ a ] ) );
    fi;
    end );

InstallMethod( ClosureLeftOperatorRing,
    "method for a unital FLMLOR with basis, and a ring element",
    IsCollsElms, [ IsUnitalFLMLOR and HasBasisOfDomain, IsRingElement ], 0,
    function( A, a )

    # if possible test if the element lies in the FLMLOR already,
    if (     HasGeneratorsOfLeftOperatorUnitalRing( A )
         and a in GeneratorsOfLeftOperatorUnitalRing( A ) )
       or a in A then
        return A;

    # otherwise make a new unital FLMLOR
    else
      return UnitalFLMLOR( LeftActingDomain( A ),
                 Concatenation( BasisVectors( BasisOfDomain( A ) ), [ a ] ),
                 "basis" );
    fi;
    end );

InstallMethod( ClosureLeftOperatorRing,
    "method for a FLMLOR containing the whole family, and a ring element",
    IsCollsElms, [ IsFLMLOR and IsWholeFamily, IsRingElement ], SUM_FLAGS,
    function( A, a )
    return A;
    end );


#############################################################################
##
#M  ClosureLeftOperatorRing( <A>, <U> ) .  closure of two left operator rings
##
InstallMethod( ClosureLeftOperatorRing,
    "method for two left operator rings",
    IsIdentical, [ IsLeftOperatorRing, IsLeftOperatorRing ], 0,
    function( A, S )
    local   g;          # one generator

    for g in GeneratorsOfLeftOperatorRing( S ) do
      A := ClosureLeftOperatorRing( A, g );
    od;
    return A;
    end );

InstallMethod( ClosureLeftOperatorRing,
    "method for two left operator unital rings",
    IsIdentical, [ IsLeftOperatorUnitalRing, IsLeftOperatorUnitalRing ], 0,
    function( A, S )
    local   g;          # one generator

    for g in GeneratorsOfLeftOperatorUnitalRing( S ) do
      A := ClosureLeftOperatorRing( A, g );
    od;
    return A;
    end );

InstallMethod( ClosureLeftOperatorRing,
    "method for a left op. ring cont. the whole family, and a collection",
    IsIdentical,
    [ IsLeftOperatorRing and IsWholeFamily, IsCollection ], SUM_FLAGS,
    function( A, S )
    return A;
    end );


#############################################################################
##
#F  MutableBasisOfClosureUnderAction( <F>, <Agens>, <gens>, <from>, <init>,
#F                                    <maxdim> )
##
##  A basis of an arbitrary finite dimensional algebra $A$ is computed as
##  follows.
##  (This is based on the possibility to deal with vector spaces generated
##  by elements of $A$.)
##
##  Let $A$ be a finite dimensional algebra over the field $F$,
##  with $S$ the set of generators of $A$.
##  (If $A$ contains a multiplicative identity this is counted as a
##  generator, that is, this identity is not regarded as word of length zero
##  in terms of the generators.)
##
##  Define $A_i = \{ a\in A; l(a) \leq i \}$ where $l(a)$ denotes the minimum
##  (taken over all representations of $a$ as sum of words in terms of $S$)
##  of the length of the longest involved word in terms of $S$.
##
##  In the general (nonassociative) case this means words with brackets.
##
##  Then $A_i$ is an $F$-space, and
##  $\{ Zero( A ) \} = A_0 \< A_1 \< A_2 \< \cdots A_k \< A_{k+1} \< \ldots$
##  is an ascending chain that eventually reaches $A$.
##  For $i > 0$ we have
##  $A_{i+1} = \langle A_i \cup \bigcup_{g\in S} ( A_i g \cup g A_i ) \rangle$
##  the closure as an $F$-space.
##
##  (For unital algebras we have to initialize $A_0 = \{ F \*\ A.one \}$,
##  here the recursion holds also for $i = 0$.)
##
##  If the algebra is (known to be) associative then we do not need to
##  multiply from both sides, that is,
##  $A_{i+1} = \langle A_i \cup \bigcup_{g\in S} A_i g \rangle$.
##
##  *Note* that the computation of the $A_i$ gives us the smallest value $k$
##  such that every element is a linear combination of words in terms of the
##  algebra generators, of maximal length $k$.
##
MutableBasisOfClosureUnderAction :=
    function( F, Agens, gens, from, init, maxdim )

    local MB,        # mutable basis, result
          gen,       # loop over generators
          v,         #
          dim,       # dimension of the actual left module
          right,     # 'true' if we have to multiply from the right
          left;      # 'true' if we have to multiply from the left

    # Get the side(s) from where to multiply.
    left  := true;
    right := true;
    if   from = "left" then
      right:= false;
    elif from = "right" then
      left:= false;
    fi;

    # $A_1$
    dim:= 0;
    MB:= MutableBasisByGenerators( F, init );
  
    while dim < Length( BasisVectors( MB ) ) and dim < maxdim do
  
      # 'MB' is a mutable basis of $A_i$.
      dim:= Length( BasisVectors( MB ) );

      if right then

        # Compute $\bigcup_{g \in S} ( A_i g \cup A_i g )$.
        for gen in Agens do
          for v in BasisVectors( MB ) do
            CloseMutableBasis( MB, v * gen );
          od;
        od;

      fi;
      if left then

        # Compute $\bigcup_{g \in S} ( A_i g \cup g A_i )$.
        for gen in Agens do
          for v in BasisVectors( MB ) do
            CloseMutableBasis( MB, gen * v );
          od;
        od;

      fi;
  
    od;
      
    # Return the mutable basis.
    return MB;

end;


#############################################################################
##
#M  \=( <A1>, <A2> ) . . . . . . . . . . . . . test if two algebras are equal
##
InstallMethod( \=,
    "method for two unital FLMLORs",
    IsIdentical, [ IsFLMLOR, IsFLMLOR ], 0,
    function( A1, A2 )
    local inters;
    if LeftActingDomain( A1 ) = LeftActingDomain( A2 ) then
      return   GeneratorsOfAlgebra( A1 ) = GeneratorsOfAlgebra( A2 )
        or (     ForAll( GeneratorsOfAlgebra( A1 ), gen -> gen in A2 )
             and ForAll( GeneratorsOfAlgebra( A2 ), gen -> gen in A1 ) );
    else
      inters:= Intersection2( LeftActingDomain( A1 ),
                              LeftActingDomain( A2 ) );
      return AsFLMLOR( inters, A1 ) = AsFLMLOR( inters, A2 );
    fi;
    end );


#############################################################################
##
#M  \=( <A1>, <A2> ) . . . . . . . . .  test if two unital algebras are equal
##
InstallMethod( \=,
    "method for two unital FLMLORs",
    IsIdentical, [ IsUnitalFLMLOR, IsUnitalFLMLOR ], 0,
    function( A1, A2 )
    local inters;
    if LeftActingDomain( A1 ) = LeftActingDomain( A2 ) then
      return   GeneratorsOfUnitalAlgebra( A1 ) = GeneratorsOfUnitalAlgebra( A2 )
        or (     ForAll( GeneratorsOfUnitalAlgebra( A1 ), gen -> gen in A2 )
             and ForAll( GeneratorsOfUnitalAlgebra( A2 ), gen -> gen in A1 ) );
    else
      inters:= Intersection2( LeftActingDomain( A1 ),
                              LeftActingDomain( A2 ) );
      return AsUnitalFLMLOR( inters, A1 ) = AsUnitalFLMLOR( inters, A2 );
    fi;
    end );


#############################################################################
##
#M  IsSubset( <G>, <H> )  . . . . . . . . . . . . test for subset of algebras
##
InstallMethod( IsSubset,
    "method for two FLMLORs",
    IsIdentical, [ IsFLMLOR, IsFLMLOR ], 0,
    function( D1, D2 )
    local inters;
    if LeftActingDomain( D1 ) = LeftActingDomain( D2 ) then
      return      GeneratorsOfLeftOperatorRing( D1 )
                = GeneratorsOfLeftOperatorRing( D2 )
             or ( Dimension( D2 ) <= Dimension( D1 )
                  and IsSubset( D1, GeneratorsOfAlgebra( D2 ) ) );
    else
      inters:= Intersection2( LeftActingDomain( D1 ), LeftActingDomain( D2 ) );
      return IsSubset( AsFLMLOR( inters, D1 ), AsFLMLOR( inters, D2 ) );
    fi;
    end );

InstallMethod( IsSubset,
    "method for two unital FLMLORs",
    IsIdentical, [ IsUnitalFLMLOR, IsUnitalFLMLOR ], 0,
    function( G, H )
    return     GeneratorsOfLeftOperatorUnitalRing( G )
             = GeneratorsOfLeftOperatorUnitalRing( H )
          or ( Dimension( H ) <= Dimension( G )
               and IsSubset( G, GeneratorsOfLeftOperatorUnitalRing( H ) ) );
    end );


#############################################################################
##
#M  IsLeftIdeal( <A>, <S> )
##
##  Check whether the subalgebra <S> is a left ideal in <A>,
##  i.e., whether <S> is contained in <A> and $a * i$ lies in <S>
##  for all basis vectors $a$ of <A> and $s$ of <S>.
##
##  For associative (unital) algebras, we need to check only the products of
##  (unital) algebra generators.
##
IsLeftIdealFromGenerators :=
    function( AsStructA, AsStructS, GeneratorsA, GeneratorsS )
    return function( A, S )

    local inter,   # intersection of left acting domains
          gensS,   # suitable generators of 'S'
          a,       # loop over suitable generators of 'A'
          i;       # loop over 'gensS'

    if not IsSubset( A, S ) then
      return false;
    elif LeftActingDomain( A ) <> LeftActingDomain( S ) then
      inter:= Intersection2( LeftActingDomain( A ), LeftActingDomain( S ) );
      return IsLeftIdeal( AsStructA( inter, A ), AsStructS( inter, S ) );
    fi;

    gensS:= GeneratorsS( S );
    for a in GeneratorsA( A ) do
      for i in gensS do
        if not a * i in S then
          return false;
        fi;
      od;
    od;
    return true;
    end;
end;

InstallOtherMethod( IsLeftIdeal,
    "method for FLMLOR and free left module",
    IsIdentical,
    [ IsFLMLOR, IsFreeLeftModule ], 0,
    IsLeftIdealFromGenerators( AsFLMLOR, AsLeftModule,
                               GeneratorsOfLeftModule,
                               GeneratorsOfLeftModule ) );

InstallOtherMethod( IsLeftIdeal,
    "method for associative FLMLOR and free left module",
    IsIdentical,
    [ IsFLMLOR and IsAssociative, IsFreeLeftModule ], 0,
    IsLeftIdealFromGenerators( AsFLMLOR, AsLeftModule,
                               GeneratorsOfLeftOperatorRing,
                               GeneratorsOfLeftModule ) );

InstallOtherMethod( IsLeftIdeal,
    "method for associative unital FLMLOR and free left module",
    IsIdentical,
    [ IsUnitalFLMLOR and IsAssociative, IsFreeLeftModule ], 0,
    IsLeftIdealFromGenerators( AsFLMLOR, AsLeftModule,
                               GeneratorsOfLeftOperatorUnitalRing,
                               GeneratorsOfLeftModule ) );

InstallMethod( IsLeftIdeal,
    "method for associative FLMLOR and FLMLOR",
    IsIdentical,
    [ IsFLMLOR and IsAssociative, IsFLMLOR ], 0,
    IsLeftIdealFromGenerators( AsFLMLOR, AsFLMLOR,
                               GeneratorsOfLeftOperatorRing,
                               GeneratorsOfLeftOperatorRing ) );


#############################################################################
##
#M  IsRightIdeal( <A>, <S> )
##
##  Check whether the subalgebra <S> is a right ideal in <A>,
##  i.e., whether <S> is contained in <A> and $s * a$ lies in <S>
##  for all basis vectors $a$ of <A> and $s$ of <S>.
##
##  For associative (unital) algebras, we need to check only the products of
##  (unital) algebra generators.
##
IsRightIdealFromGenerators :=
    function( AsStructA, AsStructS, GeneratorsA, GeneratorsS )
    return function( A, S )

    local inter,   # intersection of left acting domains
          gensS,   # suitable generators of 'S'
          a,       # loop over suitable generators of 'A'
          i;       # loop over 'gensS'

    if not IsSubset( A, S ) then
      return false;
    elif LeftActingDomain( A ) <> LeftActingDomain( S ) then
      inter:= Intersection2( LeftActingDomain( A ), LeftActingDomain( S ) );
      return IsRightIdeal( AsStructA( inter, A ), AsStructS( inter, S ) );
    fi;

    gensS:= GeneratorsS( S );
    for a in GeneratorsA( A ) do
      for i in gensS do
        if not i * a in S then
          return false;
        fi;
      od;
    od;
    return true;
    end;
end;

InstallOtherMethod( IsRightIdeal,
    "method for FLMLOR and free left module",
    IsIdentical,
    [ IsFLMLOR, IsFreeLeftModule ], 0,
    IsRightIdealFromGenerators( AsFLMLOR, AsLeftModule,
                                GeneratorsOfLeftModule,
                                GeneratorsOfLeftModule ) );

InstallOtherMethod( IsRightIdeal,
    "method for associative FLMLOR and free left module",
    IsIdentical,
    [ IsFLMLOR and IsAssociative, IsFreeLeftModule ], 0,
    IsRightIdealFromGenerators( AsFLMLOR, AsLeftModule,
                                GeneratorsOfLeftOperatorRing,
                                GeneratorsOfLeftModule ) );

InstallOtherMethod( IsRightIdeal,
    "method for associative unital FLMLOR and free left module",
    IsIdentical,
    [ IsUnitalFLMLOR and IsAssociative, IsFreeLeftModule ], 0,
    IsRightIdealFromGenerators( AsFLMLOR, AsLeftModule,
                                GeneratorsOfLeftOperatorUnitalRing,
                                GeneratorsOfLeftModule ) );

InstallMethod( IsRightIdeal,
    "method for associative FLMLOR and FLMLOR",
    IsIdentical,
    [ IsFLMLOR and IsAssociative, IsFLMLOR ], 0,
    IsRightIdealFromGenerators( AsFLMLOR, AsFLMLOR,
                                GeneratorsOfLeftOperatorRing,
                                GeneratorsOfLeftOperatorRing ) );


#############################################################################
##
#M  IsIdeal( <A>, <S> )
##
##  Check whether the subspace or subalgebra $S$ is an ideal in $A$,
##  i.e., whether $a s \in S$ and $s a \in S$
##  for all basis vectors $a$ of $A$ and $s$ of $S$.
##
InstallOtherMethod( IsIdeal,
    "method for commutative FLMLOR and free left module",
    IsIdentical,
    [ IsFLMLOR and IsCommutative, IsFreeLeftModule ], 0,
    IsLeftIdeal );

InstallOtherMethod( IsIdeal,
    "method for anti-commutative FLMLOR and free left module",
    IsIdentical,
    [ IsFLMLOR and IsAnticommutative, IsFreeLeftModule ], 0,
    IsLeftIdeal );

InstallOtherMethod( IsIdeal,
    "method for FLMLOR and free left module",
    IsIdentical,
    [ IsFLMLOR, IsFreeLeftModule ], 0,
    function( A, S )
    return IsLeftIdeal( A, S ) and IsRightIdeal( A, S );
#T Check containment only once!
    end );


#############################################################################
##
#M  PrintObj( <A> ) . . . . . . . . . . . . . . . . . pretty print an algebra
##
##  print left acting domain, if known also dimension or no. of generators
##
InstallMethod( PrintObj, true,
    [ IsAlgebra and HasDimension ], 0,
    function( A )
    Print( "<algebra of dimension ", Dimension( A ),
           " over ", LeftActingDomain( A ), ">" );
    end );

InstallMethod( PrintObj, true,
    [ IsAlgebra and HasGeneratorsOfAlgebra ], 0,
    function( A )
    Print( "<algebra over ", LeftActingDomain( A ), ", with ",
           Length( GeneratorsOfAlgebra( A ) ), " generators>" );
    end );

InstallMethod( PrintObj, true,
    [ IsAlgebra ], 0,
    function( A )
    Print( "<algebra over ", LeftActingDomain( A ), ">" );
    end );


#############################################################################
##
#M  PrintObj( <A> ) . . . . . . . . . . . . . . pretty print a unital algebra
##
##  print left acting domain, if known also dimension or no. of generators
##
InstallMethod( PrintObj, true,
    [ IsUnitalAlgebra and HasDimension ], 0,
    function( A )
    Print( "<unital algebra of dimension ", Dimension( A ),
           " over ", LeftActingDomain( A ), ">" );
    end );

InstallMethod( PrintObj, true,
    [ IsUnitalAlgebra and HasGeneratorsOfUnitalAlgebra ], 0,
    function( A )
    Print( "<unital algebra over ", LeftActingDomain( A ), ", with ",
           Length( GeneratorsOfUnitalAlgebra( A ) ), " generators>" );
    end );

InstallMethod( PrintObj, true,
    [ IsUnitalAlgebra ], 0,
    function( A )
    Print( "<unital algebra over ", LeftActingDomain( A ), ">" );
    end );


#############################################################################
##
#M  PrintObj( <A> ) . . . . . . . . . . . . . . .  pretty print a Lie algebra
##
##  print left acting domain, if known also dimension or no. of generators
##
InstallMethod( PrintObj, true,
    [ IsLieAlgebra and HasDimension ], 0,
    function( A )
    Print( "<Lie algebra of dimension ", Dimension( A ),
           " over ", LeftActingDomain( A ), ">" );
    end );

InstallMethod( PrintObj, true,
    [ IsLieAlgebra and HasGeneratorsOfAlgebra ], 0,
    function( A )
    Print( "<Lie algebra over ", LeftActingDomain( A ), ", with ",
           Length( GeneratorsOfAlgebra( A ) ), " generators>" );
    end );

InstallMethod( PrintObj, true,
    [ IsLieAlgebra ], 0,
    function( A )
    Print( "<Lie algebra over ", LeftActingDomain( A ), ">" );
    end );


#############################################################################
##
#M  AsSubalgebra(<A>, <U>) . view an algebra as subalgebra of another algebra
##
InstallMethod( AsSubalgebra,
    "method for two algebras",
    IsIdentical, [ IsAlgebra, IsAlgebra ], 0,
    function( A, U )
    local S;
    if not IsSubset( A, U ) then
      Error( "<U> must be a subset of <A>" );
    fi;

    # Construct the generators list.
    if LeftActingDomain( A ) <> LeftActingDomain( U ) then
      U:= AsAlgebra( LeftActingDomain( A ), U );
    fi;

    # Construct the subalgebra.
    S:= SubalgebraNC( A, GeneratorsOfAlgebra( U ) );

    RunIsomorphismImplications( U, S );
    RunSubsetImplications( U, S );

    # Return the subalgebra.
    return S;
    end );

InstallMethod( AsSubalgebra,
    "method for an algebra and a unital algebra",
    IsIdentical, [ IsAlgebra, IsUnitalAlgebra ], 0,
    function( A, U )
    local S;
    if not IsSubset( A, U ) then
      Error( "<U> must be a subset of <A>" );
    fi;

    # Construct the generators list.
    if LeftActingDomain( A ) <> LeftActingDomain( U ) then
      U:= AsUnitalAlgebra( LeftActingDomain( A ), U );
    fi;

    # Construct and return the subalgebra.
    S:= UnitalSubalgebraNC( A, GeneratorsOfUnitalAlgebra( U ) );
    RunIsomorphismImplications( U, S );
    RunSubsetImplications( U, S );
    return S;
    end );


#############################################################################
##
#M  AsUnitalSubalgebra(<A>, <U>) . . .  view algebra as subalgebra of another
##
InstallMethod( AsUnitalSubalgebra,
    "method for two algebras",
    IsIdentical, [ IsAlgebra, IsAlgebra ], 0,
    function( A, U )
    local S;
    if not IsSubset( A, U ) then
      Error( "<U> must be a subset of <A>" );
    elif One( U ) = fail then
      Error( "<U> does not contain an identity element" );
    fi;

    if LeftActingDomain( A ) <> LeftActingDomain( U ) then
      U:= AsUnitalAlgebra( LeftActingDomain( A ), U );
    fi;

    # Construct and return the subalgebra.
    S:= UnitalSubalgebraNC( A, GeneratorsOfAlgebra( U ) );
    RunIsomorphismImplications( U, S );
    RunSubsetImplications( U, S );
    return S;
    end );

InstallMethod( AsUnitalSubalgebra,
    "method for an algebra and a unital algebra",
    IsIdentical, [ IsAlgebra, IsUnitalAlgebra ], 0,
    function( A, U )
    local S;
    if not IsSubset( A, U ) then
      Error( "<U> must be a subset of <A>" );
    fi;

    if LeftActingDomain( A ) <> LeftActingDomain( U ) then
      U:= AsUnitalAlgebra( LeftActingDomain( A ), U );
    fi;

    # Construct and return the subalgebra.
    S:= UnitalSubalgebraNC( A, GeneratorsOfUnitalAlgebra( U ) );
    RunIsomorphismImplications( U, S );
    RunSubsetImplications( U, S );
    return S;
    end );


#############################################################################
##
#M  Centralizer( <A>, <S> )
##
##  is the centralizer of <S> in the algebra <A>, that is, the set
##  $\{ a \in A; a s = s a \forall s \in S \}$.
##  Here <S> may be a subspace or a subalgebra of <A>.
##
##  Let $(b_1, \ldots, b_n)$ be a basis of <A>, and $(s_1, \ldots, s_m)$
##  be a basis of <S>, with $s_j = \sum_{l=1}^m v_{lj} b_l$.
##  The structure constants of <A> are $c_{ijk}$ with
##  $b_i b_j = \sum_{k=1}^n c_{ijk} b_k$.
##  Then we compute a basis of the solution space of the system
##  $\sum_{i=1}^n a_i \sum_{l=1}^m v_{lj} ( c_{ilk} - c_{lik} )$ for
##  $1 \leq j \leq m$ and $1 \leq k \leq n$.
##
##  (left null space of an $n \times (nm)$ matrix)
##
##  The antisymmetry of the multiplication is used if it is known to <A>.
##
InstallMethod( Centralizer,
    "method for a finite dimensional algebra and a vector space",
    IsIdentical, [ IsAlgebra, IsVectorSpace ], 0,
    function( A, S )

    local B,           # basis of 'A'
          T,           # structure constants table w. r. to 'B'
          n,           # dimension of 'A'
          m,           # dimension of 'S'
          M,           # matrix of the equation system
          v,           # coefficients of basis vectors of 'S' w.r. to 'B'
          zerovector,  # initialize one row of 'M'
          row,         # one row of 'M'
          i, j, k, l,  # loop variables
          cil, cli,    #
          offset,
          pos;

    if not IsFiniteDimensional( A ) then
      TryNextMethod();
    fi;

    B:= BasisOfDomain( A );
    T:= StructureConstantsTable( B );
    n:= Dimension( A );
    m:= Dimension( S );
    M:= [];
    v:= List( BasisVectors( BasisOfDomain( S ) ),
              x -> Coefficients( B, x ) );

    zerovector:= [ 1 .. n*m ] * Zero( LeftActingDomain( A ) );

    if HasIsAnticommutative( A ) and IsAnticommutative( A ) then
#T different methods?

      # Column $(j-1)*n + k$ contains in row $i$ the value
      # $\sum_{l=1}^m v_{lj} c_{ilk}$
  
      for i in [ 1 .. n ] do
        row:= ShallowCopy( zerovector );
        for l in [ 1 .. n ] do
          cil:= T[i][l];
          cli:= T[l][i];
          for j in [ 1 .. n ] do
            offset:= (j-1)*n;
            for k in [ 1 .. Length( cil[1] ) ] do
              pos:= cil[1][k] + offset;
              row[ pos ]:= row[ pos ] + cil[2][k];
            od;
          od;
        od;
        Add( M, row );
      od;

    else

      # Column $(j-1)*n + k$ contains in row $i$ the value
      # $\sum_{l=1}^m v_{lj} ( c_{ilk} - c_{lik} )$
  
      for i in [ 1 .. n ] do
        row:= ShallowCopy( zerovector );
        for l in [ 1 .. n ] do
          cil:= T[i][l];
          cli:= T[l][i];
          for j in [ 1 .. n ] do
            offset:= (j-1)*n;
            for k in [ 1 .. Length( cil[1] ) ] do
              pos:= cil[1][k] + offset;
              row[ pos ]:= row[ pos ] + cil[2][k];
            od;
            for k in [ 1 .. Length( cli[1] ) ] do
              pos:= cli[1][k] + offset;
              row[ pos ]:= row[ pos ] - cli[2][k];
            od;
          od;
        od;
        Add( M, row );
      od;

    fi;

    # Solve the equation system.
    M:= NullspaceMat( M );

    # Construct the generators from the coefficient vectors.
    M:= List( M, x -> LinearCombination( B, x ) );

    # Return the subalgebra.
    if IsUnitalFLMLOR( A ) then
      return UnitalSubalgebraNC( A, M, "basis" );
    else
      return SubalgebraNC( A, M, "basis" );
    fi;
    end );


#############################################################################
##
#M  Centre( <A> )
##
##  We have to solve the system
##  $\sum_{i=1}^n a_i ( c_{ijk} - c_{jik} ) = 0$ for $1 \leq j, k \leq n$.
##
InstallMethod( Centre,
    "method for a finite dimensional FLMLOR",
    true, [ IsFLMLOR ], 0,
    function( A )

    local   C,        # centre of 'A', result
            B,        # a basis of 'A'
            T,        # structure constants table w.r. to 'B'
            n,        # dimension of 'A'
            M,        # matrix of the equation system
            i, j, k,  # loop over ...
            row,      # one row of 'M'
            pos,      # nonzero positions in $c_{ij}$
            val,      # loop over structure constants in $c_{ij}$
            offset;

    if not IsFiniteDimensional( A ) then
      TryNextMethod();
    fi;

    # If necessary convert 'A' to a FLMLOR over a commutative ring.
    if not IsCommutative( LeftActingDomain( A ) ) then
      A:= AsFLMLOR( Centre( LeftActingDomain( A ) ), A );
    fi;

    # Construct the equation system.
    B:= BasisOfDomain( A );
    T:= StructureConstantsTable( B );
    n:= Dimension( A );
    M:= NullMat( n, n*n, LeftActingDomain( A ) );
    for i in [ 1 .. n ] do
      row:= M[i];
      for j in [ 1 .. n ] do

        offset:= (j-1)*n;
        row{ offset + T[i][j][1] }:= T[i][j][2];
        pos:= T[j][i][1];
        val:= T[j][i][2];
        for k in [ 1 .. Length( pos ) ] do
          row[ offset + pos[k] ]:= row[ offset + pos[k] ] - val[k];
#T cheaper!
        od;

      od;
    od;

    # Solve the equation system.
    M:= NullspaceMat( M );

    # Construct the generators from the coefficient vectors.
    M:= List( M, x -> LinearCombination( B, x ) );

    # Construct the centre.
    C:= SubalgebraNC( A, M, "basis" );

    # Return the centre.
    return C;
    end );


##############################################################################
##
#M  ProductSpace( <U>, <V> )
##
MutableBasisOfProductSpace := function( U, V )

    local inter, # intersection of left acting domains
          u, v,  # loop over the bases
          prod,  # product function
          MB;    # mutable basis of the commutator subspace, result

    if LeftActingDomain( U ) = LeftActingDomain( V ) then
      inter:= LeftActingDomain( U );
    else
      inter:= Intersection2( LeftActingDomain( U ), LeftActingDomain( V ) );
      U:= AsVectorSpace( inter, U );
      V:= AsVectorSpace( inter, V );
    fi;

    MB:= MutableBasisByGenerators( inter, [], Zero( U ) );
    V:= BasisVectors( BasisOfDomain( V ) );
    for u in BasisVectors( BasisOfDomain( U ) ) do
      for v in V do
        CloseMutableBasis( MB, u * v );
      od;
    od;

    # Return the result.
    return [ MB, inter ];
end;

InstallMethod( ProductSpace,
    "method for two free left modules",
    IsIdentical,
    [ IsFreeLeftModule, IsFreeLeftModule ], 0,
    function( U, V )
    local MB, C;

    # Compute basis vectors.
    MB:= MutableBasisOfProductSpace( U, V );

    # Create the appropriate domain.
    if HasParent( U ) and HasParent( V )
                      and IsIdentical( Parent( U ), Parent( V ) ) then
      C:= SubmoduleNC( Parent( U ), BasisVectors( MB[1] ) );
    else
      C:= FreeLeftModule( MB[2], BasisVectors( MB[1] ) );
    fi;

    # Insert the basis.
    SetBasisOfDomain( C, ImmutableBasis( MB[1] ) );

    # Return the result.
    return C;
    end );

InstallMethod( ProductSpace,
    "method for two algebras",
    IsIdentical,
    [ IsAlgebra, IsAlgebra ], 0,
    function( U, V )
    local MB, C;

    if not IsIdentical( U, V ) then
      TryNextMethod();
    fi;

    # Compute basis vectors for the result.
    MB:= MutableBasisOfProductSpace( U, V )[1];

    # The result is an algebra in 'U'.
    C:= SubalgebraNC( U, BasisVectors( MB ) );
    SetBasisOfDomain( C, ImmutableBasis( MB ) );

    # Return the result.
    return C;
    end );

InstallMethod( ProductSpace,
    "method for two ideals with same parent",
    IsIdentical,
    [ IsAlgebra and HasParent and IsIdealInParent,
      IsAlgebra and HasParent and IsIdealInParent ], 0,
    function( U, V )
    local MB, C;

    if not IsIdentical( Parent( U ), Parent( V ) ) then
      TryNextMethod();
    fi;

    MB:= MutableBasisOfProductSpace( U, V )[1];
    C:= SubalgebraNC( Parent( U ), BasisVectors( MB ) );

    SetIsIdealInParent( C, true ); 
    SetBasisOfDomain( C, ImmutableBasis( MB ) );

    return C;
    end );


#############################################################################
##
#M  RadicalOfAlgebra( <A> ) . . . . . . . . radical of an associative algebra
##
##  'RadicalOfAlgebra' computes the radical (intersection of maximal ideals)
##  of an associative algebra <A> by first constructing a faithful
##  matrix representation.
##  (Note that there is a special implementation for associative matrix
##  algebras.)
##
##  If <A> contains an identity element then the adjoint representation is
##  already faithful.
##
##  Otherwise we add an identity element (Dorroh extension).
##  More precisely we consider the space $B = \{ (x,t) | x\in A, t\in F }$.
##  We let <A> act on this space via $a (x,t) = (ax+ta,0)$.
##  Then it is easily seen that this representation is faithful.
##
InstallMethod( RadicalOfAlgebra,
    "method for an associative algebra",
    true,
    [ IsAlgebra ], 0,
    function( A )

    local bb,    # list of matrices representing the basis elements of <A>
          n,     # dimension of <A>
          BA,    # basis of 'A'
          bv,    # basis vectors of 'BA'
          F,     # left acting domain of 'A'
          M,     # (n+1) x (n+1) matrix
          i,j,   # loop variables
          col,   # a column of 'M'
          B,     # the representation of <A>
          R,     # the radical of 'B'
          bas,   # a basis of 'B' (corresponding to the basis of <A>)
          rad;   # a basis of the radical of <A>

    if not IsAssociative( A ) then
      TryNextMethod();
    fi;

    n:= Dimension( A );
    BA:= BasisOfDomain( A );
    bv:= BasisVectors( BA );
    F:= LeftActingDomain( A );

    if One( A ) <> fail then

      bb:= List( bv, x -> AdjointMatrix( BA, x ) );

    else

      bb:= [];

      for i in [1..n] do
        M:=[];
        for j in [1..n] do
          col:= Coefficients( BA, bv[i] * bv[j] );
          col[n+1]:= Zero( F );
          Add( M, col );
        od;
        col:= [ 1 .. n+1 ] * Zero( F );
        col[i]:= One( F );
        Add( M, col );
        Add( bb, M );
      od; 

    fi;

    # Compute the radical of the isomorphic matrix algebra.
    B:= Algebra( F, bb, "basis" );
    R:= RadicalOfAlgebra( B );

    # Transfer the radical back to the original algebra.
    bas:= BasisOfDomain( B, bb, true );
    rad:= List( BasisVectors( BasisOfDomain( R ) ),
                x -> Coefficients( bas, x ) * bv );

    return SubalgebraNC( A, rad, "basis" );
    end );


#############################################################################
##
#M  IsTrivial( <A> )  . . . . . . . . . . . . . . . . . . . . .  for a FLMLOR
##
InstallMethod( IsTrivial,
    "method for a FLMLOR",
    true,
    [ IsFLMLOR ], 0,
    A -> ForAll( GeneratorsOfLeftOperatorRing( A ), IsZero ) );


#############################################################################
##
#M  IsTrivial( <A> )  . . . . . . . . . . . . . . . . . . for a unital FLMLOR
##
InstallMethod( IsTrivial,
    "method for a unital FLMLOR",
    true,
    [ IsUnitalFLMLOR ], 0,
    ReturnFalse );


#############################################################################
##
#M  GeneratorsOfVectorSpace( <A> )
##
##  We assume that it is possible to construct a basis for an algebra.
##
InstallMethod( GeneratorsOfVectorSpace,
    "method for a FLMLOR",
    true,
    [ IsFLMLOR ], 0,
    A -> BasisVectors( BasisOfDomain( A ) ) );


#############################################################################
##
#M  IdealByGenerators( <A>, <gens> ) . . . . .  create an ideal in an algebra
##
##  We need special methods to make ideals in algebras themselves algebras.
##
InstallMethod( IdealByGenerators,
    "method for FLMLOR and collection",
    IsIdentical,
    [ IsFLMLOR, IsCollection ], 0,
    function( A, gens )
    local I;
    I:= Objectify( NewKind( FamilyObj( A ),
                                IsFLMLOR
                            and IsIdealInParent
                            and IsAttributeStoringRep ),
                   rec() );
    SetLeftActingDomain( I, LeftActingDomain( A ) );
    SetGeneratorsOfIdeal( I, gens );
    SetParent( I, A );
    return I;
    end );


#############################################################################
##
#M  LeftIdealByGenerators( <A>, <gens> ) .  create a left ideal in an algebra
##
InstallMethod( LeftIdealByGenerators,
    "method for FLMLOR and collection",
    IsIdentical,
    [ IsFLMLOR, IsCollection ], 0,
    function( A, gens )
    local I;
    I:= Objectify( NewKind( FamilyObj( A ),
                                IsFLMLOR
                            and IsLeftIdealInParent
                            and IsAttributeStoringRep ),
                   rec() );
    SetLeftActingDomain( I, LeftActingDomain( A ) );
    SetGeneratorsOfLeftIdeal( I, gens );
    SetParent( I, A );
    return I;
    end );


#############################################################################
##
#M  RightIdealByGenerators( <A>, <gens> )  . create right ideal in an algebra
##
InstallMethod( RightIdealByGenerators,
    "method for FLMLOR and collection",
    IsIdentical,
    [ IsFLMLOR, IsCollection ], 0,
    function( A, gens )
    local I;
    I:= Objectify( NewKind( FamilyObj( A ),
                                IsFLMLOR
                            and IsRightIdealInParent
                            and IsAttributeStoringRep ),
                   rec() );
    SetLeftActingDomain( I, LeftActingDomain( A ) );
    SetGeneratorsOfRightIdeal( I, gens );
    SetParent( I, A );
    return I;
    end );


#############################################################################
##
#M  DerivedSubalgebra( <L> )  . . . . . . . . . . . . . . . for a Lie algebra
##
##  is the derived subalgebra of the Lie algebra <L>,
##  this is the algebra generated by all products $[ u, v ]$
##  where $u$ and $v$ range over a basis of <L>.
##
InstallMethod( DerivedSubalgebra,
    "method for a Lie algebra",
    true,
    [ IsLieAlgebra ], 0,
    L -> ProductSpace( L, L ) );


#############################################################################
##
#M  DerivedSeriesOfAlgebra( <L> )   . . . . . . . . . . . . for a Lie algebra
##
InstallOtherMethod( DerivedSeriesOfAlgebra,
    "method for a Lie algebra",
    true,
    [ IsLieAlgebra ], 0,
    function ( L )

    local   S,          # derived series of <L>, result
            D;          # derived subalgebras

    # Compute the series by repeated calling of 'DerivedSubalgebra'.
    S := [ L ];
    D := DerivedSubalgebra( L );
    while D <> S[ Length(S) ]  do
      Add( S, D );
      D:= DerivedSubalgebra( D );
    od;

    # Return the series when it becomes stable.
    return S;
    end );


#############################################################################
##
#M  GeneratorsOfLeftOperatorRing( <A> ) . . . . . . . . . for a unital FLMLOR
##
InstallMethod( GeneratorsOfLeftOperatorRing,
    "method for a unital FLMLOR",
    true, [ IsUnitalFLMLOR ], 0,
    A -> Set( Concatenation( [ One( A ) ],
                             GeneratorsOfLeftOperatorUnitalRing( A ) ) ) );


#############################################################################
##
#M  GeneratorsOfLeftOperatorRing( <A> ) . . . .  for FLMLOR with module gens.
##
InstallMethod( GeneratorsOfLeftOperatorRing,
    "method for a FLMLOR with known left module generators",
    true, [ IsFLMLOR and HasGeneratorsOfLeftModule ], 0,
    A -> GeneratorsOfLeftModule( A ) );


#############################################################################
##
#M  GeneratorsOfLeftOperatorUnitalRing( <A> ) .  for FLMLOR with module gens.
##
InstallMethod( GeneratorsOfLeftOperatorUnitalRing,
    "method for a unital FLMLOR with known left module generators",
    true, [ IsUnitalFLMLOR and HasGeneratorsOfLeftModule ], 0,
    A -> GeneratorsOfLeftModule( A ) );


#############################################################################
##
#M  DirectSumOfAlgebras( <A1>, <A2> )
##
##  Construct a s.c. algebra.
##  (There are special methods for the sum of appropriate matrix algebras.)
##
#T embeddings/projections should be provided!
##
InstallOtherMethod( DirectSumOfAlgebras,
    "method for two algebras",
    true, [ IsAlgebra, IsAlgebra ], 0,
    function( A1, A2 )

    local n,    # The dimension of the resulting algebra.
          i,j,  # Loop variables.
          T,    # The table of structure constants of the direct sum.
          scT,  #
          n1,   # The dimension of A1.
          n2,   # The dimension of A2.
          ll,   # A list of structure constants.
          L;    # result

    if LeftActingDomain( A1 ) <> LeftActingDomain( A2 ) then
      Error( "<A1> and <A2> must be written over the same field" );
    fi;

    n1:= Dimension( A1 );
    n2:= Dimension( A2 );
    n:= n1+n2;
    T:= [];

    # Initialize the s.c. table.
    T:= EmptySCTable( n, Zero( LeftActingDomain( A1 ) ) );

    # Enter the structure constants for the first algebra.
    scT:= StructureConstantsTable( BasisOfDomain( A1 ) );
    T{ [ 1 .. n1 ] }{ [ 1 .. n1 ] }:= scT{ [ 1 .. n1 ] };

    scT:= StructureConstantsTable( BasisOfDomain( A2 ) );
    for i in [1..n2] do
      for j in [1..n2] do
        ll:= ShallowCopy( scT[i][j] );
        ll[1]:= ll[1] + n1;
        T[n1+i][n1+j]:= ll;
      od;
    od;

    L:= AlgebraByStructureConstants( LeftActingDomain( A1 ), T );

    # Maintain useful information.
    if     HasIsLieAlgebra( A1 ) and HasIsLieAlgebra( A2 )
       and IsLieAlgebra( A1 ) and IsLieAlgebra( A2 ) then
      SetIsLieAlgebra( L, true );
    fi;
    if     HasIsAssociative( A1 ) and HasIsAssociative( A2 )
       and IsAssociative( A1 ) and IsAssociative( A2 ) then
      SetIsAssociative( L, true );
    fi;

    # Return the result.
    return L;
    end );


#############################################################################
##
#M  DirectSumOfAlgebras( <list> )
##
InstallMethod( DirectSumOfAlgebras,
    "method for list of algebras",
    true,
    [ IsDenseList ], 0,
    function( list )

    local R, A, i;

    if IsEmpty( list ) then
      Error( "<list> must be nonempty" );
    fi;

    R:= LeftActingDomain( list[1] );
    for A in list do
      if not IsFLMLOR( A ) or LeftActingDomain( A ) <> R then
        Error( "all entries in <list> must be FLMLORs over <R>" );
      fi;
    od;

    A:= list[1];
    for i in [ 2 .. Length( list ) ] do
      A:= DirectSumOfAlgebras( A, list[i] );
    od;

    return A;
    end );


#############################################################################
##
#O  IsCentral( <A>, <U> )  . . . . . . . .  test if <U> is centralized by <A>
##
##  Check whether every basis vector of <A> commutes with every basis vector
##  of the subset <U>.
##
##  For associative algebras, we have to check $u a = a u$ only for algebra
##  generators $a$ and $u$ of $A$ and $U$, respectively,
##  not for all vectors of a basis.
##
InstallMethod( IsCentral,
    "method for two FLMLORs",
    IsIdentical,
    [ IsFLMLOR, IsFLMLOR ], 0,
    IsCentralFromGenerators( GeneratorsOfLeftModule,
                             GeneratorsOfLeftModule ) );

InstallMethod( IsCentral,
    "method for two associative FLMLORs",
    IsIdentical,
    [ IsFLMLOR and IsAssociative, IsFLMLOR and IsAssociative ], 0,
    IsCentralFromGenerators( GeneratorsOfAlgebra,
                             GeneratorsOfAlgebra ) );

InstallMethod( IsCentral,
    "method for two associative unital FLMLORs",
    IsIdentical,
    [ IsUnitalFLMLOR and IsAssociative,
      IsUnitalFLMLOR and IsAssociative ], 0,
    IsCentralFromGenerators( GeneratorsOfUnitalAlgebra,
                             GeneratorsOfUnitalAlgebra ) );


#T #############################################################################
#T ##
#T #F  FreeAlgebra( <R>, <rank> ) . . . . . . . . . . free algebra of given rank
#T #F  FreeAlgebra( <R>, <rank>, <name> )
#T #F  FreeAlgebra( <R>, <name1>, <name2>, ... )
#T ##
#T ##  is a (nonassociative) free algebra of rank <rank>.
#T ##
#T FreeAlgebra := function( arg )
#T     Error( "sorry, nonassociative free algebras are not yet supported" );
#T end;


#############################################################################
##
#F  FreeAssociativeAlgebra( <R>, <rank> )
#F  FreeAssociativeAlgebra( <R>, <rank>, <name> )
#F  FreeAssociativeAlgebra( <R>, <name1>, <name2>, ... )
##
FreeAssociativeAlgebra := function( arg )

    local   R,          # coefficients ring
            names;      # names of the algebra generators

    # Check the argument list.
    if Length( arg ) = 0 or not IsRing( arg[1] ) then
      Error( "first argument must be a ring" );
    fi;

    R:= arg[1];

    # Construct names of generators.
    if   Length( arg ) = 2 and IsInt( arg[2] ) then
      names:= List( [ 1 .. arg[2] ],
                    i -> Concatenation( "a.", String(i) ) );
    elif     Length( arg ) = 2
         and IsList( arg[2] )
         and ForAll( arg[2], IsString ) then
      names:= arg[2];
    elif Length( arg ) = 3 and IsInt( arg[2] ) and IsString( arg[3] ) then
      names:= List( [ 1 .. arg[2] ],
                    x -> Concatenation( arg[3], ".", String(x) ) );
    elif ForAll( [ 2 .. Length( arg ) ], IsString ) then
      names:= arg{ [ 2 .. Length( arg ) ] };
    else
      Error( "usage: FreeAssociativeAlgebra( <R>, <rank> )\n",
                 "or FreeAssociativeAlgebra( <R>, <name1>, ... )" );
    fi;

    # Construct the algebra as free magma algebra of a free monoid over 'R'.
    return FreeMagmaRing( R, FreeMonoid( names ) );
end;


#############################################################################
##
#E  algebra.gi  . . . . . . . . . . . . . . . . . . . . . . . . . . ends here



