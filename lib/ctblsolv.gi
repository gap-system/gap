#############################################################################
##
#W  ctblsolv.gi                 GAP library                Hans Ulrich Besche
#W                                                              Thomas Breuer
##
#H  @(#)$Id$
##
#Y  Copyright (C)  1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
##  This file contains character table methods for solvable groups.
##
Revision.ctblsolv_gi :=
    "@(#)$Id$";


#############################################################################
##
#M  CharacterDegreesOp( <G>, <p> )  . . . . . . . . . .  for an abelian group
##
InstallMethod( CharacterDegreesOp,
    "method for an abelian group, and an integer",
    true,
    [ IsGroup and IsAbelian, IsInt ], 0,
    function( G, p )
    G:= Size( G );
    if p <> 0 then
      while G mod p = 0 do
        G:= G / p;
      od;
    fi;
    return [ [ 1, G ] ];
    end );


#############################################################################
##
#F  AppendCollectedList( <list1>, <list2> )
##
AppendCollectedList := function( list1, list2 )
    local pair1, pair2, toadd;
    for pair2 in list2 do
      toadd:= true;
      for pair1 in list1 do
        if pair1[1] = pair2[1] then
          pair1[2]:= pair1[2] + pair2[2];
          toadd:= false;
          break;
        fi;
      od;
      if toadd then
        AddSet( list1, pair2 );
      fi;
    od;
end;


#############################################################################
##
#F  KernelUnderDualAction( <N>, <Npcgs>, <v> )  . . . . . . .  local function
##
##  <Npcgs> is a PCGS of an elementary abelian group <N>.
##  <v> is a vector in the dual space of <N>, w.r.t. <Npcgs>.
##  The kernel of <v> is returned.
##
KernelUnderDualAction := function( N, Npcgs, v )

    local gens, # generators list
          i, j;

    gens:= [];
    for i in Reversed( [ 1 .. Length( v ) ] ) do
      if IsZero( v[i] ) then
        Add( gens, Npcgs[i] );
      else
        # 'i' is the position of the last nonzero entry of 'v'.
        for j in Reversed( [ 1 .. i-1 ] ) do
          Add( gens, Npcgs[j]*Npcgs[i]^( Int(-v[j]/v[i]) ) );
        od;
        return SubgroupNC( N, Reversed( gens ) );
      fi;
    od;
end;


#############################################################################
##
#F  ProjectiveCharDeg( <G> ,<z> ,<q> )
##
##  is a collected list of the degrees of those faithful and absolutely
##  irreducible characters of the group <G> in characteristic <q> that
##  restrict homogeneously to the group generated by <z>, which must be
##  central in <G>.
##  Only those characters are counted that have value a multiple of
##  'E( Order(<z>) )' on <z>.
##
ProjectiveCharDeg := function( G, z, q )

    local oz,       # the order of 'z'
          N,        # normal subgroup of 'G'
          t,
          r,        # collected list of character degrees, result
          h,        # natural epimorphism
          k,
          c,
          ci,
          zn,
          i,
          p,        # prime divisor of the size of 'N'
          P,        # Sylow 'p' subgroup of 'N'
          O,
          L,
          Gpcgs,    # PCGS of 'G'
          Ppcgs,    # PCGS of 'P'
          Opcgs,    # PCGS of 'O'
          mats,
          orbs,
          orb,      # loop over 'orbs'
          stab;     # stabilizer of canonical representative of 'orb'

    oz:= Order( z );

    # For abelian groups, there are only linear characters.
    if IsAbelian( G ) then
      G:= Size( G );
      if q <> 0 then
        while G mod q = 0 do
          G:= G / q;
        od;
      fi;
      return [ [ 1, G/oz ] ];
    fi;

    # Now 'G' is not abelian.
    h:= NaturalHomomorphismByNormalSubgroup( G, SubgroupNC( G, [ z ] ) );
    N:= ElementaryAbelianSeries( Range( h ) );
    N:= N[ Length( N )-1 ];
    if not IsPrime( Size( N ) ) then
      N:= ChiefSeriesUnderAction( Range( h ), N );
      N:= N[ Length( N )-1 ];
    fi;

    # 'N' is a normal subgroup such that 'N/<z>' is a chief factor of 'G'
    # of order 'i' which is a power of 'p'.
    N:= PreImagesSet( h, N );
    i:= Size( N ) / oz;
    p:= Factors( i )[1];

    if not IsAbelian( N ) then

      h:= NaturalHomomorphismByNormalSubgroup( G, SubgroupNC( G, [ z ] ) );

      # 'c' is a list of complement classes of 'N' modulo 'z'
      c:= List( Complementclasses( Range( h ), ImagesSet( h, N ) ),
                x -> PreImagesSet( h, x ) );
      r:= Centralizer( G, N );
      for L in c do
        if IsSubset( L, r ) then

          # L is a complement to N in G modulo <z> which centralizes N
          r:= RootInt( Size(N) / oz );
          return List( ProjectiveCharDeg( L, z, q ),
                       x -> [ x[1]*r, x[2] ] );

        fi;
      od;
      Error( "this should not happen" );

    fi;

    # 'N' is abelian, 'P' is its Sylow 'p' subgroup.
    P:= SylowSubgroup( N, p );

    if p = q then

      # Factor out 'P' (lies in the kernel of the repr.)
      h:= NaturalHomomorphismByNormalSubgroup( G, P );
      return ProjectiveCharDeg( Range( h ), ImageElm( h, z ), q );

    elif i = Size( P ) then 

      # 'z' is a p'-element, 'P' is elementary abelian.
      # Find the characters of the factor group needed.
      h:= NaturalHomomorphismByNormalSubgroup( G, P );
      r:= ProjectiveCharDeg( Range( h ), ImageElm( h, z ), q );

      if p = i then

        # 'P' has order 'p'.
        zn:= First( GeneratorsOfGroup( P ), g -> not IsOne( g ) );
        t:=  Stabilizer( G, zn );
        i:= Size(G) / Size(t);
        AppendCollectedList( r,
            List( ProjectiveCharDeg( t, zn*z, q ),
                  x -> [ x[1]*i, x[2]*(p-1)/i ] ) );
        return r;

      else

        # 'P' has order strictly larger than 'p'.
        # 'mats' describes the contragredient operation of 'G' on 'P'.
        Gpcgs:= Pcgs( G );
        Ppcgs:= Pcgs( P );
        mats:= List( List( Gpcgs, Inverse ),
                   x -> TransposedMat( List( Ppcgs,
                   y -> ExponentsOfPcElement( Ppcgs, y^x ) )*Z(p)^0 ) );
        orbs:= ExternalOrbitsStabilizers( G,
                   Enumerator( FullRowModule( GF(p), Length( Ppcgs ) ) ),
                   Gpcgs, mats, OnRight );
        orbs:= Filtered( orbs,
              o -> not IsZero( CanonicalRepresentativeOfExternalSet( o ) ) );
                                       
        for orb in orbs do

          # 'k' is the kernel of the character.
          stab:= StabilizerOfExternalSet( orb );
          h:= NaturalHomomorphismByNormalSubgroup( stab,
                  KernelUnderDualAction( P, Ppcgs,
                      CanonicalRepresentativeOfExternalSet( orb ) ) );

          # 'zn' is an element of 'Range( h )'.
          # Note that the image of 'P' under 'h' has order 'p'.
          zn:= First( GeneratorsOfGroup( ImagesSet( h, P) ),
                      g -> not IsOne( g ) )
               * ImageElm( h, z );

          # 'c' is stabilizer of the character,
          # 'ci' is the number of orbits of characters with equal kernels
          if p = 2 then
            c  := Range( h );
            ci := 1;
          else
            c  := Stabilizer( Range( h ), zn );
            ci := Size( Range( h ) ) / Size( c );
          fi;
          k:= Size( G ) / Size( stab ) * ci;
          AppendCollectedList( r,
              List( ProjectiveCharDeg( c, zn, q ),
                    x -> [ x[1]*k, x[2]*(p-1)/ci ] ) );

        od;
        return r;

      fi;

    elif IsCyclic( P ) then

      # Choose a generator 'zn' of 'P'.
      zn := Pcgs( P )[1];
      t  := Stabilizer( G, zn, OnPoints );
      if G = t then
        # 'P' is a central subgroup of 'G'.
        return List( ProjectiveCharDeg( G, zn*z, q ),
                     x -> [ x[1], x[2]*p ] );
      else
        # 'P' is not central in 'G'.
        return List( ProjectiveCharDeg( t, zn*z, q ),
                     x -> [ x[1]*p, x[2] ] );
      fi;

    fi;

    # 'P' is the direct product of the Sylow 'p' subgroup of 'z'
    # and an elementary abelian 'p' subgroup.
    O:= Omega( P, p );
    Opcgs:= Pcgs( O );
    Gpcgs:= Pcgs( G );

    # 'zn' is a generator of the intersection of <z> and 'O'
    zn := z^(oz/p);
    r  := [];
    mats:= List( List( Gpcgs, Inverse ),
                 x -> TransposedMat( List( Opcgs,
                      y -> ExponentsOfPcElement( Opcgs, y^x ) ) * Z(p)^0 ) );
    orbs:= ExternalOrbitsStabilizers( G,
               Enumerator( GF(p)^Length( Opcgs ) ),
               Gpcgs, mats, OnRight );
    orbs:= Filtered( orbs,
              o -> not IsZero( CanonicalRepresentativeOfExternalSet( o ) ) );
                                     
    # In this case the stabilzers of the kernels are already the
    # stabilizers of the characters.
    for orb in orbs do
      k:= KernelUnderDualAction( O, Opcgs,
              CanonicalRepresentativeOfExternalSet( orb ) );
      if not zn in k then
        # The kernel avoids 'zn'.
        t:= StabilizerOfExternalSet( orb );
        h:= NaturalHomomorphismByNormalSubgroup( t, k );
        t:= Size(G) / Size(t);
        AppendCollectedList( r, List( ProjectiveCharDeg( Range( h ),
                                          ImageElm( h, z ), q ),
                                      x -> [ x[1]*t, x[2] ] ) );
      fi;
    od;
    return r;
end;


#############################################################################
##
#M  CharacterDegreesOp( <G>, <p> )  . . . . . . . . . .  for a solvable group
##
##  The used algorithm is described in
##
##      S. B. Conlon, J. Symbolic Computation (1990) 9, 551-570.
##
##  The main theoretic tool for the algorithm is Clifford theory.
##  One recursive step of the algorithm will be described.
##
##  Let $G$ be a solvable group, $z$ a central element in $G$,
##  and let $q$ be the characteristic of the algebraic closed field $F$.
##  Without loss of generality, we may assume that $G$ is nonabelian.
##  Consider a faithful linear character $\lambda$ of $\langle z \rangle$.
##  We calculate the character degrees $(G,z,q)$ of those absolutely
##  irreducible characters of $G$ whose restrictions to $\langle z \rangle$
##  are a multiple of $\lambda$.
##
##  We choose a normal subgroup $N$ of $G$ such that the factor
##  $N / \langle z \rangle$ is a chief factor in $G$, and consider
##  the following cases.
##
##  If $N$ is nonabelian then we calculate a subgroup $L$ of $G$ such that
##  $N \cap L = \langle z \rangle$, $L$ centralizes $N$, and $N L = G$.
##  One can show that the order of $N / \langle z \rangle$ is a square $r^2$,
##  and that the degrees $(G,z,q)$ are obtained from the degrees $(L,z,q)$
##  on multiplying each with $r$.
##
##  If $N$ is abelian then the order of $N / \langle z \rangle$ is a prime
##  power $p^i$.
##  Let $P$ denote the Sylow $p$ subgroup of $N$.
##  Following Clifford's theorem, we calculate orbit representatives and
##  inertia subgroups with respect to the action of $G$ on those irreducible
##  characters of $P$ that restrict to multiples of $\lambda_P$.
##  For that, we distinguish three cases.
##
##  (a) $z$ is a $p^{\prime}$ element.
##      Then we compute first the character degrees $(G/P,zP,q)$,
##      corresponding to the (orbit of the) trivial character.
##      The action on the nontrivial irreducible characters of $P$
##      is dual to the action on the nonzero vectors of the vector space
##      $P$.
##      For each representative, we compute the kernel $K$, and the degrees
##      $(S/K,zK,q)$, where $S$ denotes the inertia subgroup.
##
##  (b) $z$ is not a $p^{\prime}$ element, and $P$ cyclic (not prime order).
##      Let $y$ be a generator of $P$.
##      If $y$ is central in $G$ then we have to return $p$ copies of the
##      degrees $(G,zy,q)$.
##      Otherwise we compute the degrees $(C_G(y),zy,q)$, and multiply
##      each with $p$.
##
##  (c) $z$ is not a $p^{\prime}$ element, and $P$ is not cyclic.
##      We compute $O = \Omega(P)$.
##      As above, we consider the dual operation to that in $O$,
##      and for each orbit representative we check whether its restriction
##      to $O$ is a multiple of $\lambda_O$, and if yes compute the degrees
##      $(S/K,zK,q)$.
##
##  Note that only those cases of the algorithm 'ProjectiveCharDeg'
##  are needed that occur for trivial $z$.
##  Especialy N is elementary abelian.
##
InstallMethod( CharacterDegreesOp,
    "method for a solvable group and an integer (Conlon's algorithm)",
    true,
    [ IsGroup and IsSolvableGroup, IsInt ], 0,
    function( G, q )

    local r,      # list of degrees, result
          N,      # elementary abelian normal subgroup of 'G'
          p,      # prime divisor of the order of 'N'
          z,      # one generator of 'N'
          t,      # stabilizer of 'z' in 'G'
          i,      # index of 't' in 'G'
          Gpcgs,  # PCGS of 'G'
          Npcgs,  # PCGS of 'N'
          mats,   # matrices describing the action of 'Gpcgs' w.r.t. 'Npcgs'
          orbs,   # orbits of the action
          orb,    # loop over 'orbs'
          rep,    # canonical representative of 'orb'
          stab,   # stabilkizer of 'rep'
          h,      # nat. hom. by the kernel of a character
          c,
          ci,
          k;

    # If the group is abelian, we must give up because this method
    # needs a proper elementary abelian normal subgroup for its
    # reduction step.
    # (Note that we must not call 'TryNextMethod' because the method
    # for abelian groups has higher rank.)
    if IsAbelian( G ) then
      return CharacterDegrees( G, q );
    elif not ( q = 0 or IsPrimeInt( q ) ) then
      Error( "<q> mut be zero or a prime" );
    fi;

    # Choose a normal elementary abelian 'p'-subgroup 'N',
    # not necessarily minimal.
    N:= ElementaryAbelianSeries( G );
    N:= N[ Length( N ) - 1 ];
    r:= CharacterDegreesOp( G / N, q );
    p:= Factors( Size( N ) )[1];

    if p = q then

      # If 'N' is a 'q'-group we are done.
      return r;

    elif Size( N ) = p then

      # 'N' is of prime order.
      z:= Pcgs( N )[1];
      t:= Stabilizer( G, z, OnPoints );
      i:= Size( G ) / Size( t );
      AppendCollectedList( r, List( ProjectiveCharDeg( t, z, q ),
                                    x -> [ x[1]*i, x[2]*(p-1)/i ] ) );
      return r;

    else

      # 'N' is an elementary abelian 'p'-group of nonprime order.
      Gpcgs:= Pcgs( G );
      Npcgs:= Pcgs( N );
      mats:= List( Gpcgs, x -> TransposedMat( List( Npcgs,
                 y -> ExponentsOfPcElement( Npcgs, y^x ) ) * Z(p)^0 )^-1 );
      orbs:= ExternalOrbitsStabilizers( G,
                 Enumerator( GF( p )^Length( Npcgs ) ),
                 Gpcgs, mats, OnRight );
      orbs:= Filtered( orbs,
              o -> not IsZero( CanonicalRepresentativeOfExternalSet( o ) ) );
                                     
      for orb in orbs do

        stab:= StabilizerOfExternalSet( orb );
        rep:= CanonicalRepresentativeOfExternalSet( orb );
        h:= NaturalHomomorphismByNormalSubgroup( stab,
                KernelUnderDualAction( N, Npcgs, rep ) );
        # The kernel has index 'p' in 'stab'.
        z:= First( GeneratorsOfGroup( ImagesSet( h, N ) ),
                   g -> not IsOne( g ) );
        if p = 2 then
          c  := Range( h );
          ci := 1;
        else 
          c  := Stabilizer( Range( h ), z );
          ci := Size( Range( h ) ) / Size( c );
        fi;
        k:= Size( G ) / Size( stab ) * ci;
        AppendCollectedList( r, List( ProjectiveCharDeg( c, z, q ),
                                      x -> [ x[1]*k, x[2]*(p-1)/ci ] ) );

      od;

    fi;

    return r;
    end );


#############################################################################
##
#F  CoveringTriplesCharacters( <G>, <z> ) . . . . . . . . . . . . . . . local
##
##  <G> must be a supersolvable group, and <z> a central element in <G>.
##  'CoveringTriplesCharacters' returns a list of tripels $[ T, K, e ]$
##  such that every irreducible character $\chi$ of <G> with the property
##  that $\chi(<z>)$ is a multiple of 'E( Order(<z>) )' is induced from a
##  linear character of some $T$, with kernel $K$.
##  The element $e \in T$ is chosen such that $\langle e K \rangle = T/K$.
##
##  The algorithm is in principle the same as 'ProjectiveCharDeg',
##  but the recursion stops if $<G> = <z>$.
##  The structure and the names of the variables are the same.
##
CoveringTriplesCharacters := function( G, z )

    local oz,
          N,
          t,
          r,
          h,
          k,
          c,
          zn,
          i,
          p,
          P,
          O,
          Gpcgs,
          Ppcgs,
          Opcgs,
          mats,
          orbs,
          orb;

    # The trivial character will be dealt with separately.
    if IsTrivial( G ) then
      return [];
    fi;

    oz:= Order( z );
    if Size( G ) = oz then
      return [ [ G, TrivialSubgroup( G ), z ] ];
    fi;

    h:= NaturalHomomorphismByNormalSubgroup( G, SubgroupNC( G, [ z ] ) );
    N:= ElementaryAbelianSeries( Range( h ) );
    N:= N[ Length( N ) - 1 ];
    if not IsPrime( Size( N ) ) then
      N:= ChiefSeriesUnderAction( Range( h ), N );
      N:= N[ Length( N ) - 1 ];
    fi;
    N:= PreImagesSet( h, N );

    if not IsAbelian( N ) then
      Print( "#I misuse of 'CoveringTriplesCharacters'!\n" );
      return [];
    fi;

    i:= Size( N ) / oz;
    p:= Factors( i )[1];
    P:= SylowSubgroup( N, p );

    if i = Size( P ) then 

      # 'z' is a p'-element, 'P' is elementary abelian.
      # Find the characters of the factor group needed.
      h:= NaturalHomomorphismByNormalSubgroup( G, P );
      r:= List( CoveringTriplesCharacters( Range( h ), ImageElm( h, z ) ),
                x -> [ PreImagesSet( h, x[1] ),
                       PreImagesSet( h, x[2] ),
                       PreImagesRepresentative( h, x[3] ) ] );

      if p = i then

        # 'P' has order 'p'.
        zn:= First( GeneratorsOfGroup( P ), g -> not IsOne( g ) );
        return Concatenation( r,
                   CoveringTriplesCharacters( Stabilizer( G, zn ), zn*z ) );

      else

        Gpcgs:= Pcgs( G );
        Ppcgs:= Pcgs( P );
        mats:= List( List( Gpcgs, Inverse ),
                   x -> TransposedMat( List( Ppcgs,
                   y -> ExponentsOfPcElement( Ppcgs, y^x ) )*Z(p)^0 ) );
        orbs:= ExternalOrbitsStabilizers( G,
                   Enumerator( FullRowModule( GF(p), Length( Ppcgs ) ) ),
                   Gpcgs, mats, OnRight );
        orbs:= Filtered( orbs,
              o -> not IsZero( CanonicalRepresentativeOfExternalSet( o ) ) );
                                       
        for orb in orbs do
          h:= NaturalHomomorphismByNormalSubgroup(
                  StabilizerOfExternalSet( orb ),
                  KernelUnderDualAction( P, Ppcgs,
                      CanonicalRepresentativeOfExternalSet( orb ) ) );
          zn:= First( GeneratorsOfGroup( ImagesSet( h, P ) ),
                      g -> not IsOne( g ) )
               * ImageElm( h, z );
  
          if p = 2 then
            c:= Range( h );
          else
            c:= Stabilizer( Range( h ), zn );
          fi;
          Append( r, List( CoveringTriplesCharacters( c, zn ),
                           x -> [ PreImagesSet( h, x[1] ),
                                  PreImagesSet( h, x[2] ),
                                  PreImagesRepresentative( h, x[3] ) ] ) );
        od;
        return r;

      fi;

    elif IsCyclic( P ) then

      zn:= Pcgs( P )[1];
      return CoveringTriplesCharacters( Stabilizer( G, zn ), zn*z );

    fi;

    O:= Omega( P, p );
    Opcgs:= Pcgs( O );
    Gpcgs:= Pcgs( G );

    zn := z^(oz/p);
    r  := [];
    mats:= List( List( Gpcgs, Inverse ),
                 x -> TransposedMat( List( Opcgs,
                      y -> ExponentsOfPcElement( Opcgs, y^x ) )*Z(p)^0 ) );
    orbs:= ExternalOrbitsStabilizers( G,
               Enumerator( FullRowModule( GF(p), Length( Opcgs ) ) ),
               Gpcgs, mats, OnRight );
    orbs:= Filtered( orbs,
              o -> not IsZero( CanonicalRepresentativeOfExternalSet( o ) ) );
                                     
    for orb in orbs do
      k:= KernelUnderDualAction( O, Opcgs,
              CanonicalRepresentativeOfExternalSet( orb ) );
      if not zn in k then
        t:= SubgroupNC( G, StabilizerOfExternalSet( orb ) );
        h:= NaturalHomomorphismByNormalSubgroup( t, k );
        Append( r,
            List( CoveringTriplesCharacters( Range( h ), ImageElm( h, z ) ),
                  x -> [ PreImagesSet( h, x[1] ),
                         PreImagesSet( h, x[2] ),
                         PreImagesRepresentative( h, x[3] ) ] ) );
      fi;
    od;
    return r;
end;


#############################################################################
##
#F  IrrConlon( <G> )
##
##  This algorithm is a generalization of the algorithm to compute the
##  absolutely irreducible degrees of a solvable group to the computation
##  of the absolutely irreducible characters of a supersolvable group,
##  using an idea like in 
##
##      S. B. Conlon, J. Symbolic Computation (1990) 9, 535-550.
##
##  The function 'CoveringTriplesCharacters' is used to compute a list of
##  triples describing linear representations of subgroups of <G>.
##  These linear representations are induced to <G> and then evaluated on
##  representatives of the conjugacy classes. 
##
##  For every irreducible character the monomiality information is stored as
##  value of the attribute 'TestMonomial'.
##
IrrConlon := function( G )

    local ccl,        # conjugacy classes of 'G'
          Gpcgs,      # PCGS of 'G'
          irr,        # matrix of character values
          irredinfo,  # monomiality info
          evl,        # encode class representatives as words in 'Gpcgs'
          i,
          t,
          chi,
          j,
          mat,
          k,
          triple,
          hom,
          zi,
          oz,
          ee,
          zp,
          co,          # cosets
          coreps,      # representatives of 'co'
          dim,
          rep,         # matrix representation
          bco,
          p,
          r,
          mulmoma,     # local function: multiply monomial matrices
          i1,          # loop variable in 'mulmoma'
          re,          # result of 'mulmoma'
          ct;          # character table of 'G'

    # Compute the product of the monomial matrices 'a' and 'b';
    # The diagonal elements are powers of a fixed 'oz'-th root of unity.
    mulmoma:= function( a, b )
      re:= rec( perm:= [], diag:= [] );
      for i1 in [ 1 .. Length( a.perm ) ] do
        re.perm[i1]:= b.perm[ a.perm[i1] ];
        re.diag[ b.perm[i1] ]:= ( b.diag[ b.perm[i1] ] + a.diag[i1] ) mod oz;
      od;
      return re;
    end;

    ccl:= ConjugacyClasses( G );
    Gpcgs:= Pcgs( G );
    irr:= [];
    irredinfo:= [ rec( inducedFrom:= rec( subgroup:= G, kernel:= G ) ) ];

    # 'evl' is a list describing representatives of the nontrivial
    # conjugacy classes.
    # the entry for the element $g.1^2*g.2^0*g.3^1$ is $[ 1, 1, 3 ]$.
    evl:= [];
    for i in [ 2 .. Length( ccl ) ] do
      k:= ExponentsOfPcElement( Gpcgs, Representative( ccl[i] ) );
      t:= [];
      for j in [ 1 .. Length( k ) ] do
        if 0 < k[j] then
          Append( t, [ 1 .. k[j] ]*0 + j );
        fi;
      od;
      Add( evl, t );
    od;

    for triple in CoveringTriplesCharacters( G, One( G ) ) do

      hom:= NaturalHomomorphismByNormalSubgroup( triple[1], triple[2] );
      zi:= ImagesRepresentative( hom, triple[3] );
      oz:= Order( zi );
      ee:= E( oz );
      zp:= List( [ 1 .. oz ], x -> zi^x );
      co:= RightCosets( G, triple[1] );
      coreps:= List(  co, Representative );
      dim:= Length( co );

      # 'rep' describes a matrix representation on a module with basis
      # a transversal of the stabilizer in 'G'.
      # (The monomial matrices are the same as in 'RepresentationsPGroup'.)
      rep:= [];
      for i in Gpcgs do
        mat:= rec( perm:= [], diag:= [] );
        for j in [ 1 .. dim ] do
          bco:= co[j]*i;
          p:= Position( co, bco, 0 );
          Add( mat.perm, p );
          mat.diag[p]:= Position( zp,
              ImageElm( hom, coreps[j]*i*Inverse( coreps[p] ) ), 0 );
        od;
        Add( rep, mat );
      od;

      # Compute the representing matrices for class representatives,
      # and their traces.
      chi:= [ dim ];
      for j in evl do
        mat:= Iterated( rep{ j }, mulmoma );
        t:= 0;
        for k in [ 1 .. dim ] do
          if mat.perm[k] = k then 
            t:= t + ee^mat.diag[k];
          fi;
        od;
        Add( chi, t );
      od;

      # Test if 'chi' is known and add 'chi' and its Galois-conjugates
      # to the list.
      # Also compute the monomiality information.
      if not chi in irr then
        chi:= GaloisMat( [ chi ] ).mat;
        Append( irr, chi );
        for j in chi do
          Add( irredinfo, rec( subgroup:= triple[1], kernel:= triple[2] ) );
        od;
      fi;

    od;

    # Construct the characters from their values lists,
    # and set the monomiality info.
    ct:= CharacterTable( G );
    irr:= Concatenation( [ TrivialCharacter( G ) ],
                         List( irr, chi -> CharacterByValues( ct, chi ) ) );
    for i in [ 1 .. Length( irr ) ] do
      SetTestMonomial( irr[i], irredinfo[i] );
    od;

    # Return the characters.
    return irr;
end;


#############################################################################
##
#M  Irr( <G> )  . . . . . . .  for a supersolvable group (Conlon's algorithm)
##
InstallMethod( Irr,
    "method for a supersolvable group (Conlon's algorithm)",
    true,
    [ IsGroup and IsSupersolvableGroup ], 0,
    IrrConlon );


# #############################################################################
# ##
# #F  RepresenatationsPGroup(G) . irr. representations of a supersolvable group
# ##
# ##  This file contains those functions which calculate the irreducible
# ##  representaions and characters of supersolvable ag-groups with the 
# ##  algorithm published by Ulrich Baum, University of Bonn, Germany, 1991
# ##
# ##  The matrices for the monomial representations are discribed as a record 
# ##  with entries perm and diag. E.g. the matrix (perm:=[3,1,2],diag:=[1,2,3])
# ##  is the product of 
# ##  [ . , . , 1 ]     [  Ee^1 ,   .   ,   .   ]   [   .   ,   .   ,  Ee^3 ]
# ##  [ 1 , . , . ]  *  [   .   ,  Ee^2 ,   .   ] = [  Ee^1 ,   .   ,   .   ]
# ##  [ . , 1 , . ]     [   .   ,   .   ,  Ee^3 ]   [   .   ,  Ee^2 ,   .   ]
# ##  where Ee:=E(g.exponent). If g.exponent is unknown then
# ##  Ee is E(Size(g)). The Representations are returned in a record with the
# ##  components exponent, lin for the list of linear representations and 
# ##  nonlin for the nonlinear representations. The linear representations are
# ##  given as the list of exponents of E(exponent) on the igs, the nonlinear
# ##  as matrices on the igs as discribed above.
# ##
# ##  This function is able to compute the representations of a solvable group
# ##  if it has an abelian normal subgroup with supersolvable factorgroup.
# ##  If the supersolvable residuum of the group is not abelian, the 
# ##  algorithm is applied to the factorgroup of g to the commutator subgroup
# ##  of the supersolvable residuum of g.
# ##
# ##  For this purpose a composition series of g is used, such that the 
# ##  maximal abelian and all nonabelian composition subgroups are normal.
# ##  Along this series increasing the representations of the composition
# ##  subgroups are calculated knowing the representations of the subgroup
# ##  below.
# ##
# ##  These representations have the property, that on every subgroup below
# ##  they restrict to a direct sum of irreducible representations, and
# ##  if two irreducible components are similar, they are allready equal.
# ##
# ##  For the computation of the representation of the subgroup G using
# ##  those of the subgroup N below the theorem of clifford is used. The
# ##  index [G:N] is prime, so for every representation F of N the induced
# ##  representation is irreducible or N could be extended to G in p
# ##  different ways.
# ##
# ##  In the first case the representation will be induced in the usall way.
# ##  If the induced representation is restricted to N again, it is the sum
# ##  of all the conjugates of R under the operation of G. For every conjugate
# ##  the equivalent representative from the list of representations of N
# ##  is found, and the induced of R is modified such that it restricts to
# ##  the direct sum of the representatives.
# ##
# ##  In the other case some matrix must be found which operates on R like
# ##  an element g form G\N. Modified by scalar matrices this matrix can
# ##  be used to construct the p different extensions.
# ##
# ##  For both purposes an algorithm is needed which tests (recursive)
# ##  wheather two representations F and D of the subgroups are equivalent,
# ##  and, if they are, returns a conjugating matrix. Therefore F and D should
# ##  be a representation of G. N should be the smaller composition subgroup
# ##  of primindex p. 
# ##  
# ##  If F and D are linear representation the recursion stops and the
# ##  representations are equivalent if they are equal.
# ##
# ##  If they are not linear, it is tested by locking at their permutation
# ##  structure if their restrictions to N are irreducible or not.
# ##
# ##  If both restrictions are irreducible, this test is recursive applied
# ##  to the restrictions. If they are irreducible, a conjugating matrix is
# ##  returned and it has just to be tested, if this matrix conjugates F
# ##  and D.
# ##
# ##  If both restrictions are reducible, pairs of equivalent irreducible
# ##  components of the restrictions are searched recursiv. The conjugation
# ##  matrix will be combinated from the permutation matrix of the conponents
# ##  and those conjugating matrices which transform the single components.
# ##
# RepresentationsPGroup := function(arg)
# 
#     local   mulmoma, opmoma, poweval, conrep, conlinrep, contest, isredrep,
#         liftreps, liftlinreps, liftrepsab, liftlinrepsab,
#         i, j, exp, replist, linreplist, coli, poli, lg, gexps, expl, igs,
#         flag, s, cs, ssr, hom, iso, t, k, g, rep,
#         i1, i2, i3, r, rr, rrr, aip, aid, bap, bad;
# 
#     # mulmoma returns the product of 2 monomial matrices
#     mulmoma:=function(a,b)
#     r:=rec(perm:=[],diag:=[]);
#     for i1 in [1..Length(a.perm)] do
#         r.perm[i1]:=b.perm[a.perm[i1]];
#         r.diag[b.perm[i1]]:=(b.diag[b.perm[i1]]+a.diag[i1]) mod exp;
#         od;
#     return r;
#     end;
# 
#     # opmoma returns a^-1*b*a for monomial matrices
#     opmoma:=function(b,a)
#     aip:=[]; aid:=[]; bap:=[]; bad:=[];
#     for i1 in [1..Length(a.perm)] do
#         aip[a.perm[i1]]:=i1; aid[i1]:=exp-a.diag[a.perm[i1]];
#         bad[a.perm[i1]]:=a.diag[a.perm[i1]]+b.diag[i1];
#         bap[i1]:=a.perm[b.perm[i1]];
#     od;
#     r:=rec(perm:=[],diag:=[]);
#     for i1 in [1..Length(a.perm)] do
#         r.perm[i1]:=bap[aip[i1]];
#         r.diag[bap[i1]]:=(bad[bap[i1]]+aid[i1]) mod exp;
#     od;
#     return r;
#     end;
# 
#     # poweval evalutes the representation rep on the p-th power of
#     # the conjugating element. The p-th power of this element is discribed
#     # by poli
#     poweval:=function(rep)
#     if poli=[] then
#         return rec( perm:=[1..Length(rep[1].perm)],
#                     diag:=[1..Length(rep[1].perm)]*0);
#     fi;
#     if Length(poli)=1 then return Copy(rep[poli[1]]); fi;
#     rr:=mulmoma(rep[poli[1]],rep[poli[2]]);
#     for i2 in [3..Length(poli)] do rr:=mulmoma(rr,rep[poli[i2]]); od;
#     return rr;
#     end;
# 
#     # conrep returns the conjugate representation of rep.
#     # The operation on rep is discribed by coli
#     conrep:=function(rep)
#     rr:=[];
#     for i2 in coli do
#         rrr:=rep[i2[1]];
#         for i3 in [2..Length(i2)] do rrr:=mulmoma(rrr,rep[i2[i3]]); od;
#         Add(rr,rrr);
#         od;
#     return rr;
#     end;
# 
#     # conlinrep does the same like conrep for a linear representation
#     conlinrep:=function(rep)
#     r:=[];
#     for i1 in coli do
#         rr:=rep[i1[1]];
#         for i2 in [2..Length(i1)] do
#             rr:=rr+rep[i1[i2]];
#             od;
#             Add(r,rr mod exp);
#         od;
#     return r;
#     end;
# 
#     # test if the restriction of the representation rep is reducible
#     isredrep:=function(rep,rp,b,p)
#     for i1 in [rp..Length(rep)] do
#         for i2 in [1..p]*b do
#             for i3 in [i2-b+1..i2] do
#                 if rep[i1].perm[i3]>i2 then return false; fi;
#                 od;
#             od;
#         od;
#     return true;
#     end;
# 
#     # contest tests whether r1 and r2 are conjugate representations.
#     # If it is so, the function returns a conjugating matrix.
#     # r1 and r2 must have the same degree and be nonlinear
#     contest:=function(r1,r2)
#     local   i, j, d, b, p, rp, Ap, flag, rr, rrr,
#         c, B, P, PP, X, XX, zr1, zr2, rr2, rrr2;
#     # d is the degree of the representations
#     d:=Length(r1[1].perm);
#     # check if r1=r2 for time improvement
#     if r1=r2 then return rec(perm:=[1..d],diag:=[1..d]*0); fi;
#     # search for maximal composition subgroup so that r1 and r2 are
#     # reducible
#     rp:=1; flag:=false;
#     repeat
#         rp:=rp+1; p:=gexps[lg-Length(r1)+rp-1]; b:=d/p;
#         if IsInt(b) then
#             if not isredrep(r1,rp,b,p) then
#                 if isredrep(r2,rp,b,p) then return false; fi;
#                 # if one of representations is reducible and the other
#                 # is not, they aren't equivalent
#             else
#                 if not isredrep(r2,rp,b,p) then
#                     return false;
#                 else flag:=true;
#                     fi;
#                 fi;
#             fi;
#     until flag;
#     # zr1 and zr2 will be lists of the irreducible components of r1 and r2
#     zr1:=[]; zr2:=[];
#     for i1 in [0..p-1]*b do
#         rr:=[]; rr2:=[];
#         for i2 in [rp..Length(r1)] do
#             rrr:=rec(perm:=[],diag:=[]); rrr2:=rec(perm:=[],diag:=[]);
#             for i3 in [i1+1..i1+b] do
#                 Add(rrr.perm,r1[i2].perm[i3]-i1);
#                 Add(rrr.diag,r1[i2].diag[i3]);
#                 Add(rrr2.perm,r2[i2].perm[i3]-i1);
#                 Add(rrr2.diag,r2[i2].diag[i3]);
#             od;
#             Add(rr,rrr); Add(rr2,rrr2);
#         od;
#         Add(zr1,rr); Add(zr2,rr2);
#     od;
#     # X is a list of those matrices conjugating the pairs of
#     # irreducible components, PP discribes the permutation on the set
#     # of components
#     X:=[]; PP:=rec(perm:=[],diag:=[1..d]*0);
#     if b=1 then
#         # the irreducible components are linear
#         for i in [1..p] do
#             j:=Position(zr2,zr1[i]);
#             # linear representations are equivalient if they are equal
#             if j=false then return false; fi;
#             # if their is a component which has no equivalent partner,
#             # then r1 and r2 aren't equivalent
#             Add(X,rec(perm:=[1],diag:=[0])); Add(PP.perm,j);
#         od;
#     else
#         # the irreducible components aren't linear
#         # searching for pairs of equivalent components
#         P:=[1..p];
#         for i in [1..p] do
#             flag:=true;
#             for j in P do
#                 if flag then 
#                     c:=contest(zr1[i],zr2[j]);
#                     if c<>false then
#                         RemoveSet(P,j); Add(X,c); flag:=false;
#                         Append(PP.perm,[(j-1)*b+1..j*b]);
#                     fi;
#                 fi;
#             od;
#             # zr1[i] is not equivalent to any zr2[j]
#             if flag then return false; fi;
#         od;
#     fi;
#     # find coefficients for the X[i] and construct conjugating matrix
#     j:=Copy(PP.perm); for i in [1..d] do PP.perm[j[i]]:=i; od;
#     P:=opmoma(r2[rp-1],PP); XX:=Copy(X[1]); c:=0;
#     for i in [1..p-1] do
#         Ap:=r1[rp-1].perm[i*b+1]-(i-1)*b; B:=rec(perm:=[],diag:=[]);
#         for j in [(i-1)*b+1..i*b] do
#             Add(B.perm,P.perm[j+b]-(i-1)*b); Add(B.diag,P.diag[j]);
#         od;
#         c:=c+mulmoma(B,X[i]).diag[Ap]-r1[rp-1].diag[Ap+(i-1)*b]
#             -X[i+1].diag[1];
#         Append(XX.perm,X[i+1].perm+b*i); Append(XX.diag,X[i+1].diag+c);
#     od;
#     XX:=mulmoma(PP,XX);
#     for i in [1..rp-2] do if opmoma(r2[i],XX)<>r1[i] then return false; fi; od;
#     return XX;
#     end;
# 
#     # liftreps does one iterativ step by constructing all representations
#     # of the next composition subgroup which arise from nonlinear
#     # representations
#     liftreps:=function(replist)
#     local   i, j, k, p, dim, d, used, flag, rep, con, result, D, g, c, X, r;
#     p:=gexps[lg-Length(replist[1])];
#     # used is a list mentioning all those representations which have be 
#     # used for the construction
#     used:=BlistList([1..Length(replist)],[]); result:=[]; d:=1;
#     while d<>false do
#         used[d]:=true; rep:=replist[d]; con:=conrep(rep); g:=poweval(rep);
#         c:=contest(rep,con);
#         if c<>false then
#             # rep can be extended in p different ways, c is a operating
#             # matrix
#             j:=mulmoma(c,c); for k in [3..p] do j:=mulmoma(c,j); od;
#             j:=j.diag[1]+g.diag[g.perm[1]]; r:=rec(perm:=[],diag:=[]);
#             # r:=c^-1
#             for k in [1..Length(c.perm)] do
#                 r.perm[c.perm[k]]:=k; r.diag[k]:=exp-c.diag[c.perm[k]];
#             od;
#             # adjust r by a scalar and contruct the p extensions
#             for k in (j/p)+[0..p-1]*(exp/p) do
#                 X:=[]; for i in r.diag do Add(X,(i+k) mod exp); od;
#                 Add(result,Concatenation([rec(perm:=r.perm,diag:=X)],rep));
#             od;
#         else
#             # rep could not be extended
#             dim:=Length(rep[1].diag); D:=Copy(rep); r:=(p-1)*dim;
#             X:=rec(perm:=[1..dim],diag:=[1..dim]*0);
#             # search for the representatives of the G-conjugates of rep
#             for j in [1..p-1]*dim do
#                 flag:=false; i:=1;
#                 repeat
#                     if (not used[i]) and
#                         (Length(con[1].perm)=Length(replist[i][1].perm)) then
#                         c:=contest(replist[i],con);
#                         if c<>false then
#                             Append(X.diag,c.diag); Append(X.perm,c.perm+j);
#                             for k in [1..Length(rep)] do
#                                 Append(D[k].diag,replist[i][k].diag);
#                                 Append(D[k].perm,replist[i][k].perm+j);
#                             od;
#                             # theese representatives are used
#                             used[i]:=true; flag:=true;
#                         fi;
#                     fi;
#                     i:=i+1;
#                 until flag;
#                 if j<>r then con:=conrep(con); fi;
#             od;
#             Add(result,Concatenation([opmoma(rec(perm:=Concatenation(g.perm+r,
#                 [1..r]),diag:=Concatenation([1..r]*0,g.diag)),X)],D));
#         fi;
#         d:=Position(used,false,d);
#     od;
#     return result;
#     end;
# 
#     # liftrepsab does the same like liftreps if the operation is trivial
#     liftrepsab:=function(replist)
#     local   result, rep, p, k, o;
#     p:=gexps[lg-Length(replist[1])]; result:=[];
#     for rep in replist do
#         o:=[1..Length(rep[1].perm)]*0;
#         for k in (poweval(rep).diag[1]/p)+[0..p-1]*(exp/p) do
#             Add(result,Concatenation([rec(perm:=
#                 [1..Length(rep[1].perm)],diag:=o+k)],rep));
#         od;
#     od;
#     return result;
#     end;
# 
#     # liftlinreps does the same like liftreps for linear represenations
#     liftlinreps:=function(replist)
#     local   i, j, k, d, p, pot, rep, con, used, lin, nonlin, D; 
#     used:=BlistList([1..Length(replist)],[]); lin:=[]; nonlin:=[]; d:=1;
#     p:=gexps[lg-Length(replist[1])];
#     while d<>false do
#         rep:=replist[d]; used[d]:=true; con:=conlinrep(rep);
#         if poli=[] then
#             pot:=0;
#         else
#             pot:=rep[poli[1]];
#             for i in [2..Length(poli)] do pot:=pot+rep[poli[i]]; od;
#             pot:=pot mod exp;
#         fi;
#         if con=rep then 
#             for i in (pot/p)+[0..p-1]*(exp/p) do
#                 Add(lin,Concatenation([i],rep));
#             od;
#         else
#             D:=[];
#             for i in rep do Add(D,rec(perm:=[1..p],diag:=[i])); od;
#             for j in [2..p] do
#                 i:=Position(replist,con);
#                 for k in [1..Length(rep)] do Add(D[k].diag,replist[i][k]); od;
#                 used[i]:=true;
#                 if j<>p then con:=conlinrep(con); fi;
#             od;
#             Add(nonlin,Concatenation([rec(perm:=Concatenation([p],
#                 [1..p-1]),diag:=Concatenation([1..p-1]*0,[pot]))],D));
#         fi;
#         d:=Position(used,false,d);
#     od;
#     return rec(lin:=Set(lin),nonlin:=nonlin);
#     end;
# 
#     # liftlinrepsab ...
#     liftlinrepsab:=function(replist)
#     local   i, p, pot, rep, result;
#     result:=[]; p:=gexps[lg-Length(replist[1])];
#     if poli=[] then
#         pot:=[0..p-1]*(exp/p);
#         for rep in replist do
#             for i in pot do Add(result,Concatenation([i],rep)); od;
#         od;
#     else
#         for rep in replist do
#             pot:=rep[poli[1]];
#             for i in [2..Length(poli)] do pot:=pot+rep[poli[i]]; od;
#             pot:=pot mod exp;
#             for i in (pot/p)+[0..p-1]*(exp/p) do
#                 Add(result,Concatenation([i],rep));
#             od;
#         od;
#     fi;
#     return result;
#     end;
# 
# 
#     # main procedure
#     g:=arg[1];
#     lg:=Length(Igs(g)); i:=1; igs:=Igs(g); cs:=CompositionSeries(g);
#     if IsBound(g.exponent) then exp:=g.exponent; else exp:=Size(g); fi;
#     # test and adjust the composition series
#     for i in [2..Length(cs)-1] do
#         if not (IsNormal(g,cs[i]) or IsAbelian(cs[i-1])) then
#             # the composition series of g is not suitable for the algorithm
#             replist:=[]; linreplist:=[]; expl:=[];
#             ssr:=SupersolvableResiduum(g);
#             hom:=NaturalHomomorphismByNormalSubgroup( g, DerivedSubgroup(ssr) );
#             if ( Size(hom.kernel)>1 and Length(arg)=1 ) then
#     Print("#W  RepresentationsPGroup:not all representations known\n");
#                 fi;
#             iso:=IsomorphismAgGroup(ElementaryAbelianSeriesThrough(
#                 List(g.ds,x->Image(hom,x))));
# #T Elm or Set?
#             Range( iso ).exponent:=exp;
#             # Apply function recursiv to the new group or factorgroup
#             rep:=RepresentationsPGroup( Range( iso ) );
#             lg:=Length( Range( iso ).generators);
#             # look how the images of the original igs is written in the
#             # new group
#             for i in igs do
#                 k:=Exponents( Range( iso ),Image(iso,Image(hom,i)));
# #T Elm or Set?
#                 t:=[];
#                 for j in [1..lg] do for i1 in [1..k[j]] do Add(t,j); od; od;
#                 Add(expl,t);
#                 od;
#             # find linear representations of original group
#             for i in rep.lin do
#                 s:=[];
#                 for j in expl do
#                     t:=0; for k in j do t:=t+i[k]; od; Add(s,t mod exp);
#                     od;
#                 Add(linreplist,s);
#                 od;
#             # find nonlinear representations of original group
#             for i in rep.nonlin do
#                 s:=[]; rr:=Length(i[1].perm);
#                 for j in expl do
#                     t:=rec(perm:=[1..rr],diag:=[1..rr]*0);
#                     for k in j do t:=mulmoma(t,i[k]); od; Add(s,t);
#                     od;
#                 Add(replist,s);
#                 od;
#             return rec(exponent:=exp,nonlin:=replist,lin:=linreplist);
#             fi;
#         od;
#     gexps:=[]; for i in igs do Add(gexps,RelativeOrderAgWord(i)); od;
#     # the representations of the smallest nontrivial compositionsubgroup
#     # are initialissed
#     linreplist:=List([0..gexps[lg]-1]*(exp/gexps[lg]),x->[x]); replist:=[];
#     # this loop runs along the composition series constructing the
#     # representations
#     for i in Reversed([1..lg-1]) do
#         # coli discribes the operation on the character of the normal subgroup
#         coli:=[]; flag:=true;
#         for j in [i+1..lg] do
#             expl:=igs[j]^igs[i]; if expl <> igs[j] then flag:=false; fi;
#             expl:=Exponents(g,expl);
#             Add(coli,Concatenation(List([i+1..lg],x->
#                 List([1..expl[x]],y->x-i))));
#         od;
#         expl:=Exponents(g,igs[i]^gexps[i]);
#         # poli discribes the p-th power of the conjugating element
#         poli:=Concatenation(List([i+1..lg],x->List([1..expl[x]],y->x-i)));
#         if flag then
#             # the operation is trivial
#             linreplist:=liftlinrepsab(linreplist);
#             if replist<>[] then replist:=liftrepsab(replist); fi;
#         else
#             # the operation is not trivial
#             if replist<>[] then replist:=liftreps(replist); fi;
#             j:=liftlinreps(linreplist); Append(replist,j.nonlin);
#             linreplist:=j.lin;
#         fi;
#     od;
#     return rec(exponent:=exp,nonlin:=replist,lin:=linreplist);
# end;
# 
# 
# 
# #############################################################################
# ##
# #F  MatRepresentationsPGroup( G [, int ] ). .  irr. matrix representations of
# #F  . . . . . . . . . . . . . . . . . . . . . . . . . . a supersolvable group
# ##
# ##  This function returns a list of homomorphism from the ag-group G 
# ##  to complex matrix groups realising the represenatations belonging
# ##  to the characters which can be computed by CharTablePGroup. If the
# ##  second argument is given, only the int-th representation is retuned.
# ##
# MatRepresentationsPGroup := function(arg)
#  
#     local   rep, mrep, i, j, k, t, r, e, mulmoma, m, al, Ee, lg, ew, evl,
#         ni, tt, g;
# 
#     mulmoma:=function(a,b)
#     r:=rec(perm:=[],diag:=[]);
#     for m in [1..al] do
#         r.perm[m]:=b.perm[a.perm[m]];
#         r.diag[b.perm[m]]:=(b.diag[b.perm[m]]+a.diag[m]);
#     od;
#     return r;
#     end;
# 
#     # check the arguments
#     if    Length( arg ) > 2
#        or not IsAgGroup( arg[1] )
#        or ( Length( arg ) = 2 and not IsInt( arg[2] ) ) then
#         Error("MatRepresentationsPGroup:usage( <ag-group> )\n",
#               "                                     ( <ag-group> , <int> )\n");
#     fi;
# 
#     g:= arg[1];
#     rep:= RepresentationsPGroup( g );
#     mrep:= [];
#     e:= E( rep.exponent );
#     Ee:= E( rep.exponent );
#     lg:= Length( Igs(g) );
#     evl:= [];
# 
#     # look how the generators are expressed in terms of the igs
#     for i in g.generators do
#       ew:= Exponents( g, i );
#       t:= [];
#       for j in [ 1 .. lg ] do
#         for k in [ 1 .. ew[j] ] do Add( t, j ); od;
#       od;
#       Add(evl,t);
#     od;
# 
#     if Length(arg)=2 then
#         if Length(rep.lin)<arg[2] then 
#             rep.nonlin:=[rep.nonlin[arg[2]-Length(rep.lin)]]; rep.lin:=[];
#         else
#             rep.nonlin:=[]; rep.lin:=[rep.lin[arg[2]]];
#         fi;
#     fi;
# 
#     # get linear representations
#     for i in rep.lin do
#         ni:=[];
#         for j in evl do
#             t:=0; for k in j do t:=t+i[k]; od; Add(ni,[[Ee^t]]);
# #T for not too big exponent store the powers Ee^t (compute only once)!
#             od;
#         Add(mrep,ni);
#     od;
# 
#     # get nonlinear representations
#     for i in rep.nonlin do
#         ni:=[]; al:=Length(i[1].perm);
#         for j in evl do 
#             t:=rec(perm:=[1..Length(i[1].perm)]);
#             t.diag:=t.perm*0;
#             for k in j do t:= mulmoma(t,i[k]); od;
#             tt:=List(t.perm,x->0*t.perm);
# 
#             # transform into a cyclotomic matrix
#             for k in [1..Length(t.perm)] do
#                 tt[k][t.perm[k]]:=Ee^t.diag[t.perm[k]];
#             od;
#             Add(ni,tt);
#         od;
#         Add(mrep,ni);
#     od;
#     if Length(arg)=2 then
#         return GroupHomomorphismByImages(g,MatGroup(mrep[1],CF(rep.exponent)),
#             g.generators,mrep[1]);
#     fi;
# 
#     return List(mrep,x->GroupHomomorphismByImages(g,MatGroup(x,
#         CF(rep.exponent)),g.generators,x));
#     end;
# 
# 
# 
# #############################################################################
# ##
# #F  CharTablePGroup(G)  . . . . . .  character table of a supersolvable group
# ##
# ##  This function calculates the character table of an ag-represented group
# ##  G, if there is an abelian normal subgroup N such that G/N is
# ##  supersolvable. If this is not, the characters of the largest factorgroup
# ##  with this property are computed and inflated to G. In this case a 
# ##  warning is printed out. The character table is returned and fixed in
# ##  G.charTable. If there are more then one arguments, they are ignored
# ##  but no warnings are printed.
# ##
# CharTablePGroup := function(arg)
# 
#     local   ecs, evl, lg, Ee, rep, t, tt, i, j, k, mulmoma, ew, ni, r, m,
#         al, p, pl, powermap, tbl, g;
# 
#     mulmoma:=function(a,b)
#     r:=rec(perm:=[],diag:=[]);
#     for m in [1..al] do
#         r.perm[m]:=b.perm[a.perm[m]];
#         r.diag[b.perm[m]]:=(b.diag[b.perm[m]]+a.diag[m]);
#     od;
#     return r;
#     end;
# 
#     g:=arg[1];
# 
#     # Note that we do not need the conjugacy classes and power maps
#     # for computing the irreducible characters.
#     # What we can use is the exponent of the group, and since we need
#     # the classes anyhow in the end, we can compute them now.
#     ecs:= ConjugacyClasses( g );
#     tbl:= CharTableHead( g );
# #T would it be reasonable to postpone the computation of power maps,
# #T and later use the characters?
#     if not IsBound( g.exponent ) then
#       g.exponent:= Lcm( Set( tbl.orders ) );
#     fi;
# 
#     if Length(arg)=1 then 
#       rep:= RepresentationsPGroup( g );
#     else
#       rep:= RepresentationsPGroup( g, 1 );
#     fi;
# 
#     lg:=Length(Igs(g));
#     evl:=[];
#     for i in ecs do
#       Elements(i);
# #T really ??
#       ew:=Exponents(g,i.representative);
#       t:=[];
#       for j in [1..lg] do
#         for k in [1..ew[j]] do
#           Add(t,j);
#         od;
#       od;
#       Add(evl,t);
#     od;
# 
#     Ee:=E(rep.exponent);
#     for i in rep.lin do
#       ni:= [];
#       for j in evl do
#         t:= 0;
#         for k in j do
#           t:= t+i[k];
#         od;
#         Add(ni,Ee^t);
#       od;
#       if not ni in tbl.irreducibles then
#         Add( tbl.irreducibles, ni );
#       fi;
#     od;
#     for i in rep.nonlin do
#       ni:=[];
#       al:=Length(i[1].perm);
#       for j in evl do 
#         t:=rec(perm:=[1..Length(i[1].perm)]);
#         t.diag:=t.perm*0;
#         tt:=0;
#         for k in j do
#           t:=mulmoma(t,i[k]);
#         od;
#         for k in [1..Length(i[1].perm)] do
#           if t.perm[k]=k then
#             tt:= tt+Ee^t.diag[k];
#           fi;
#         od;
#         Add(ni,tt);
#       od;
#       if not ni in tbl.irreducibles then
#         Add( tbl.irreducibles, ni );
#       fi;
#     od;
# 
#     if not IsBound(tbl.identifier) then 
#       if IsBound(g.name) then
#         tbl.identifier:=g.name;
#       elif IsBound(Parent(g).name) then
# ??
#         tbl.identifier:=Parent(g).name;
#         for k in g.generators do
#           tbl.identifier:= ConcatenationString(tbl.identifier,"_",String(k));
#         od;
#       else 
#       tbl.identifier:="";
#       fi;
#     fi;
# 
#     if Sum( List( tbl.irreducibles, x -> x[1]*x[1] ), 0 ) <> tbl.size then
#       if Length( arg ) = 1 then
#         Print( "#W  CharTablePGroup: incomplete CharTable\n" );
#       fi;
#     else
#       g.charTable:=tbl;
# #T really ???
#     fi;
#     return tbl;
# end;


#############################################################################
##
#E  ctblsolv.gi . . . . . . . . . . . . . . . . . . . . . . . . . . ends here



