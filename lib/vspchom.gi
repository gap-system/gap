#############################################################################
##
#W  vspchom.gi                  GAP library                     Thomas Breuer
##
#H  @(#)$Id$
##
#Y  Copyright (C)  1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
##  This file contains methods for general linear mappings of finite
##  dimensional free left modules.
##
##  There are two default representations of such general mappings,
##  one by generators and images, the other by two bases and a matrix.
##
##  Note that a matrix is not the appropriate object to represent a general
##  linear mapping if it is not total or not single-valued;
##  moreover, if one does not prescribe images of a basis but of an
##  arbitrary generating system, one does not want to compute a basis at the
##  time the general mapping is formed;
##  finally, the matrix is not appropriate to compute preimages, whereas
##  the general mapping by images behaves symmetrically in this respect.
##
##  (The matrix is best for linear mappings used as arithmetic elements,
##  for mapping elements of the source to the range and back; storing
##  images and preimages avoids the matrix multiplication.)
##
##  1. methods for linear general mappings given by images
##  2. methods for linear mappings given by matrices
##  3. methods for vector spaces of linear mappings
##  4. methods for algebras of linear mappings
##  5. methods for full hom spaces
##
Revision.vspchom_gi :=
    "@(#)$Id$";


#############################################################################
##
##  1. methods for linear general mappings given by images
##

#############################################################################
##
#R  IsLinearGeneralMappingByImagesDefaultRep
##
##  is a default representation of $F$-linear general mappings between two
##  free left modules $V$ and $W$ where $F$ is equal to the left acting
##  domain of $V$ and of $W$.
##
##  (It would be possible to allow situations where $F$ is only contained
##  in the left acting domain of $W$;
##  this would lead to asymmetry w.r.t. taking the inverse general mapping.)
##
##  Defining components are
##
##  'generators' \: \\
##      list of vectors in $V$,
##
##  'genimages' \: \\
##      list of vectors in $W$.
##
##  The general mapping is defined as the linear closure of the relation
##  that joins the $i$-th entry in 'generators' and the $i$-th entry in
##  'genimages'.
##
##  If one wants to compute images, one needs the components
##  'basispreimage' \: \\
##      a basis of the $F$-module generated by 'generators',
##
##  'imagesbasispreimage' \: \\
##      images of the basis vectors of 'basispreimage',
##
##  'corelations' \: \\
##      linearly independent generators for the corelation space,
##      i.e., of the space of all row vectors <r> such that
##      'LinearCombination( <r>, generators )' is zero in $V$.
##      (The corresponding linear combinations of 'genimages'
##      generate the cokernel.)
##
##  If these components are not yet bound, they are computed by
##  'MakeImagesInfoGeneralLinearMappingByImages'.
##  If 'generators' is a *basis* of a free left module then these
##  components can be entered without extra work.
##
##  If one wants to compute preimages, one needs the components
##  'basisimage' \: \\
##      a basis of the $F$-module generated by 'genimages',
##
##  'preimagesbasisimage' \: \\
##      preimages of the basis vectors of 'basisimage',
##
##  'relations' \: \\
##      linearly independent generators for the relation space,
##      i.e., of the space of all row vectors <r> such that
##      'LinearCombination( <r>, genimages )' is zero in $W$.
##      (The corresponding linear combinations of 'generators'
##      generate the kernel.)
##
##  If these components are not yet bound, they are computed by
##  'MakePreImagesInfoGeneralLinearMappingByImages'.
##  If 'genimages' is a *basis* of a free left module then these
##  components can be entered without extra work.
##
##  Computed images and preimages of free left modules under linear mappings
##  are always free left modules.
##  If one needs more structure (e.g., that of an algebra) for an image or
##  preimage then the linear mapping must have a special representation.
##
##  Note that the inverse general mapping of a linear mapping defined by
##  images is best handled if it uses the default method,
##  since such an inverse general mapping delegates the tasks of computing
##  (pre)images to the original general mapping.
##  So the (pre)images info is computed only once.
#T  but what about sums of such mappings?
#T  better try to share info also in this case?
#T  (share a list that is filled with the info later?)
##
IsLinearGeneralMappingByImagesDefaultRep := NewRepresentation(
    "IsLinearGeneralMappingByImagesDefaultRep",
    IsLeftModuleGeneralMapping and IsAdditiveElementWithInverse
    and IsAttributeStoringRep,
    [ "basisimage", "preimagesbasisimage", "corelations",
      "basispreimage", "imagesbasispreimage", "relations",
      "generators", "genimages" ] );


#############################################################################
##
#M  LeftModuleGeneralMappingByImages( <S>, <R>, <gens>, <imgs> )
##
InstallMethod( LeftModuleGeneralMappingByImages,
    "method for two free left modules and two lists",
    true,
    [ IsFreeLeftModule, IsFreeLeftModule, IsList, IsList ], 0,
    function( S, R, gens, imgs )

    local map;        # general mapping from <S> to <R>, result

    # Check the arguments.
    if   Length( gens ) <> Length( imgs )  then
      Error( "<gens> and <imgs> must have the same length" );
    elif not IsSubset( S, gens ) then
      Error( "<gens> must lie in <S>" );
    elif not IsSubset( R, imgs ) then
      Error( "<imgs> must lie in <R>" );
    elif LeftActingDomain( S ) <> LeftActingDomain( R ) then
      Error( "<S> and <R> must have same left acting domain" );
    fi;

    # Make the general mapping.
    map:= Objectify( KindOfDefaultGeneralMapping( S, R, 
                             IsSPGeneralMapping
                         and RespectsAddition
                         and RespectsAdditiveInverses
                         and RespectsScalarMultiplication
                         and IsLinearGeneralMappingByImagesDefaultRep ),
                     rec( 
                          generators := gens,
                          genimages  := imgs
                         ) );

    # Handle the case that 'gens' is a basis.
    if IsBasis( gens ) then
      map!.basispreimage       := gens;
      map!.imagesbasispreimage := imgs;
      map!.corelations         := Immutable( [] );
    fi;

    # Handle the case that 'imgs' is a basis.
    if IsBasis( imgs ) then
      map!.basisimage          := imgs;
      map!.preimagesbasisimage := gens;
      map!.relations           := Immutable( [] );
    fi;

    # return the general mapping
    return map;
    end );


#############################################################################
##
#M  LeftModuleHomomorphismByImages( <S>, <R>, <gens>, <imgs> )
##
InstallMethod( LeftModuleHomomorphismByImages,
    "method for two left modules and two lists",
    true,
    [ IsFreeLeftModule, IsFreeLeftModule, IsList, IsList ], 0,
    function( S, R, gens, imgs )
    local map;        # homomorphism from <source> to <range>, result
    map:= LeftModuleGeneralMappingByImages( S, R, gens, imgs );
    SetIsSingleValued( map );
    SetIsTotal( map );
    return map;
    end );


#############################################################################
##
#M  ImagesSource( <map> ) . . . . . . . . . . . . . . . . for linear g.m.b.i.
##
InstallMethod( ImagesSource,
    "method for a linear g.m.b.i.",
    true,
    [ IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep ], 0,
    function( map )
    local R;
    if IsBound( map!.basisimage ) then
      return UnderlyingLeftModule( map!.basisimage );
    else
      R:= Range( map );
      return LeftModuleByGenerators( LeftActingDomain( R ),
                                     map!.genimages,
                                     Zero( R ) );
    fi;
    end );


#############################################################################
##
#M  PreImagesRange( <map> ) . . . . . . . . . . . . . . . for linear g.m.b.i.
##
InstallMethod( PreImagesRange,
    "method for a linear g.m.b.i.",
    true,
    [ IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep ], 0,
    function( map )
    local S;
    if IsBound( map!.basispreimage ) then
      return UnderlyingLeftModule( map!.basispreimage );
    else
      S:= Source( map );
      return LeftModuleByGenerators( LeftActingDomain( S ),
                                     map!.generators,
                                     Zero( S ) );
    fi;
    end );


#############################################################################
##
#F  MakeImagesInfoLinearGeneralMappingByImages( <map> )
##
##  Provide the information for computing images, that is, set up
##  the components 'basispreimage', 'imagesbasispreimage', 'corelations'.
##
MakeImagesInfoLinearGeneralMappingByImages := function( map )

    local preimage,
          ech,
          B;

    preimage:= PreImagesRange( map );

    if IsGaussianRowSpaceRep( Source( map ) ) then
#T operation MakeImagesInfo( map, source )
#T to leave this to the method selection ?
#T or flag 'IsFromGaussianSpace' ?

      # The images of the basis vectors are obtained on
      # forming the linear combinations of images of generators
      # given by 'ech.coeffs'.
  
      ech:= SemiEchelonMatTransformation( map!.generators );
      map!.basispreimage       := Immutable( SemiEchelonBasisByGeneratorsNC(
                                      preimage, ech.vectors ) );
      map!.corelations         := Immutable( ech.relations );
      map!.imagesbasispreimage := Immutable( ech.coeffs * map!.genimages );

    else

      # Delegate the work to the associated row space.
      B:= BasisOfDomain( preimage );
      ech:= SemiEchelonMatTransformation( List( map!.generators,
                     x -> Coefficients( B, x ) ) );
      map!.basispreimage       := Immutable( BasisByGeneratorsNC(
                                      preimage,
                                      List( ech.vectors,
                                        x -> LinearCombination( B, x ) ) ) );
      map!.corelations         := Immutable( ech.relations );
      map!.imagesbasispreimage := Immutable( LinearCombination(
                                      map!.genimages, ech.coeffs ) );

    fi;
end;


#############################################################################
##
#F  MakePreImagesInfoLinearGeneralMappingByImages( <map> )
##
##  Provide the information for computing preimages, that is, set up
##  the components 'basisimage', 'preimagesbasisimage', 'relations'.
##
MakePreImagesInfoLinearGeneralMappingByImages := function( map )

    local image,
          ech,
          B;

    image:= ImagesSource( map );

    if IsGaussianRowSpaceRep( Range( map ) ) then

      # The preimages of the basis vectors are obtained on
      # forming the linear combinations of preimages of genimages
      # given by 'ech.coeffs'.
  
      ech:= SemiEchelonMatTransformation( map!.genimages );
      map!.basisimage          := Immutable( SemiEchelonBasisByGeneratorsNC(
                                      image, ech.vectors ) );
      map!.relations           := Immutable( ech.relations );
      map!.preimagesbasisimage := Immutable( ech.coeffs * map!.generators );

    else

      # Delegate the work to the associated row space.
      B:= BasisOfDomain( image );
      ech:= SemiEchelonMatTransformation( List( map!.genimages,
                     x -> Coefficients( B, x ) ) );
      map!.basisimage          := Immutable( BasisByGeneratorsNC(
                                      image,
                                      List( ech.vectors,
                                        x -> LinearCombination( B, x ) ) ) );
      map!.relations           := Immutable( ech.relations );
      map!.preimagesbasisimage := Immutable( List( ech.coeffs,
                                      row -> LinearCombination(
                                                 row, map!.generators ) ) );

    fi;
end;


#############################################################################
##
#M  CoKernelOfAdditiveGeneralMapping( <map> ) . . .  for left module g.m.b.i.
##
InstallMethod( CoKernelOfAdditiveGeneralMapping,
    "method for left module g.m.b.i.",
    true,
    [ IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep ], 0,
    function( map )
    local genimages, R;

    # Form the linear combinations of the basis vectors for the
    # corelation space with the 'genimages' of 'map'.

    if not IsBound( map!.corelations ) then
      MakeImagesInfoLinearGeneralMappingByImages( map );
    fi;
    genimages:= map!.genimages;
    R:= Range( map );
    return LeftModuleByGenerators( LeftActingDomain( R ),
               List( map!.corelations,
                     r -> LinearCombination( genimages, r ) ),
               Zero( R ) );
    end );


#############################################################################
##
#M  IsSingleValued( <map> ) . . . . . . . . . . . .  for left module g.m.b.i.
##
InstallMethod( IsSingleValued,
    "method for left module g.m.b.i.",
    true,
    [ IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep ], 0,
    function( map )
    local genimages;

    if not IsBound( map!.corelations ) then
      MakeImagesInfoLinearGeneralMappingByImages( map );
    fi;
    genimages:= map!.genimages;
    return ForAll( map!.corelations,
                   r -> IsZero( LinearCombination( genimages, r ) ) );
    end );


#############################################################################
##
#M  KernelOfAdditiveGeneralMapping( <map> ) . . . .  for left module g.m.b.i.
##
InstallMethod( KernelOfAdditiveGeneralMapping,
    "method for left module g.m.b.i.",
    true,
    [ IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep ], 0,
    function( map )
    local generators, S;

    # Form the linear combinations of the basis vectors for the
    # relation space with the 'generators' of 'map'.

    if not IsBound( map!.relations ) then
      MakePreImagesInfoLinearGeneralMappingByImages( map );
    fi;
    generators:= map!.generators;
    S:= Source( map );
    return LeftModuleByGenerators( LeftActingDomain( S ),
               List( map!.relations,
                     r -> LinearCombination( generators, r ) ),
               Zero( S ) );
    end );


#############################################################################
##
#M  IsInjective( <map> )  . . . . . . . . . . . . .  for left module g.m.b.i.
##
InstallMethod( IsInjective,
    "method for left module g.m.b.i.",
    true,
    [ IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep ], 0,
    function( map )
    local generators;

    if not IsBound( map!.relations ) then
      MakePreImagesInfoLinearGeneralMappingByImages( map );
    fi;
    generators:= map!.generators;
    return ForAll( map!.relations,
                   r -> IsZero( LinearCombination( generators, r ) ) );
    end );


#############################################################################
##
#M  ImagesRepresentative( <map>, <elm> )  . . . . .  for left module g.m.b.i.
##
InstallMethod( ImagesRepresentative,
    "method for left module g.m.b.i., and element",
    FamSourceEqFamElm,
    [ IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep,
      IsObject ], 0,
    function( map, elm )
    if not IsBound( map!.basispreimage ) then
      MakeImagesInfoLinearGeneralMappingByImages( map );
    fi;
    elm:= Coefficients( map!.basispreimage, elm );
    if elm = fail then
      return fail;
    fi;
    return LinearCombination( map!.imagesbasispreimage, elm );
    end );


#############################################################################
##
#M  PreImagesRepresentative( <map>, <elm> ) . . . .  for left module g.m.b.i.
##
InstallMethod( PreImagesRepresentative,
    "method for left module g.m.b.i., and element",
    FamRangeEqFamElm,
    [ IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep,
      IsObject ], 0,
    function( map, elm )
    if not IsBound( map!.basisimage ) then
      MakePreImagesInfoLinearGeneralMappingByImages( map );
    fi;
    elm:= Coefficients( map!.basisimage, elm );
    if elm = fail then
      return fail;
    fi;
    return LinearCombination( map!.preimagesbasisimage, elm );
    end );


#############################################################################
##
#M  PrintObj( <map> ) . . . . . . . . . . . . . . .  for left module g.m.b.i.
##
InstallMethod( PrintObj,
    "method for a left module g.m.b.i",
    true,
    [ IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep ], 0,
    function( map )
    Print( map!.generators, " -> ", map!.genimages );
    end );


#############################################################################
##
#M  \*( <c>, <map> )  . . . . . . . . . . . .  for scalar and linear g.m.b.i.
##
InstallMethod( \*,
    "method for scalar and linear g.m.b.i.",
    true,
    [ IsMultiplicativeElement,
      IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep ], 0,
    function( scalar, map )

    local mult,   # the multiple of 'map', result
          F;      # left acting domain

    # Check the scalar.
    # (Maybe it is in fact another mapping, and we want to compose.)
    if     not IsInt( scalar )
       and not IsElmsColls( FamilyObj( scalar ),
                   FamilyObj( LeftActingDomain( Range( map ) ) ) ) then
      TryNextMethod();
    fi;

    # Construct the linear general mapping (if possible).
    mult:= LeftModuleGeneralMappingByImages(
               Source( map ), Range( map ), map!.generators,
               List( map!.genimages, v -> scalar * v ) );

    # Maintain info on the preimage side of the general mapping.
    if IsBound( map!.basispreimage ) then
      mult!.basispreimage       := map!.basispreimage;
      mult!.imagesbasispreimage := Immutable(
          List( map!.imagesbasispreimage, v -> scalar * v ) );
      mult!.corelations         := map!.corelations;
    fi;

    # Being a mapping is preserved by scalar multiplication.
    if HasIsSingleValued( map ) then
      SetIsSingleValued( mult, IsSingleValued( map ) );
    fi;
    if HasIsTotal( map ) then
      SetIsTotal( mult, IsTotal( map ) );
    fi;

    # If the scalar is invertible in the left acting domain of the source
    # then surjectivity and injectivity are maintained as well as the image.
    F:= LeftActingDomain( Source( map ) );
    if scalar in F and IsUnit( F, scalar ) then

      if HasIsInjective( map ) then
        SetIsInjective( mult, IsInjective( map ) );
      fi;
      if HasIsSurjective( map ) then
        SetIsSurjective( mult, IsSurjective( map ) );
      fi;

      if IsBound( map!.basisimage ) then
        scalar:= Inverse( scalar );
        mult!.basisimage          := map!.basisimage;
        mult!.preimagesbasisimage := Immutable(
            List( map!.preimagesbasisimage, v -> scalar * v ) );
        mult!.relations           := map!.relations;
      fi;

    fi;

    return mult;
    end );


#############################################################################
##
#M  AdditiveInverse( <map> )  . . . . . . . . . . . . . . for linear g.m.b.i.
##
InstallMethod( AdditiveInverse,
    "method for linear g.m.b.i.",
    true,
    [ IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep ], 0,
    function( map )

    local ainv;   # the additive inverse of 'map', result

    # Construct the linear general mapping (if possible).
    ainv:= LeftModuleGeneralMappingByImages(
               Source( map ), Range( map ), map!.generators,
               List( map!.genimages, AdditiveInverse ) );

    # Maintain images and preimages info.
    if IsBound( map!.basispreimage ) then
      ainv!.basispreimage       := map!.basispreimage;
      ainv!.imagesbasispreimage := Immutable(
          List( map!.imagesbasispreimage, AdditiveInverse ) );
      ainv!.corelations         := map!.corelations;
    fi;
    if IsBound( map!.basisimage ) then
      ainv!.basisimage          := map!.basisimage;
      ainv!.preimagesbasisimage := Immutable(
          List( map!.preimagesbasisimage, AdditiveInverse ) );
      ainv!.relations           := map!.relations;
    fi;

    # Being a mapping is preserved by scalar multiplication.
    if HasIsSingleValued( map ) then
      SetIsSingleValued( ainv, IsSingleValued( map ) );
    fi;
    if HasIsTotal( map ) then
      SetIsTotal( ainv, IsTotal( map ) );
    fi;

    # Surjectivity and injectivity are maintained.
    if HasIsInjective( map ) then
      SetIsInjective( ainv, IsInjective( map ) );
    fi;
    if HasIsSurjective( map ) then
      SetIsSurjective( ainv, IsSurjective( map ) );
    fi;

    return ainv;
    end );


#############################################################################
##
#T  \<( <map1>, <map2> )
##
##  method for two linear mappings from Gaussian spaces, use canonical bases?
##


#############################################################################
##
#M  CompositionMapping2( <map2>, map1> )   for left mod. hom. & lin. g.m.b.i.
##
InstallMethod( CompositionMapping2,
    "method for left module hom. and linear g.m.b.i.",
    FamSource1EqFamRange2,
    [ IsLeftModuleHomomorphism,
      IsLeftModuleGeneralMapping
      and IsLinearGeneralMappingByImagesDefaultRep ], 0,
    function( map2, map1 )
    local comp,        # composition of <map2> and <map1>, result
          gens,
          genimages;

    # Check that the linear mappings can be composed.

    # Compute images for the generators of 'map1'.
    if     IsLinearGeneralMappingByImagesDefaultRep( map2 )
       and map1!.genimages = map2!.generators then

      gens      := map1!.generators;
      genimages := map2!.genimages;

    else

      gens:= map1!.generators;
      genimages:= List( map1!.genimages,
                        v -> ImagesRepresentative( map2, v ) );

    fi;

    # Construct the linear general mapping.
    comp:= LeftModuleGeneralMappingByImages(
               Source( map1 ), Range( map2 ), gens, genimages );

    # Maintain images info (only if 'gens' is not a basis).
    if     IsLinearGeneralMappingByImagesDefaultRep( comp )
       and not IsBound( comp!.basispreimage  )
       and IsBound( map1!.basispreimage ) then
      comp!.basispreimage       := map1!.basispreimage;
      comp!.corelations         := map1!.corelations;
      comp!.imagesbasispreimage := Immutable(
          List( map1!.imagesbasispreimage,
                v -> ImagesRepresentative( map2, v ) ) );
    fi;

    # Return the composition.
    return comp;
    end );


#############################################################################
##
#M  \+( <map1>, map2> ) . . . . . . . . . . . . . . . for two linear g.m.b.i.
##
##  If both general mappings respect zero, additive inverses, scalar
##  multiplication then the sum also does.
##  
SumOfGMBIAndGeneralMapping := function( map1, map2 )

    local gens,
          genimages,
          sum;

    # Check that the linear mappings can be added.
    if    Source( map1 ) <> Source( map2 )
       or Range( map1 ) <> Range( map2 ) then
      Error( "<map1> and <map2> must have same source and range" );
    elif  PreImagesRange( map1 ) <> PreImagesRange( map2 )
       or ImagesSource( map1 ) <> ImagesSource( map2 ) then
      Error( "<map1> and <map2> must have same (pre)image" );
    fi;

    if     IsLinearGeneralMappingByImagesDefaultRep( map2 )
       and map1!.generators = map2!.generators then

      # If the generators in both general mappings are the same,
      # it suffices to add the images.
      gens      := map1!.generators;
      genimages := map1!.genimages + map2!.genimages;

    else

      # Compute images of the generators of 'map1' under 'map2'.
      # (Note that both general mappings must be described in terms of
      # 'generators' in order to keep the meaning of 'corelations'.)
      gens:= map1!.generators;
      genimages:=   map1!.genimages
                  + List( map1!.generators,
                          v -> ImagesRepresentative( map2, v ) );

    fi;

    # Construct the linear general mapping.
    sum:= LeftModuleGeneralMappingByImages(
              Source( map1 ), Range( map1 ), gens, genimages );

    # Maintain images info (only if 'gens' is not a basis).
    if     IsLinearGeneralMappingByImagesDefaultRep( sum )
       and IsLinearGeneralMappingByImagesDefaultRep( map2 )
       and not IsBound( sum!.basispreimage  )
       and IsBound( map1!.basispreimage )
       and IsBound( map2!.basispreimage )
       and map1!.basispreimage = map2!.basispreimage then
      sum!.basispreimage       := map1!.basispreimage;
      sum!.corelations         := map1!.corelations;
      sum!.imagesbasispreimage :=
          map1!.imagesbasispreimage + map2!.imagesbasispreimage;
    fi;

    # Return the sum.
    return sum;
end;


InstallOtherMethod( \+,
    "method for linear g.m.b.i. and general mapping",
    IsIdentical,
    [ IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep,
      IsGeneralMapping ], 0,
    SumOfGMBIAndGeneralMapping );

InstallOtherMethod( \+,
    "method for general mapping and linear g.m.b.i.",
    IsIdentical,
    [ IsGeneralMapping,
      IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep ], 0,
    function( map1, map2 )
    return SumOfGMBIAndGeneralMapping( map2, map1 );
    end );


#############################################################################
##
#M  \+( <map1>, <map2> )  . . . . . . . . . for two linear mappings by images
##
##  The method for (total and single-valued general) mappings takes
##  advantage from the fact that 'generators' and 'basispreimage' components
##  need not be distinguished since the 'corelations' component is empty.
##  
SumOfMBIAndMapping := function( map1, map2 )

    local gens,
          genimages,
          sum;

    # Check that the linear mappings can be added.
    if    Source( map1 ) <> Source( map2 )
       or Range( map1 ) <> Range( map2 ) then
      Error( "<map1> and <map2> must have same source and range" );
    elif  PreImagesRange( map1 ) <> PreImagesRange( map2 )
       or ImagesSource( map1 ) <> ImagesSource( map2 ) then
      Error( "<map1> and <map2> must have same (pre)image" );
    fi;

    if     IsBound( map1!.basispreimage ) then

      # Use the basis in the construction.
      gens:= map1!.basispreimage;

      if     IsLinearGeneralMappingByImagesDefaultRep( map2 )
         and IsBound( map2!.basispreimage )
         and map1!.basispreimage = map2!.basispreimage then

        genimages := map1!.imagesbasispreimage + map2!.imagesbasispreimage;

      else

        genimages:=   map1!.imagesbasispreimage
                    + List( gens,
                            v -> ImagesRepresentative( map2, v ) );

      fi;

    elif     IsLinearGeneralMappingByImagesDefaultRep( map2 )
         and map1!.generators = map2!.generators then

      # If the generators in both general mappings are the same,
      # it suffices to add the images.
      gens      := map1!.generators;
      genimages := map1!.genimages + map2!.genimages;

    else

      # Compute images of the generators of 'map1' under 'map2'.
      # (Note that both general mappings must be described in terms of
      # 'generators' in order to keep the meaning of 'corelations'.)
      gens:= map1!.generators;
      genimages:=   map1!.genimages
                  + List( map1!.generators,
                          v -> ImagesRepresentative( map2, v ) );

    fi;

    # Construct the linear mapping.
    sum:= LeftModuleHomomorphismByImages(
              Source( map1 ), Range( map1 ), gens, genimages );

    # Return the sum.
    return sum;
end;


InstallOtherMethod( \+,
    "method for linear m.b.i. and mapping",
    IsIdentical,
    [ IsMapping and IsLinearGeneralMappingByImagesDefaultRep,
      IsMapping ], 0,
    SumOfMBIAndMapping );

InstallOtherMethod( \+,
    "method for mapping and linear m.b.i.",
    IsIdentical,
    [ IsMapping,
      IsMapping and IsLinearGeneralMappingByImagesDefaultRep ], 0,
    function( map1, map2 )
    return SumOfMBIAndMapping( map2, map1 );
    end );


#############################################################################
##
##  2. methods for linear mappings given by matrices
##


#############################################################################
##
#R  IsLinearMappingByMatrixDefaultRep
##
##  is another default representation of $F$-linear mappings between
##  two free left modules $V$ and $W$ where $F$ is equal to the left acting
##  domain of $V$ and of $W$.
##
##  Defining components are
##
##  'basissource' \: \\
##      basis of $V$,
##
##  'basisrange' \: \\
##      basis of $W$,
##
##  'matrix' \: \\
##      matrix over $F$, of dimensions $\dim(V)$ times $\dim(W)$.
##
##  The mapping is defined as follows.
##  The image of a vector in $V$ has coefficients
##  'Coefficients( <map>!.basissource <v> ) * <map>!.matrix'
##  w.r.t. '<map>!.basisrange'.
##
##  If one wants to compute preimages, one needs the components
##  'basisimage' \: \\
##      basis of the image of <map>,
##
##  'preimagesbasisimage' \: \\
##      preimages of the basis vectors of 'basisimage',
##
##  'relations' \: \\
##      linearly independent generators for the relation space,
##      i.e., of the left null space of '<map>!.matrix'.
##      (The corresponding linear combinations of 'basissource'
##      generate the kernel.)
##
##  If these components are not yet bound, they are computed by
##  'MakePreImagesInfoLinearMappingByMatrix'.
##
##  Computed images and preimages of free left modules under linear mappings
##  are always free left modules.
##  If one needs more structure (e.g., that of an algebra) for an image or
##  preimage then the linear mapping must have a special representation.
##
##  Note that the inverse general mapping of a linear mapping defined by
##  a matrix is best handled if it uses the default method,
##  since such an inverse general mapping delegates the tasks of computing
##  (pre)images to the original general mapping.
##  So the (pre)images info is computed only once.
#T  but what about sums of such mappings?
#T  better try to share info also in this case?
#T  (share a list that is filled with the info later?)
##
IsLinearMappingByMatrixDefaultRep := NewRepresentation(
    "IsLinearMappingByMatrixDefaultRep",
    IsAdditiveElementWithInverse and IsAttributeStoringRep,
    [ "basissource", "basisrange", "matrix",
      "basisimage", "preimagesbasisimage", "relations" ] );


#############################################################################
##
#M  LeftModuleHomomorphismByMatrix( <BS>, <matrix>, <BR> )
##
##  is the total and single-valued linear general mapping with <BS> a basis
##  of the source and <BR> a basis of the range, and the rows of the matrix
##  <matrix> being the coefficients vectors of the images of <BS> w.r.t.
##  <BR>.
##
InstallMethod( LeftModuleHomomorphismByMatrix,
    "method for two bases of free left modules and a matrix",
    true,
    [ IsBasis, IsMatrix, IsBasis ], 0,
    function( BS, matrix, BR )

    local S, R, map;

    S:= UnderlyingLeftModule( BS );
    R:= UnderlyingLeftModule( BR );

    # Check the arguments.
    if   Length( BS ) <> Length( matrix )  then
      Error( "<BS> and <matrix> must have the same length" );
    elif Length( BR ) <> Length( matrix[1] )  then
      Error( "<BR> and <matrix>[1] must have the same length" );
    elif LeftActingDomain( S ) <> LeftActingDomain( R ) then
      Error( "<S> and <R> must have same left acting domain" );
    fi;
#T check entries of the matrix?

    # Make the mapping.
    map:= Objectify( KindOfDefaultGeneralMapping( S, R, 
                             IsSPGeneralMapping
                         and IsSingleValued
                         and IsTotal
                         and RespectsAddition
                         and RespectsAdditiveInverses
                         and RespectsScalarMultiplication
                         and IsLinearMappingByMatrixDefaultRep ),
                     rec( 
                          basissource := BS,
                          matrix      := Immutable( matrix ),
                          basisrange  := BR
                         ) );

    # return the mapping
    return map;
    end );


#############################################################################
##
#F  MakePreImagesInfoLinearMappingByMatrix( <map> )
##
##  Provide the information for computing preimages, that is, set up
##  the components 'basisimage', 'preimagesbasisimage', 'relations'.
##
MakePreImagesInfoLinearMappingByMatrix := function( map )

    local ech,
          B;

    ech:= SemiEchelonMatTransformation( map!.matrix );
    B:= BasisOfDomain( Range( map ) );
    map!.basisimage          := Immutable( BasisByGeneratorsNC(
                                    ImagesSource( map ),
                                    List( ech.vectors,
                                      x -> LinearCombination( B, x ) ) ) );
    map!.relations           := Immutable( ech.relations );

    map!.preimagesbasisimage := Immutable( List( ech.coeffs,
                                    row -> LinearCombination(
                                               map!.basissource, row ) ) );
end;


#############################################################################
##
#M  KernelOfAdditiveGeneralMapping( <map> ) . . . . .  for left module m.b.m.
##
InstallMethod( KernelOfAdditiveGeneralMapping,
    "method for left module m.b.m.",
    true,
    [ IsGeneralMapping and IsLinearMappingByMatrixDefaultRep ], 0,
    function( map )
    local generators, S;

    # Form the linear combinations of the basis vectors for the
    # relation space with the 'basissource' of 'map'.

    if not IsBound( map!.relations ) then
      MakePreImagesInfoLinearMappingByMatrix( map );
    fi;
    generators:= BasisVectors( map!.basissource );
    S:= Source( map );
    return LeftModuleByGenerators( LeftActingDomain( S ),
               List( map!.relations,
                     r -> LinearCombination( generators, r ) ),
               Zero( S ) );
    end );


#############################################################################
##
#M  IsInjective( <map> )  . . . . . . . . . . . . . .  for left module m.b.m.
##
InstallMethod( IsInjective,
    "method for left module m.b.m.",
    true,
    [ IsGeneralMapping and IsLinearMappingByMatrixDefaultRep ], 0,
    function( map )
    local generators;

    if not IsBound( map!.relations ) then
      MakePreImagesInfoLinearMappingByMatrix( map );
    fi;
    generators:= BasisVectors( map!.basissource );
    return ForAll( map!.relations,
                   r -> IsZero( LinearCombination( generators, r ) ) );
    end );


#############################################################################
##
#M  ImagesRepresentative( <map>, <elm> )  . . . . . .  for left module m.b.m.
##
InstallMethod( ImagesRepresentative,
    "method for left module m.b.m., and element",
    FamSourceEqFamElm,
    [ IsGeneralMapping and IsLinearMappingByMatrixDefaultRep,
      IsObject ], 0,
    function( map, elm )
    elm:= Coefficients( map!.basissource, elm );
    if elm <> fail then
      elm:= LinearCombination( map!.basisrange, elm * map!.matrix );
    fi;
    return elm;
    end );


#############################################################################
##
#M  PreImagesRepresentative( <map>, <elm> ) . . . . .  for left module m.b.m.
##
InstallMethod( PreImagesRepresentative,
    "method for left module m.b.m., and element",
    FamRangeEqFamElm,
    [ IsGeneralMapping and IsLinearMappingByMatrixDefaultRep,
      IsObject ], 0,
    function( map, elm )
    if not IsBound( map!.basisimage ) then
      MakePreImagesInfoLinearMappingByMatrix( map );
    fi;
    elm:= Coefficients( map!.basisimage, elm );
    if elm = fail then
      return fail;
    fi;
    return LinearCombination( map!.preimagesbasisimage, elm );
    end );


#############################################################################
##
#M  PrintObj( <map> ) . . . . . . . . . . . . . . . .  for left module m.b.m.
##
InstallMethod( PrintObj,
    "method for a left module m.b.m.",
    true,
    [ IsGeneralMapping and IsLinearMappingByMatrixDefaultRep ], 0,
    function( map )
    Print( "<linear mapping by matrix, ",
           UnderlyingLeftModule( map!.basissource ), " -> ",
           UnderlyingLeftModule( map!.basisrange ), ">" );
    end );


#############################################################################
##
#M  NaturalHomomorphismBySubspace( <V>, <triv> )  . . . for free left modules
##
##  Return the identity mapping.
##
InstallMethod( NaturalHomomorphismBySubspace,
    "method for left module and trivial left module",
    IsIdentical,
    [ IsFreeLeftModule, IsFreeLeftModule and IsTrivial ], SUM_FLAGS,
    function( V, W )
    return IdentityMapping( V );
    end );


#############################################################################
##
#M  NaturalHomomorphismBySubspace( <V>, <W> ) . . . for two free left modules
##
##  return a left module m.b.m.
##
InstallMethod( NaturalHomomorphismBySubspace,
    "method for two finite dimensional free left modules",
    IsIdentical,
    [ IsFreeLeftModule, IsFreeLeftModule ], 0,
    function( V, W )

    local F,
          Wvectors,
          mb,
          compl,
          gen,
          B,
          img,
          canbas,
          zero,
          Bimgs,
          nathom;

    # Check that the modules are finite dimensional.
    if not IsFiniteDimensional( V ) or not IsFiniteDimensional( W ) then
      TryNextMethod();
    fi;

    # If 'V' is equal to 'W', return a zero mapping.
    if not IsSubset( V, W ) then
      Error( "<W> must be c ontained in <V>" );
    elif Dimension( V ) = Dimension( W ) then
      return ZeroMapping( V, FullRowModule( LeftActingDomain( V ), 0 ) );
    fi;

    # If the left acting domains are different, adjust them.
    F:= LeftActingDomain( V );
    if F <> LeftActingDomain( W ) then
      F:= Intersection2( F, LeftActingDomain( W ) );
      V:= AsLeftModule( F, V );
      W:= AsLeftModule( F, W );
    fi;

    # Compute a basis of 'V' through a basis of 'W'.
    Wvectors:= BasisVectors( BasisOfDomain( W ) );
    mb:= MutableBasisByGenerators( F, Wvectors );
    compl:= [];
    for gen in BasisVectors( BasisOfDomain( V ) ) do
      if not IsContainedInSpan( mb, gen ) then
        Add( compl, gen );
        CloseMutableBasis( mb, gen );
      fi;
    od;
    B:= BasisByGeneratorsNC( V, Concatenation( Wvectors, compl ) );

    # Compute the linear mapping by images.
    img:= FullRowModule( F, Length( compl ) );
    canbas:= CanonicalBasis( img );
    zero:= Zero( img );
    Bimgs:= Concatenation( List( Wvectors, v -> zero ),
                           BasisVectors( canbas ) );
    nathom:= LeftModuleHomomorphismByMatrix( B, Bimgs, canbas );
#T take a special representation for nat. hom.s,
#T (just compute coefficients, and then choose a subset ...)

    # Enter the preimages info.
    nathom!.basisimage:= canbas;
    nathom!.preimagesbasisimage:= Immutable( compl );
#T relations are not needed if the kernel is known ?

    SetKernelOfAdditiveGeneralMapping( nathom, W );

    return nathom;
    end );


#############################################################################
##
#M  \*( <c>, <map> )  . . . . . . . . . . . . .  for scalar and linear m.b.m.
##
InstallMethod( \*,
    "method for scalar and linear m.b.m.",
    true,
    [ IsMultiplicativeElement,
      IsGeneralMapping and IsLinearMappingByMatrixDefaultRep ], 0,
    function( scalar, map )

    local mult,   # the multiple of 'map', result
          F;      # left acting domain

    # Check the scalar.
    # (Maybe it is in fact another mapping, and we want to compose.)
    if     not IsInt( scalar )
       and not IsElmsColls( FamilyObj( scalar ),
                   FamilyObj( LeftActingDomain( Range( map ) ) ) ) then
      TryNextMethod();
    fi;

    # Construct the linear mapping (if possible).
    mult:= LeftModuleHomomorphismByMatrix(
               map!.basissource,
               scalar * map!.matrix,
               map!.basisrange );

    # If the scalar is invertible in the left acting domain of the source
    # then surjectivity and injectivity are maintained as well as the image.
    F:= LeftActingDomain( Source( map ) );
    if scalar in F and IsUnit( F, scalar ) then

      if HasIsInjective( map ) then
        SetIsInjective( mult, IsInjective( map ) );
      fi;
      if HasIsSurjective( map ) then
        SetIsSurjective( mult, IsSurjective( map ) );
      fi;

      if IsBound( map!.basisimage ) then
        scalar:= Inverse( scalar );
        mult!.basisimage          := map!.basisimage;
        mult!.preimagesbasisimage := Immutable(
            List( map!.preimagesbasisimage, v -> scalar * v ) );
        mult!.relations           := map!.relations;
      fi;

    fi;

    return mult;
    end );


#############################################################################
##
#M  AdditiveInverse( <map> )  . . . . . . . . . . . . . . . for linear m.b.m.
##
InstallMethod( AdditiveInverse,
    "method for linear m.b.m.",
    true,
    [ IsGeneralMapping and IsLinearMappingByMatrixDefaultRep ], 0,
    function( map )

    local ainv;   # the additive inverse of 'map', result

    # Construct the linear general mapping (if possible).
    ainv:= LeftModuleHomomorphismByMatrix(
               map!.basissource,
               AdditiveInverse( map!.matrix ),
               map!.basisrange );

    # Maintain preimages info.
    if IsBound( map!.basisimage ) then
      ainv!.basisimage          := map!.basisimage;
      ainv!.preimagesbasisimage := Immutable(
          List( map!.preimagesbasisimage, AdditiveInverse ) );
      ainv!.relations           := map!.relations;
    fi;

    # Surjectivity and injectivity are maintained.
    if HasIsInjective( map ) then
      SetIsInjective( ainv, IsInjective( map ) );
    fi;
    if HasIsSurjective( map ) then
      SetIsSurjective( ainv, IsSurjective( map ) );
    fi;

    return ainv;
    end );


#############################################################################
##
#M  CompositionMapping2( <map2>, map1> )  .  for left mod. hom. & lin. m.b.m.
##
InstallMethod( CompositionMapping2,
    "method for left module hom. and linear m.b.m.",
    FamSource1EqFamRange2,
    [ IsLeftModuleHomomorphism,
      IsLeftModuleHomomorphism and IsLinearMappingByMatrixDefaultRep ], 0,
    function( map2, map1 )
    local comp,        # composition of <map1> and <map2>, result
          BR,          # basis of the range of 'map2'
          mat2;        # matrix corresponding to 'map2'

    # Compute images for the generators of 'map1'.
    if     IsLinearMappingByMatrixDefaultRep( map2 )
       and map1!.basisrange = map2!.basissource then

      BR   := map2!.basisrange;
      mat2 := map2!.matrix;

    else

      BR:= Range( map2 );
      if not IsFiniteDimensional( BR ) then
        TryNextMethod();
      fi;
      BR:= BasisOfDomain( BR );
      mat2:= List( BasisVectors( map1!.basisrange ),
                 v -> Coefficients( BR, ImagesRepresentative( map2, v ) ) );

    fi;

    # Construct the linear mapping.
    comp:= LeftModuleHomomorphismByMatrix( map1!.basissource,
               map1!.matrix * mat2, BR );

    # Return the composition.
    return comp;
    end );


#############################################################################
##
#M  \+( <map1>, map2> ) . . . . . . . . . . . . . . . . for two linear m.b.m.
##
##  Two general mappings that respect addition can be added pointwise
##  if their images are equal and their preimages are equal.
##  The sum does also respect addition.
##
##  If both general mappings respect zero, additive inverses, scalar
##  multiplication then the sum also does.
##  
SumOfMBMAndMapping := function( map1, map2 )

    local gens,
          genimages,
          sum;

    # Check that the linear mappings can be added.
    if    Source( map1 ) <> Source( map2 )
       or Range( map1 ) <> Range( map2 ) then
      Error( "<map1> and <map2> must have same source and range" );
    fi;

    if    IsLinearMappingByMatrixDefaultRep( map2 )
       and map1!.basissource = map2!.basissource
       and map1!.basisrange  = map2!.basisrange then

      # If the bases in both mappings are the same,
      # it suffices to add the matrices.
      sum:= LeftModuleHomomorphismByMatrix(
                map1!.basissource,
                map1!.matrix + map2!.matrix,
                map1!.basisrange );

    else

      # Compute images of the generators of 'map1' under 'map2'.
      sum:= LeftModuleHomomorphismByMatrix(
                map1!.basissource,
                map1!.matrix
                + List( BasisVectors( map1!.basissource ),
                        v -> Coefficients( map1!.basisrange,
                                 ImagesRepresentative( map2, v ) ) ),
                map1!.basisrange );

    fi;

    # Return the sum.
    return sum;
end;


InstallOtherMethod( \+,
    "method for linear m.b.m. and mapping",
    IsIdentical,
    [ IsMapping and IsLinearMappingByMatrixDefaultRep,
      IsMapping ], 0,
    SumOfMBMAndMapping );

InstallOtherMethod( \+,
    "method for mapping and linear m.b.m.",
    IsIdentical,
    [ IsMapping,
      IsMapping and IsLinearMappingByMatrixDefaultRep ], 0,
    function( map1, map2 )
    return SumOfMBMAndMapping( map2, map1 );
    end );


#############################################################################
##
#M  \+( <map1>, <map2> )  . . . . for mapping by matrix and mapping by images
##
InstallMethod( \+,
    "method for linear m.b.m. and linear m.b.i.",
    IsIdentical,
    [ IsMapping and IsLinearMappingByMatrixDefaultRep,
      IsMapping and IsLinearGeneralMappingByImagesDefaultRep ], 0,
    SumOfMBMAndMapping );

InstallMethod( \+,
    "method for linear m.b.i. and linear m.b.m.",
    IsIdentical,
    [ IsMapping and IsLinearGeneralMappingByImagesDefaultRep,
      IsMapping and IsLinearMappingByMatrixDefaultRep ], 0,
    function( map1, map2 )
    return SumOfMBMAndMapping( map2, map1 );
    end );


#############################################################################
##
##  3. methods for vector spaces of linear mappings
##


#############################################################################
##
#R  IsLinearMappingsSpaceDefaultRep
##
##  is the representation of vector spaces of linear mappings
##  that are handled via nice bases.
##  The associated basis is computed using the matrices w.r.t. fixed bases
##  of preimage and image.
##
##  'basissource' : \\
##     basis of the source of each mapping in the space
##
##  'basisrange' : \\
##     basis of the range of each mapping in the space
##
##  We have
##  'List( <V>!.basissource,
##         x -> Coefficients( <V>!.basisrange,
##                            ImagesRepresentative( <v>, x ) ) )'
##  the nice vector of $<v> \in <V>$,
##  and
##  'LeftModuleHomomorphismByMatrix( <V>!.basissource,
##                                   <M>,
##                                   <V>!.basisrange )'
##  the ugly vector of the matrix <M>.
##
##  (Note that we cannot expect that the elements of the space are
##  represented via matrices.
##  If they are, and if the bases are the right ones, we may use the
##  stored matrices, of course.)
##
IsLinearMappingsSpaceDefaultRep := NewRepresentation(
    "IsLinearMappingsSpaceDefaultRep",
    IsHandledByNiceBasis,
    [ "basissource", "basisrange" ] );


#############################################################################
##
#M  PrepareNiceFreeLeftModule( <V> )  . . . .  for a space of linear mappings
##
InstallMethod( PrepareNiceFreeLeftModule,
    "method for vector space of linear mappings",
    true,
    [ IsVectorSpace and IsLinearMappingsSpaceDefaultRep ], 0,
    Ignore );


#############################################################################
##
#M  NiceVector( <V>, <v> )  . .  for space of lin. mappings, and lin. mapping
##
##  is the matrix in 'NiceFreeLeftModule( <V> )' that corresponds
##  to the vector <v> of <V>.
##
InstallOtherMethod( NiceVector,
    "method for space of linear mappings, and linear mapping",
    IsCollsElms,
    [ IsFreeLeftModule and IsLinearMappingsSpaceDefaultRep,
      IsMapping ], 0,
    function( V, v )
    local M, i, c;
    M:= [];
    for i in BasisVectors( V!.basissource ) do
      c:= Coefficients( V!.basisrange, ImagesRepresentative( v, i ) );
      if c = fail then
        return fail;
      fi;
      Add( M, c );
    od;
    return M;
    end );


InstallMethod( NiceVector,
    "method for space of linear mappings, and linear mapping by matrix",
    IsCollsElms,
    [ IsFreeLeftModule and IsLinearMappingsSpaceDefaultRep,
      IsMapping and IsLinearMappingByMatrixDefaultRep ], 0,
    function( V, v )
    local M, i, c;
    if V!.basissource = v!.basissource and V!.basisrange = v!.basisrange then
      return v!.matrix;
    else
      TryNextMethod();
    fi;
    end );


#############################################################################
##
#M  UglyVector( <V>, <mat> )  . . .  for space of linear mappings, and matrix
##
InstallMethod( UglyVector,
    "method for space of linear mappings, and matrix",
    true,
    [ IsFreeLeftModule and IsLinearMappingsSpaceDefaultRep, IsMatrix ], 0,
    function( V, mat )
    return LeftModuleHomomorphismByMatrix( V!.basissource,
                                           mat, V!.basisrange );
    end );


#############################################################################
##
#M  MutableBasisByGenerators( <R>, <gens> )
#M  MutableBasisByGenerators( <R>, <gens>, <zero> )
##
##  We choose a mutable basis that stores a mutable basis for a nice module.
##
InstallMethod( MutableBasisByGenerators,
    "method for division ring and collection of linear mappings",
    true,
    [ IsDivisionRing, IsGeneralMappingCollection ], 0,
    MutableBasisViaNiceMutableBasisMethod2 );

InstallOtherMethod( MutableBasisByGenerators,
    "method for division ring, (possibly empty) list, and zero element",
    true,
    [ IsDivisionRing, IsList, IsLeftModuleHomomorphism ], 0,
    MutableBasisViaNiceMutableBasisMethod3 );


#############################################################################
##
#M  LeftModuleByGenerators( <F>, <gens> ) . . create space of linear mappings
##
InstallMethod( LeftModuleByGenerators,
    "method for division ring and collection of linear mappings",
    true,
    [ IsDivisionRing, IsGeneralMappingCollection ] , 0,
    function( F, gens )
    local V, S, R;

    # Check that the mappings have left modules as source and range.
    gens:= AsList( gens );
    if IsEmpty( gens ) then
      Error( "need at least one element" );
    fi;
    S:= Source( gens[1] );
    R:= Range(  gens[1] );
    if    not IsLeftModule( S )
       or not IsLeftModule( R )
       or not ForAll( gens, IsMapping ) then
      TryNextMethod();
    fi;

    # Check that all generators have the same source and range.
    if   ForAny( gens, map -> Source( map ) <> S ) then
      Error( "all mappings in <gens> must have same source" );
    elif ForAny( gens, map -> Range( map ) <> R ) then
      Error( "all mappings in <gens> must have same range" );
    fi;

    # Write 'S' and 'R' over 'F' (necessary for the nice left module).
    if LeftActingDomain( S ) <> F then
      S:= AsLeftModule( F, S );
      R:= AsLeftModule( F, R );
    fi;

    V:= Objectify( NewKind( FamilyObj( gens ),
                                IsFreeLeftModule
                            and IsLeftActedOnByDivisionRing
                            and IsLinearMappingsSpaceDefaultRep
                            and IsAttributeStoringRep ),
                   rec() );
    SetLeftActingDomain( V, F );
    SetGeneratorsOfLeftModule( V, gens );

    V!.basissource := BasisOfDomain( S );
    V!.basisrange  := BasisOfDomain( R );

    return V;
    end );


#############################################################################
##
#M  LeftModuleByGenerators( <F>, <gens>, <zero> )
##
InstallOtherMethod( LeftModuleByGenerators,
    "method for division ring and collection of linear mappings",
    true,
    [ IsDivisionRing, IsHomogeneousList, IsGeneralMapping ], 0,
    function( F, gens, zero )
    local S, R, V;

    # Check that the mappings have left modules as source and range.
    gens:= AsList( gens );
    S:= Source( zero );
    R:= Range(  zero );
    if    not IsLeftModule( S )
       or not IsLeftModule( R )
       or not ForAll( gens, IsMapping ) then
      TryNextMethod();
    fi;

    # Check that all generators have the same source and range.
    if   ForAny( gens, map -> Source( map ) <> S ) then
      Error( "all mappings in <gens> must have same source" );
    elif ForAny( gens, map -> Range( map ) <> R ) then
      Error( "all mappings in <gens> must have same range" );
    fi;

    # Write 'S' and 'R' over 'F' (necessary for the nice left module).
    if LeftActingDomain( S ) <> F then
      S:= AsLeftModule( F, S );
      R:= AsLeftModule( F, R );
    fi;

    V:= Objectify( NewKind( CollectionsFamily( FamilyObj( zero ) ),
                                IsFreeLeftModule
                            and IsLeftActedOnByDivisionRing
                            and IsLinearMappingsSpaceDefaultRep
                            and IsAttributeStoringRep ),
                   rec() );
    SetLeftActingDomain( V, F );
    SetGeneratorsOfLeftModule( V, AsList( gens ) );
    SetZero( V, zero );

    V!.basissource := BasisOfDomain( S );
    V!.basisrange  := BasisOfDomain( R );

    return V;
    end );


#############################################################################
##
##  4. methods for algebras of linear mappings
##


#############################################################################
##
#M  IsFiniteDimensional( <A> )  . . . . .  hom FLMLORs are finite dimensional
##
InstallTrueMethod( IsFiniteDimensional,
    IsFLMLOR and IsLinearMappingsSpaceDefaultRep );


#############################################################################
##
#M  RingByGenerators( <homs> )  . . ring generated by a list of lin. mappings
##
##  If <homs> is a list of linear mappings of finite vector spaces then
##  we construct a hom algebra over the prime field.
##
InstallOtherMethod( RingByGenerators,
    "method for a list of linear mappings of finite vector spaces",
    true,
    [ IsGeneralMappingCollection ], 0,
    function( maps )
    local S;
    maps:= AsList( maps );
    if IsEmpty( maps ) then
      Error( "need at least one element" );
    fi;
    if not ForAll( maps, IsLeftModuleHomomorphism ) then
      TryNextMethod();
    fi;
    S:= Source( maps[1] );
    if     IsVectorSpace( S )
       and IsFFECollection( LeftActingDomain( S ) ) then
      return FLMLORByGenerators( GF( Characteristic( S ) ), maps );
    elif   IsVectorSpace( S )
       and IsCyclotomicsCollection( LeftActingDomain( S ) ) then
      return FLMLORByGenerators( Integers, maps );
    else
      TryNextMethod();
    fi;
    end );


#############################################################################
##
#M  DefaultRingByGenerators( <maps> )  . . ring cont. a list of lin. mappings
##
##  If <maps> is a list of mappings of vector spaces then
##  we construct an algebra over the prime field.
##  (So this may differ from the result of 'RingByGenerators' if the
##  characteristic is zero.)
##
InstallOtherMethod( DefaultRingByGenerators,
    "method for a list of linear mappings of vector spaces",
    true,
    [ IsGeneralMappingCollection ], 0,
    function( maps )
    local S;
    maps:= AsList( maps );
    if IsEmpty( maps ) then
      Error( "need at least one element" );
    fi;
    if not ForAll( maps, IsLeftModuleHomomorphism ) then
      TryNextMethod();
    fi;
    S:= Source( maps[1] );
    if     IsVectorSpace( S )
       and IsFFECollection( LeftActingDomain( S ) ) then
      return FLMLORByGenerators( GF( Characteristic( S ) ), maps );
    elif   IsVectorSpace( S )
       and IsCyclotomicsCollection( LeftActingDomain( S ) ) then
      return FLMLORByGenerators( Rationals, maps );
    else
      TryNextMethod();
    fi;
    end );


#############################################################################
##
#M  RingWithOneByGenerators( <homs> ) . . . . . for a list of linear mappings
##
##  If <homs> is a list of linear mappings of a finite vector space then
##  we construct a hom algebra-with-one over the prime field.
##
InstallOtherMethod( RingWithOneByGenerators,
    "method for a list of linear mappings of finite vector spaces",
    true,
    [ IsGeneralMappingCollection ], 0,
    function( maps )
    local S;
    maps:= AsList( maps );
    if IsEmpty( maps ) then
      Error( "need at least one element" );
    fi;
    if not ForAll( maps, IsLeftModuleHomomorphism ) then
      TryNextMethod();
    fi;
    S:= Source( maps[1] );
    if     IsVectorSpace( S )
       and IsFFECollection( LeftActingDomain( S ) )
       and S = Range( maps[1] ) then
      return FLMLORWithOneByGenerators( GF( Characteristic( S ) ), maps );
    elif   IsVectorSpace( S )
       and IsCyclotomicsCollection( LeftActingDomain( S ) ) then
      return FLMLORWithOneByGenerators( Integers, maps );
    else
      TryNextMethod();
    fi;
    end );


#############################################################################
##
#M  FLMLORByGenerators( <F>, <maps> )
#M  FLMLORByGenerators( <F>, <empty>, <zero> )
#M  FLMLORByGenerators( <F>, <maps>, <zero> )
##
InstallMethod( FLMLORByGenerators,
    "method for division ring and list of linear mappings",
    true,
    [ IsDivisionRing, IsGeneralMappingCollection and IsList ], 0,
    function( F, maps )
    local S, dims, A;

    # Check that all entries in 'maps' are linear mappings with same
    # source and range.
    S:= Source( maps[1] );
    if   ForAny( maps, map -> Source( map ) <> S or Range( map ) <> S ) then
      Error( "all entries in <maps> must have same source and range" );
    elif LeftActingDomain( S ) <> F then
      S:= AsLeftModule( F, S );
    fi;

    A:= Objectify( NewKind( FamilyObj( maps ),
                                IsFLMLOR
                            and IsAttributeStoringRep
                            and IsLinearMappingsSpaceDefaultRep ),
                   rec() );

    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftOperatorRing( A, AsList( maps ) );

    A!.basissource := BasisOfDomain( S );
    A!.basisrange  := A!.basissource;

    # Return the result.
    return A;
    end );

InstallOtherMethod( FLMLORByGenerators,
    "method for division ring, empty list, and zero mapping",
    true,
    [ IsDivisionRing, IsList and IsEmpty, IsGeneralMapping ], 0,
    function( F, empty, zero )
    local dims, A;

    # Check whether this method is the right one.
    if Source( zero ) <> Range( zero ) or not IsZero( zero ) then
      Error( "<zero> must be a zero mapping" );
    fi;

    A:= Objectify( NewKind( CollectionsFamily( FamilyObj( zero ) ),
                                IsFLMLOR
                            and IsAttributeStoringRep
                            and IsLinearMappingsSpaceDefaultRep
                            and IsTrivial ),
                   rec() );
    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftModule( A, empty );
    SetZero( A, zero );

    A!.basissource := BasisOfDomain( Source( zero ) );
    A!.basisrange  := A!.basissource;

    # Return the result.
    return A;
    end );

InstallOtherMethod( FLMLORByGenerators,
    "method for division ring, list of mappings, and mapping",
    true,
    [ IsDivisionRing, IsGeneralMappingCollection and IsList,
      IsGeneralMapping ], 0,
    function( F, maps, zero )
    local S, dims, A;

    # Check whether this method is the right one.
    if Source( zero ) <> Range( zero ) or not IsZero( zero ) then
      Error( "<zero> must be a zero mapping" );
    fi;
    # Check that all entries in 'maps' are linear mappings with same
    # source and range.
    S:= Source( zero );
    if    S <> Range( zero )
       or ForAny( maps, map -> Source( map ) <> S or Range( map ) <> S ) then
      Error( "all entries in <maps> must have same source and range" );
    elif LeftActingDomain( S ) <> F then
      S:= AsLeftModule( F, S );
    fi;

    A:= Objectify( NewKind( FamilyObj( maps ),
                                IsFLMLOR
                            and IsAttributeStoringRep
                            and IsLinearMappingsSpaceDefaultRep ),
                   rec() );

    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftOperatorRing( A, AsList( maps ) );
    SetZero( A, zero );

    A!.basissource := BasisOfDomain( Source( zero ) );
    A!.basisrange  := A!.basissource;

    # Return the result.
    return A;
    end );


#############################################################################
##
#M  FLMLORWithOneByGenerators( <F>, <maps> )
#M  FLMLORWithOneByGenerators( <F>, <empty>, <zero> )
#M  FLMLORWithOneByGenerators( <F>, <maps>, <zero> )
##
InstallMethod( FLMLORWithOneByGenerators,
    "method for division ring and list of linear mappings",
    true,
    [ IsDivisionRing, IsGeneralMappingCollection and IsList ], 0,
    function( F, maps )
    local S, dims, A;

    # Check that all entries in 'maps' are linear mappings with same
    # source and range.
    S:= Source( maps[1] );
    if   ForAny( maps, map -> Source( map ) <> S or Range( map ) <> S ) then
      Error( "all entries in <maps> must have same source and range" );
    elif LeftActingDomain( S ) <> F then
      S:= AsLeftModule( F, S );
    fi;

    A:= Objectify( NewKind( FamilyObj( maps ),
                                IsFLMLORWithOne
                            and IsAttributeStoringRep
                            and IsLinearMappingsSpaceDefaultRep ),
                   rec() );

    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftOperatorRingWithOne( A, AsList( maps ) );

    A!.basissource := BasisOfDomain( S );
    A!.basisrange  := A!.basissource;

    # Return the result.
    return A;
    end );

InstallOtherMethod( FLMLORWithOneByGenerators,
    "method for division ring, empty list, and zero mapping",
    true,
    [ IsDivisionRing, IsList and IsEmpty, IsGeneralMapping ], 0,
    function( F, empty, zero )
    local dims, A;

    # Check whether this method is the right one.
    if Source( zero ) <> Range( zero ) or not IsZero( zero ) then
      Error( "<zero> must be a zero mapping" );
    fi;

    A:= Objectify( NewKind( CollectionsFamily( FamilyObj( zero ) ),
                                IsFLMLORWithOne
                            and IsAttributeStoringRep
                            and IsLinearMappingsSpaceDefaultRep
                            and IsAssociative ),
                   rec() );
    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftOperatorRingWithOne( A, empty );
    SetZero( A, zero );

    A!.basissource := BasisOfDomain( Source( zero ) );
    A!.basisrange  := A!.basissource;

    # Return the result.
    return A;
    end );

InstallOtherMethod( FLMLORWithOneByGenerators,
    "method for division ring, list of mappings, and mapping",
    true,
    [ IsDivisionRing, IsGeneralMappingCollection and IsList,
      IsGeneralMapping ], 0,
    function( F, maps, zero )
    local S, dims, A;

    # Check whether this method is the right one.
    if Source( zero ) <> Range( zero ) or not IsZero( zero ) then
      Error( "<zero> must be a zero mapping" );
    fi;
    # Check that all entries in 'maps' are linear mappings with same
    # source and range.
    S:= Source( zero );
    if    S <> Range( zero )
       or ForAny( maps, map -> Source( map ) <> S or Range( map ) <> S ) then
      Error( "all entries in <maps> must have same source and range" );
    elif LeftActingDomain( S ) <> F then
      S:= AsLeftModule( F, S );
    fi;

    A:= Objectify( NewKind( FamilyObj( maps ),
                                IsFLMLORWithOne
                            and IsAttributeStoringRep
                            and IsLinearMappingsSpaceDefaultRep ),
                   rec() );

    SetLeftActingDomain( A, F );
    SetGeneratorsOfLeftOperatorRingWithOne( A, AsList( maps ) );
    SetZero( A, zero );

    A!.basissource := BasisOfDomain( Source( zero ) );
    A!.basisrange  := A!.basissource;

    # Return the result.
    return A;
    end );


#############################################################################
##
##  5. methods for full hom spaces
##


#############################################################################
##
#M  IsFullHomModule( V )  . . . . . . . . . . .  for space of linear mappings
##
InstallMethod( IsFullHomModule,
    "method for space of linear mappings",
    true,
    [ IsFreeLeftModule and IsLinearMappingsSpaceDefaultRep ], 0,
    V -> Dimension( V ) = Dimension( UnderlyingLeftModule( V!.basissource ) )
             * Dimension( UnderlyingLeftModule( V!.basisrange ) ) );


#############################################################################
##
#M  Dimension( <M> )  . . . . . . . . . for full hom space of linear mappings
##
InstallMethod( Dimension,
    "method for full hom space of linear mappings",
    true,
    [ IsFreeLeftModule and IsLinearMappingsSpaceDefaultRep
      and IsFullHomModule ], 0,
    V ->   Dimension( UnderlyingLeftModule( V!.basissource ) )
         * Dimension( UnderlyingLeftModule( V!.basisrange  ) ) );


#############################################################################
##
#M  Random( <M> ) . . . . . . . . . . . for full hom space of linear mappings
##
InstallMethod( Random,
    "method for full hom space of linear mappings",
    true,
    [ IsFreeLeftModule and IsLinearMappingsSpaceDefaultRep
      and IsFullHomModule ], 0,
    function( M )
    local BS, BR;
    BS:= M!.basissource;
    BR:= M!.basisrange;

    return LeftModuleHomomorphismByMatrix( BS,
               RandomMat( Dimension( UnderlyingLeftModule( BS ) ),
                          Dimension( UnderlyingLeftModule( BR ) ),
                          LeftActingDomain( M ) ),
               BR );
    end );


#############################################################################
##
#M  GeneratorsOfLeftModule( <V> ) . . . for full hom space of linear mappings
##
StandardGeneratorsOfFullHomModule := function( M )

    local BS, BR, R, one, m, n, zeromat, gens, i, j, gen;

    BS:= M!.basissource;
    BR:= M!.basisrange;
    R:= LeftActingDomain( M );
    one:= One( R );
    m:= Dimension( UnderlyingLeftModule( BS ) );
    n:= Dimension( UnderlyingLeftModule( BR ) );
    zeromat:= NullMat( m, n, R );
    gens:= [];
    for i in [ 1 .. m ] do
      for j in [ 1 .. n ] do
        gen:= List( zeromat, ShallowCopy );
        gen[i][j]:= one;
        Add( gens, LeftModuleHomomorphismByMatrix( BS, gen, BR ) );
      od;
    od;

    return gens;
end;

InstallMethod( GeneratorsOfLeftModule,
    "method for full hom space of linear mappings",
    true,
    [ IsFreeLeftModule and IsLinearMappingsSpaceDefaultRep
      and IsFullHomModule ], 0,
    StandardGeneratorsOfFullHomModule );


#############################################################################
##
#M  PrintObj( <M> ) . . . . . . . . . . for full hom space of linear mappings
##
InstallMethod( PrintObj,
    "method for full hom space of linear mappings",
    true,
    [ IsFreeLeftModule and IsLinearMappingsSpaceDefaultRep
      and IsFullHomModule ], SUM_FLAGS,
    function( M )
    if IsIdentical( M!.basissource, M!.basisrange ) then
      Print( "End( ", LeftActingDomain( M ), ", ",
             UnderlyingLeftModule( M!.basissource  ), " )" );
    else
      Print( "Hom( ", LeftActingDomain( M ), ", ",
             UnderlyingLeftModule( M!.basissource ), ", ",
             UnderlyingLeftModule( M!.basisrange  ), " )" );
    fi;
    end );


#############################################################################
##
#M  \in( <v>, <V> ) . . . . . . . . . . for full hom space of linear mappings
##
InstallMethod( \in,
    "method for full hom space of linear mappings",
    IsElmsColls,
    [ IsGeneralMapping,
      IsFreeLeftModule and IsLinearMappingsSpaceDefaultRep
      and IsFullHomModule ], 0,
    function( map, M )
    return     Source( map ) = UnderlyingLeftModule( M!.basissource )
           and Range(  map ) = UnderlyingLeftModule( M!.basisrange  )
           and IsLeftModuleHomomorphism( map );
    end );


#############################################################################
##
#M  IsPseudoCanonicalBasisFullHomModule( <B> )  . . . . for a full hom module
##
InstallMethod( IsPseudoCanonicalBasisFullHomModule,
    "method for a full hom module",
    true,
    [ IsBasis ], 0,
    function( B )
    local V;
    V:= UnderlyingLeftModule( B );
    if IsLinearMappingsSpaceDefaultRep( V ) then
      if not IsFullHomModule( V ) then
        return false;
      fi;
      return List( BasisVectors( B ),
                   map -> List( BasisVectors( V!.basissource ),
                                v -> Coefficients( V!.basisrange,
                                 ImagesRepresentative( map, v ) ) ) )
             = StandardGeneratorsOfFullHomModule( V );
    else
      Error( "do not know what a pseudo canon. basis for <V> is" );
    fi;
    end );


#############################################################################
##
#M  BasisVectors( <B> ) . . . for pseudo canonical basis of a full hom module
##
InstallMethod( BasisVectors,
    "method for pseudo canonical basis of a full hom module",
    true,
    [ IsBasis and IsPseudoCanonicalBasisFullHomModule ], 0,
    B -> StandardGeneratorsOfFullHomModule( UnderlyingLeftModule( B ) ) );


#############################################################################
##
#M  Coefficients( <B>, <m> )   for a pseudo canon. basis of a full hom module
##
InstallOtherMethod( Coefficients,
    "method for pseudo canon. basis of a full hom module, and lin. mapping",
    IsCollsElms,
    [ IsBasis and IsPseudoCanonicalBasisFullHomModule, IsGeneralMapping ], 0,
    function( B, map )
    local V, R;
    V:= UnderlyingLeftModule( B );
    if not IsLinearMappingsSpaceDefaultRep( V ) then
      TryNextMethod();
    fi;
    R:= LeftActingDomain( V );
    if     Source( map ) = UnderlyingLeftModule( V!.basissource )
       and Range(  map ) = UnderlyingLeftModule( V!.basisrange  )
       and IsLeftModuleHomomorphism( map ) then
      return Concatenation(
                  List( BasisVectors( V!.basissource ),
                        v -> Coefficients( V!.basisrange,
                                 ImagesRepresentative( map, v ) ) ) );
    else
      return fail;
    fi;
    end );

InstallMethod( Coefficients,
    "method for pseudo can. basis of full hom module, and lin. m.b.m.",
    IsCollsElms,
    [ IsBasis and IsPseudoCanonicalBasisFullHomModule,
      IsMapping and IsLinearMappingByMatrixDefaultRep ], 0,
    function( B, map )
    local V, R;
    V:= UnderlyingLeftModule( B );
    if not IsLinearMappingsSpaceDefaultRep( V ) then
      TryNextMethod();
    fi;
    R:= LeftActingDomain( V );
    if     map!.basissource = V!.basissource
       and map!.basisrange  = V!.basisrange then
      return Concatenation( map!.matrix );
    elif   Source( map ) = UnderlyingLeftModule( V!.basissource )
       and Range(  map ) = UnderlyingLeftModule( V!.basisrange  ) then
      return Concatenation(
                  List( BasisVectors( V!.basissource ),
                        v -> Coefficients( V!.basisrange,
                                 ImagesRepresentative( map, v ) ) ) );
    else
      return fail;
    fi;
    end );


#############################################################################
##
#M  BasisOfDomain( <M> )  . . . . . . . . . . . . . . . . for full hom module
##
InstallMethod( BasisOfDomain,
    "method for full hom space of linear mappings",
    true,
    [ IsFreeLeftModule and IsFullHomModule ], 100,
    function( V )
    local B;
    B:= Objectify( NewKind( FamilyObj( V ),
                                IsBasis
                            and IsPseudoCanonicalBasisFullHomModule
                            and IsAttributeStoringRep ),
                   rec() );
    SetUnderlyingLeftModule( B, V );
    return B;
    end );


#############################################################################
##
#M  Hom( <F>, <V>, <W> )
##
InstallMethod( Hom,
    "method for division ring and two free left modules",
    true,
    [ IsDivisionRing, IsFreeLeftModule, IsFreeLeftModule ], 0,
    function( F, V, W )
    local M;   # the free module record, result

    if V = W then
      return End( F, V );
    fi;
    if LeftActingDomain( V ) <> F then
      V:= AsLeftModule( F, V );
    fi;
    if LeftActingDomain( W ) <> F then
      W:= AsLeftModule( F, W );
    fi;

    M:= Objectify( NewKind( CollectionsFamily( GeneralMappingsFamily(
                                ElementsFamily( FamilyObj( V ) ),
                                ElementsFamily( FamilyObj( W ) ) ) ),
                                IsFreeLeftModule
                            and IsLinearMappingsSpaceDefaultRep
                            and IsFullHomModule
                            and IsAttributeStoringRep ),
                   rec() );

    SetLeftActingDomain( M, F );

    M!.basissource := BasisOfDomain( V );
    M!.basisrange  := BasisOfDomain( W );

    return M;
    end );


#############################################################################
##
#M  End( <F>, <V> ) . . . . . . . . .  for division ring and free left module
##
##  We use the generators that are also taken for full matrix FLMLORs.
##
InstallMethod( End,
    "method for division ring and space of linear mappings",
    true,
    [ IsDivisionRing, IsFreeLeftModule ], 0,
    function( F, V )

    local n,      # dimension of 'V'
          i,      # loop over the rows
          gens,   # list of generators
          one,    # the identity of the field
          B,      # basis of 'V'
          A;      # algebra, result

    if LeftActingDomain( V ) <> F then
      V:= AsLeftModule( F, V );
    fi;

    n:= Dimension( V );
    gens:= NullMat( n, n, F );
    gens:= [ gens, List( gens, ShallowCopy ) ];
    one:= One( F );

    # Construct the generators.
    gens[1][1][1]:= one;
    gens[2][1][n]:= one;
    for i in [ 2 .. n ] do
      gens[2][i][i-1]:= one;
    od;
    B:= BasisOfDomain( V );
    gens:= List( gens, mat -> LeftModuleHomomorphismByMatrix( B, mat, B ) );

    # Construct the FLMLOR.
    A:= AlgebraWithOneByGenerators( F, gens );
    SetIsFullHomModule( A, true );

    # Return the FLMLOR.
    return A;
    end );


#T InstallMethod( Field, true, [ IsGeneralMappingCollection ], 0, ... );
#T InstallMethod( DefaultField, true, [ IsGeneralMappingCollection ], 0, ... );

#############################################################################
##
#E  vspchom.gi  . . . . . . . . . . . . . . . . . . . . . . . . . . ends here



