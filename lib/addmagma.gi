#############################################################################
##
#W  addmagma.gi                 GAP library                     Thomas Breuer
##
#W  @(#)$Id$
##
#Y  Copyright (C)  1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
Revision.addmagma_gi :=
    "@(#)$Id$";


#############################################################################
##
#M  Print( <A> )  . . . . . . . . . . . . . . . . . . print an additive magma
##
InstallMethod( PrintObj, true, [ IsAdditiveMagma ], 0,
    function( A )
    Print( "AdditiveMagma( ... )" );
    end );

InstallMethod( PrintObj, true,
    [ IsAdditiveMagma and HasGeneratorsOfAdditiveMagma ], 0,
    function( A )
    Print( "AdditiveMagma( ", GeneratorsOfAdditiveMagma( A ), " )" );
    end );


#############################################################################
##
#M  IsTrivial( <A> )  . . . . . . . test whether an additive magma is trivial
##
InstallImmediateMethod( IsTrivial,
    IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagmaWithZero , 0,
    function( A )
    if IsEmpty( GeneratorsOfAdditiveMagmaWithZero( A ) ) then
      return true;
    else
      TryNextMethod();
    fi;
    end );

InstallImmediateMethod( IsTrivial,
    IsAdditiveMagmaWithInverses
    and HasGeneratorsOfAdditiveMagmaWithInverses, 0,
    function( A )
    if IsEmpty( GeneratorsOfAdditiveMagmaWithInverses( A ) ) then
      return true;
    else
      TryNextMethod();
    fi;
    end );


#############################################################################
##
#F  AdditiveMagma( <gens> )
#F  AdditiveMagma( <Fam>, <gens> )
##
AdditiveMagma := function( arg )

    # list of generators
    if Length( arg ) = 1 and IsList( arg[1] ) and 0 < Length( arg[1] ) then
      return AdditiveMagmaByGenerators( arg[1] );

    # family plus list of generators
    elif Length( arg ) = 2 and IsFamily( arg[1] ) and IsList( arg[1] ) then
      return AdditiveMagmaByGenerators( arg[1], arg[2] );

    # generators
    elif 0 < Length( arg ) then
      return AdditiveMagmaByGenerators( arg );
    fi;

    # no argument given, error
    Error("usage: AdditiveMagma(<gens>), AdditiveMagma(<Fam>,<gens>)");
end;


#############################################################################
##
#F  SubadditiveMagma( <M>, <gens> )  add. submagma of <M> generated by <gens>
##
SubadditiveMagma := function( M, gens )
    if not IsAdditiveMagma( M ) then
        Error( "<M> must be a magma" );
    elif IsEmpty( gens ) then
        return SubadditiveMagmaNC( M, gens );
    elif not IsHomogeneousList(gens)  then
        Error( "<gens> must be a homogeneous list of elements" );
    elif not IsIdentical( FamilyObj(M), FamilyObj(gens) )  then
        Error( "families of <gens> and <M> are different" );
    fi;
    if not ForAll( gens, x -> x in M ) then
        Error( "<gens> must be elements in <M>" );
    fi;
    return SubadditiveMagmaNC( M, gens );
end;


#############################################################################
##
#F  SubadditiveMagmaNC( <M>, <gens> )
##
##  Note that 'SubadditiveMagmaNC' is allowed to call 'Objectify'
##  in the case that <gens> is empty.
##
SubadditiveMagmaNC := function( M, gens )
    local K, S;

    if IsEmpty( gens ) then
      K:= NewType( FamilyObj(M),
                       IsAdditiveMagma
                   and IsTrivial
                   and IsAttributeStoringRep );
      S:= Objectify( K, rec() );
      SetGeneratorsOfAdditiveMagma( S, [] );
    else
      S:= AdditiveMagmaByGenerators(gens);
    fi;
    SetParent( S, M );
    return S;
end;


#############################################################################
##
#F  AdditiveMagmaWithZero( <gens> )
#F  AdditiveMagmaWithZero( <Fam>, <gens> )
##
AdditiveMagmaWithZero := function( arg )

    # list of generators
    if Length( arg ) = 1 and IsList( arg[1] ) and 0 < Length( arg[1] ) then
      return AdditiveMagmaWithZeroByGenerators( arg[1] );

    # family plus list of generators
    elif Length( arg ) = 2 and IsFamily( arg[1] ) and IsList( arg[1] ) then
      return AdditiveMagmaWithZeroByGenerators( arg[1], arg[2] );

    # generators
    elif 0 < Length( arg ) then
      return AdditiveMagmaWithZeroByGenerators( arg );
    fi;

    # no argument given, error
    Error("usage: AdditiveMagmaWithZero(<gens>), ",
          "AdditiveMagmaWithZero(<Fam>,<gens>)");
end;


#############################################################################
##
#F  SubadditiveMagmaWithZero( <M>, <gens> )
#F                        . . .  add. submagma-with-one of <M> gen. by <gens>
##
SubadditiveMagmaWithZero := function( M, gens )
    if not IsAdditiveMagmaWithZero( M ) then
        Error( "<M> must be a magma-with-one" );
    elif IsEmpty( gens ) then
        return SubadditiveMagmaWithZeroNC( M, gens );
    elif not IsHomogeneousList(gens)  then
        Error( "<gens> must be a homogeneous list of elements" );
    elif not IsIdentical( FamilyObj(M), FamilyObj(gens) )  then
        Error( "families of <gens> and <M> are different" );
    fi;
    if not ForAll( gens, x -> x in M ) then
        Error( "<gens> must be elements in <M>" );
    fi;
    return SubadditiveMagmaWithZeroNC( M, gens );
end;


#############################################################################
##
#F  SubadditiveMagmaWithZeroNC( <M>, <gens> )
##
##  Note that 'SubadditiveMagmaWithZeroNC' is allowed to call 'Objectify'
##  in the case that <gens> is empty.
##
##  Furthermore note that a trivial additive magma with zero is automatically
##  an additive group.
##
SubadditiveMagmaWithZeroNC := function( M, gens )
    local K, S;

    if IsEmpty( gens ) then
      K:= NewType( FamilyObj(M),
                       IsAdditiveMagmaWithInverses
                   and IsTrivial
                   and IsAttributeStoringRep );
      S:= Objectify( K, rec() );
      SetGeneratorsOfAdditiveMagmaWithInverses( S, [] );
    else
      S:= AdditiveMagmaWithZeroByGenerators(gens);
    fi;
    SetParent( S, M );
    return S;
end;


#############################################################################
##
#F  AdditiveMagmaWithInverses( <gens> )
#F  AdditiveMagmaWithInverses( <Fam>, <gens> )
##
AdditiveMagmaWithInverses := function( arg )

    # list of generators
    if Length( arg ) = 1 and IsList( arg[1] ) and 0 < Length( arg[1] ) then
      return AdditiveMagmaWithInversesByGenerators( arg[1] );

    # family plus list of generators
    elif Length( arg ) = 2 and IsFamily( arg[1] ) and IsList( arg[1] ) then
      return AdditiveMagmaWithInversesByGenerators( arg[1], arg[2] );

    # generators
    elif 0 < Length( arg ) then
      return AdditiveMagmaWithInversesByGenerators( arg );
    fi;

    # no argument given, error
    Error("usage: AdditiveMagmaWithInverses(<gens>), ",
          "AdditiveMagmaWithInverses(<Fam>,<gens>)");
end;


#############################################################################
##
#F  SubadditiveMagmaWithInverses( <M>, <gens> )
#F                    . . . . . add. submagma-with-inv. of <M> gen. by <gens>
##
SubadditiveMagmaWithInverses := function( M, gens )
    if not IsAdditiveMagmaWithInverses( M ) then
        Error( "<M> must be a magma-with-inverses" );
    elif IsEmpty( gens ) then
        return SubadditiveMagmaWithInversesNC( M, gens );
    elif not IsHomogeneousList(gens)  then
        Error( "<gens> must be a homogeneous list of elements" );
    elif not IsIdentical( FamilyObj(M), FamilyObj(gens) )  then
        Error( "families of <gens> and <M> are different" );
    fi;
    if not ForAll( gens, x -> x in M ) then
        Error( "<gens> must be elements in <M>" );
    fi;
    return SubadditiveMagmaWithInversesNC( M, gens );
end;


#############################################################################
##
#F  SubadditiveMagmaWithInversesNC( <M>, <gens> )
##
##  Note that 'SubadditiveMagmaWithInversesNC' is allowed to call 'Objectify'
##  in the case that <gens> is empty.
##
SubadditiveMagmaWithInversesNC := function( M, gens )
    local K, S;

    if IsEmpty( gens ) then
      K:= NewType( FamilyObj(M),
                       IsAdditiveMagmaWithInverses
                   and IsTrivial
                   and IsAttributeStoringRep );
      S:= Objectify( K, rec() );
      SetGeneratorsOfAdditiveMagmaWithInverses( S, [] );
    else
      S:= AdditiveMagmaWithInversesByGenerators(gens);
    fi;
    SetParent( S, M );
    return S;
end;


#############################################################################
##
#F  SubadditiveGroup
#F  SubadditiveGroupNC
##
SubadditiveGroup := SubadditiveMagmaWithInverses;
SubadditiveGroupNC := SubadditiveMagmaWithInversesNC;


#############################################################################
##
#M  TrivialSubadditiveMagmaWithZero( <M> )  . . . for an add.-magma-with-zero
##
InstallMethod( TrivialSubadditiveMagmaWithZero,
    "method for add.-magma-with-zero",
    true,
    [ IsAdditiveMagmaWithZero ], 0,
    M -> SubadditiveMagmaWithZeroNC( M, [] ) );


#############################################################################
##
#M  AdditiveMagmaByGenerators( <gens> ) . . . . . . . . . .  for a collection
##
InstallMethod( AdditiveMagmaByGenerators,
    "method for collection",
    true,
    [ IsCollection ] , 0,
    function( gens )
    local M;
    M:= Objectify( NewType( FamilyObj( gens ),
                            IsAdditiveMagma and IsAttributeStoringRep ),
                   rec() );
    SetGeneratorsOfAdditiveMagma( M, AsList( gens ) );
    return M;
    end );


#############################################################################
##
#M  AdditiveMagmaByGenerators( <Fam>, <gens> )  . . . . . for family and list
##
InstallOtherMethod( AdditiveMagmaByGenerators,
    "method for family and list",
    true,
    [ IsFamily, IsList ], 0,
    function( family, gens )
    local M;
    if not ( IsEmpty(gens) or IsIdentical( FamilyObj(gens), family ) ) then
      Error( "<family> and family of <gens> do not match" );
    fi;
    M:= Objectify( NewType( family,
                            IsAdditiveMagma and IsAttributeStoringRep ),
                   rec() );
    SetGeneratorsOfAdditiveMagma( M, AsList( gens ) );
    return M;
    end );


#############################################################################
##
#M  AdditiveMagmaWithZeroByGenerators( <gens> ) . . . . . .  for a collection
##
InstallMethod( AdditiveMagmaWithZeroByGenerators,
    "method for collection",
    true,
    [ IsCollection ] , 0,
    function( gens )
    local M;
    M:= Objectify( NewType( FamilyObj( gens ),
                       IsAdditiveMagmaWithZero and IsAttributeStoringRep ),
                   rec() );
    SetGeneratorsOfAdditiveMagmaWithZero( M, AsList( gens ) );
    return M;
    end );


#############################################################################
##
#M  AdditiveMagmaWithZeroByGenerators( <Fam>, <gens> )  . for family and list
##
InstallOtherMethod( AdditiveMagmaWithZeroByGenerators,
    "method for family and list",
    true,
    [ IsFamily, IsList ], 0,
    function( family, gens )
    local M;
    if not ( IsEmpty(gens) or IsIdentical( FamilyObj(gens), family ) ) then
      Error( "<family> and family of <gens> do not match" );
    fi;
    M:= Objectify( NewType( family,
                       IsAdditiveMagmaWithZero and IsAttributeStoringRep ),
                   rec() );
    SetGeneratorsOfAdditiveMagmaWithZero( M, AsList( gens ) );
    return M;
    end );


#############################################################################
##
#M  AdditiveMagmaWithInversesByGenerators( <gens> ) . . . .  for a collection
##
InstallMethod( AdditiveMagmaWithInversesByGenerators,
    "method for collection",
    true,
    [ IsCollection ] , 0,
    function( gens )
    local M;
    M:= Objectify( NewType( FamilyObj( gens ),
                     IsAdditiveMagmaWithInverses and IsAttributeStoringRep ),
                   rec() );
    SetGeneratorsOfAdditiveMagmaWithInverses( M, AsList( gens ) );
    return M;
    end );


#############################################################################
##
#M  AdditiveMagmaWithInversesByGenerators(<Fam>,<gens>) . for family and list
##
InstallOtherMethod( AdditiveMagmaWithInversesByGenerators,
    "method for family and list",
    true,
    [ IsFamily, IsList ], 0,
    function( family, gens )
    local M;
    if not ( IsEmpty(gens) or IsIdentical( FamilyObj(gens), family ) ) then
      Error( "<family> and family of <gens> do not match" );
    fi;
    M:= Objectify( NewType( family,
                     IsAdditiveMagmaWithInverses and IsAttributeStoringRep ),
                   rec() );
    SetGeneratorsOfAdditiveMagmaWithInverses( M, AsList( gens ) );
    return M;
    end );


#############################################################################
##
#M  GeneratorsOfAdditiveMagma( <A> )
#M  GeneratorsOfAdditiveMagmaWithZero( <A> )
#M  GeneratorsOfAdditiveMagmaWithInverses( <A> )
##
##  If nothing special is known about the additive magma <A> we have
##  no chance to get the required generators.
##
##  If we know 'GeneratorsOfAdditiveMagma',
##  they are also 'GeneratorsOfAdditiveMagmaWithZero'.
##  If we know 'GeneratorsOfAdditiveMagmaWithZero',
##  they are also 'GeneratorsOfAdditiveMagmaWithInverses'.
##
InstallImmediateMethod( GeneratorsOfAdditiveMagmaWithZero,
    IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagma, 0,
    A -> GeneratorsOfAdditiveMagma( A ) );

InstallImmediateMethod( GeneratorsOfAdditiveMagmaWithInverses,
    IsAdditiveMagmaWithInverses and HasGeneratorsOfAdditiveMagmaWithZero, 0,
    A -> GeneratorsOfAdditiveMagmaWithZero( A ) );


InstallMethod( GeneratorsOfAdditiveMagma, true,
    [ IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagmaWithZero ], 0,
    A -> Concatenation( GeneratorsOfAdditiveMagmaWithZero( A ),
              [ Zero( A ) ] ) );

InstallMethod( GeneratorsOfAdditiveMagma, true,
    [     IsAdditiveMagmaWithInverses
      and HasGeneratorsOfAdditiveMagmaWithInverses ], 0,
    A -> Concatenation( GeneratorsOfAdditiveMagmaWithInverses( A ),
              [ Zero( A ) ],
              List( GeneratorsOfAdditiveMagmaWithInverses( A ),
                    AdditiveInverse ) ) );

InstallMethod( GeneratorsOfAdditiveMagmaWithZero, true,
    [     IsAdditiveMagmaWithInverses
      and HasGeneratorsOfAdditiveMagmaWithInverses ], 0,
    A -> Concatenation( GeneratorsOfAdditiveMagmaWithInverses( A ),
              List( GeneratorsOfAdditiveMagmaWithInverses( A ),
                    AdditiveInverse ) ) );


#############################################################################
##
#M  Representative( <A> ) . . . . . . . . .  one element of an additive magma
##
InstallMethod( Representative,
    "method for additive magma with known generators",
    true,
    [ IsAdditiveMagma and HasGeneratorsOfAdditiveMagma ], 0,
    RepresentativeFromGenerators( GeneratorsOfAdditiveMagma ) );

InstallMethod( Representative,
    "method for additive-magma-with-zero with known generators",
    true,
    [ IsAdditiveMagmaWithZero and HasGeneratorsOfAdditiveMagmaWithZero ], 0,
    RepresentativeFromGenerators( GeneratorsOfAdditiveMagmaWithZero ) );

InstallMethod( Representative,
    "method for additive-magma-with-inverses with known generators",
    true,
    [ IsAdditiveMagmaWithInverses
      and HasGeneratorsOfAdditiveMagmaWithInverses ], 0,
    RepresentativeFromGenerators( GeneratorsOfAdditiveMagmaWithInverses ) );

InstallMethod( Representative,
    "method for additive-magma-with-zero with known zero",
    true,
    [ IsAdditiveMagmaWithZero and HasZero ], SUM_FLAGS,
    Zero );


#############################################################################
##
#M  AdditiveNeutralElement( <A> ) . . . . . . . . . zero of an additive magma
##
InstallMethod( AdditiveNeutralElement, true, [ IsAdditiveMagma ], 0,
    function( M )
    local m;
    if IsFinite( M ) then
      for m in M do
        if ForAll( M, n -> n + m = n ) then
          return m;
        fi;
      od;
      return fail;
    else
      TryNextMethod();
    fi;
    end );


#############################################################################
##
#M  Zero( <A> ) . . . . . . . . . . . . . . . . . . zero of an additive magma
##
InstallOtherMethod( Zero,
    "method for additive magma",
    true, [ IsAdditiveMagma ], 0,
    function( A )
    local zero;
    zero:= Zero( Representative( A ) );
    if zero <> fail and zero in A then
      return zero;
    else
      return fail;
    fi;
    end );

InstallOtherMethod( Zero,
    "method for additive magma with zero (look at family)",
    true, [ IsAdditiveMagmaWithZero ], SUM_FLAGS,
    function( A )
    A:= ElementsFamily( FamilyObj( A ) );
    if HasZero( A ) then
      return Zero( A );
    else
      TryNextMethod();
    fi;
    end );
#T immediate?

InstallOtherMethod( Zero, true, [ IsAdditiveMagmaWithZero and HasParent ], 0,
    A -> Zero( Parent( A ) ) );
#T really ask the parent for such information?

InstallOtherMethod( Zero,
    "method for additive magma with zero",
    true, [ IsAdditiveMagmaWithZero ], 0,
    A -> Zero( Representative( A ) ) );


#############################################################################
##
#M  Enumerator( <A> ) . . . .  enumerator of trivial additive magma with zero
#M  EnumeratorSorted( <A> ) .  enumerator of trivial additive magma with zero
##
EnumeratorOfTrivialAdditiveMagmaWithZero := A -> Immutable( [ Zero( A ) ] );

InstallMethod( Enumerator,
    true, [ IsAdditiveMagmaWithZero and IsTrivial ], 0,
    EnumeratorOfTrivialAdditiveMagmaWithZero );

InstallMethod( EnumeratorSorted,
    true, [ IsAdditiveMagmaWithZero and IsTrivial ], 0,
    EnumeratorOfTrivialAdditiveMagmaWithZero );


#############################################################################
##
#F  ClosureAdditiveMagmaDefault( <A>, <elm> )  closure of add. magma with elm
##
ClosureAdditiveMagmaDefault := function( A, elm )

    local   C,          # closure '\< <a>, <obj> \>', result
            gens,       # generators of <A>
            gen,        # generator of <A> or <C>
            Celements,  # intermediate list of elements
            len;        # current number of elements

    gens:= GeneratorsOfAdditiveMagma( A );

    # try to avoid adding an element to a add. magma that already contains it
    if   elm in gens
      or ( HasAsListSorted( A ) and elm in AsListSorted( A ) )
    then
        return A;
    fi;

    # make the closure add. magma
    gens:= Concatenation( gens, [ elm ] );
    C:= AdditiveMagmaByGenerators( gens );
    UseSubsetRelation( C, A );
    
    # if the elements of <A> are known then extend this list
    # (multiply each element from the left and right with the new
    # generator, and then multiply with all elements until the
    # list becomes stable)
    if HasAsListSorted( A ) then

        Celements := ShallowCopy( AsListSorted( A ) );
        AddSet( Celements, elm );
        UniteSet( Celements, Celements + elm );
        UniteSet( Celements, elm + Celements );
        repeat
            len:= Length( Celements );
            for gen in Celements do
                UniteSet( Celements, Celements + gen );
                UniteSet( Celements, gen + Celements );
            od;
        until len = Length( Celements );

        SetAsListSorted( C, AsListSorted( Celements ) );
        SetIsFinite( C, true );
        SetSize( C, Length( Celements ) );

    fi;

    # return the closure
    return C;
end;


#############################################################################
##
#M  Enumerator( <A> ) . . . . . . . . .  set of the elements of an add. magma
#M  EnumeratorSorted( <A> ) . . . . . .  set of the elements of an add. magma
##
EnumeratorOfAdditiveMagma := function( A )

    local   gens,       # add. magma generators of <A>
            H,          # subadd. magma of the first generators of <A>
            gen;        # generator of <A>

    # handle the case of an empty add. magma
    gens:= GeneratorsOfAdditiveMagma( A );
    if IsEmpty( gens ) then
      return [];
    fi;

    # start with the empty add. magma and its element list
    H:= SubadditiveMagma( A, [] );
    SetAsListSorted( H, Immutable( [ ] ) );

    # Add the generators one after the other.
    # We use a function that maintains the elements list for the closure.
    for gen in gens do
      H:= ClosureAdditiveMagmaDefault( H, gen );
    od;

    # return the list of elements
    Assert( 2, HasAsListSorted( H ) );
    return AsListSorted( H );
end;

InstallMethod( Enumerator,
    "generic method for an add. magma",
    true,
    [ IsAdditiveMagma and IsAttributeStoringRep ], 0,
    EnumeratorOfAdditiveMagma );

InstallMethod( EnumeratorSorted,
    "generic method for an add. magma",
    true,
    [ IsAdditiveMagma and IsAttributeStoringRep ], 0,
    EnumeratorOfAdditiveMagma );


#############################################################################
##
#M  IsSubset( <M>, <N> )  . . . . . . . . . . . . . . for two additive magmas
##
InstallMethod( IsSubset,
    "method for two additive magmas",
    IsIdentical,
    [ IsAdditiveMagma, IsAdditiveMagma ], 0,
    function( M, N )
    return IsSubset( M, GeneratorsOfAdditiveMagma( N ) );
    end );


#############################################################################
##
#M  IsSubset( <M>, <N> )  . . . . . . . . . for two additive magmas with zero
##
InstallMethod( IsSubset,
    "method for two additive magmas with zero",
    IsIdentical,
    [ IsAdditiveMagmaWithZero, IsAdditiveMagmaWithZero ], 0,
    function( M, N )
    return IsSubset( M, GeneratorsOfAdditiveMagmaWithZero( N ) );
    end );


#############################################################################
##
#M  IsSubset( <M>, <N> )  . . . . . . . for two additive magmas with inverses
##
InstallMethod( IsSubset,
    "method for two additive magmas with inverses",
    IsIdentical,
    [ IsAdditiveMagmaWithInverses, IsAdditiveMagmaWithInverses ], 0,
    function( M, N )
    return IsSubset( M, GeneratorsOfAdditiveMagmaWithInverses( N ) );
    end );


#############################################################################
##
#M  ClosureAdditiveGroup( <A>, <a> )  . . . . . .  for add. group and element
##
InstallMethod( ClosureAdditiveGroup,
    "method for add. group and element",
    IsCollsElms,
    [ IsAdditiveGroup, IsAdditiveElement ], 0,
    function( A, a )

    # if possible test if the element lies in the add. group already
    if a in GeneratorsOfAdditiveGroup( A ) or
       ( HasAsList( A ) and a in AsList( A ) ) then
      return A;
    fi;

    # Otherwise make a new add. group.
    return AdditiveGroupByGenerators( 
               Concatenation( GeneratorsOfAdditiveGroup( A ), [ a ] ) );
    end );


#############################################################################
##
#M  ClosureAdditiveGroup( <A>, <B> )  . . . . . . . . . . for two add. groups
##
InstallOtherMethod( ClosureAdditiveGroup,
    "method for two add. groups",
    IsIdentical,
    [ IsAdditiveGroup, IsAdditiveGroup ], 0,
    function( A, B )
    local C, b;
    C:= A;
    for b in GeneratorsOfAdditiveGroup( B ) do
      C:= ClosureAdditiveGroup( C, b );
    od;
    return C;
    end );


#############################################################################
##
#E  addmagma.gi . . . . . . . . . . . . . . . . . . . . . . . . . . ends here



