#############################################################################
##
#W  matrix.gd                   GAP library                     Thoams Breuer
#W                                                             & Frank Celler
#W                                                         & Alexander Hulpke
#W                                                           & Heiko Theissen
#W                                                         & Martin Schoenert
##
#H  @(#)$Id$
##
#Y  Copyright (C)  1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
#Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
##
##  This file contains those functions that mainly deal with matrices.
##
Revision.matrix_gd :=
    "@(#)$Id$";


#############################################################################
##
#V  InfoMatrix
##
DeclareInfoClass( "InfoMatrix" );


#############################################################################
##
#P  IsGeneralizedCartanMatrix( <A> )
##
##  The square matrix <A> is a generalized Cartan Matrix if and only if
##  1. `A[i][i] = 2' for all $i$,
##  2. `A[i][j]' are nonpositive integers for $i \not= j$,
##  3. `A[i][j] = 0' implies `A[j][i] = 0'.
##
DeclareProperty( "IsGeneralizedCartanMatrix", IsMatrix );


#############################################################################
##

#O  DiagonalOfMat( <mat> )
##
##  returns the diagonal of <mat> as a list.
DeclareGlobalFunction( "DiagonalOfMat" );


#############################################################################
##
#A  AbelianInvariantsOfList( <list> ) . . . . .  abelian invariants of a list
##
DeclareAttribute( "AbelianInvariantsOfList", IsCyclotomicCollection );


#############################################################################
##
#A  BaseMat( <mat> )  . . . . . . . . . .  base for the row space of a matrix
##
##  returns a basis for the row space generated by the rows of <mat> in the
##  form of an immutable matrix.
DeclareAttribute( "BaseMat", IsMatrix );


#############################################################################
##
#A  BaseOrthogonalSpaceMat( <mat> )
##
##  Let $V$ be the row space generated  by the rows of  <mat> (over any field
##  that contains all  entries of <mat>).  `BaseOrthogonalSpaceMat( <mat>  )'
##  computes a base of the orthogonal space of $V$.
##
##  The rows of <mat> need not be linearly independent.
##
#T Note that this means to transpose twice ...
##
DeclareAttribute( "BaseOrthogonalSpaceMat", IsMatrix );


#############################################################################
##
#A  DefaultFieldOfMatrix( <mat> )
##
##  is a field (not necessarily the smallest one) containing all entries
##  of the matrix <mat>.
##
DeclareAttribute( "DefaultFieldOfMatrix", IsMatrix );


#############################################################################
##
#A  DepthOfUpperTriangularMatrix( <mat> )
##
DeclareAttribute( "DepthOfUpperTriangularMatrix", IsMatrix );


#############################################################################
##
#A  DeterminantMat( <mat> ) . . . . . . . . . . . . . determinant of a matrix
#F  Determinant( <mat> )
##
##  returns the determinant of the square matrix <mat>
DeclareAttribute( "DeterminantMat", IsMatrix );


#############################################################################
##
#A  DimensionsMat( <mat> )  . . . . . . . . . . . . .  dimensions of a matrix
##
##  is a list of length 2, the first being the number of rows, the second
##  being the number of columns of the matrix <mat>.
##
DeclareAttribute( "DimensionsMat", IsMatrix );


#############################################################################
##
#A  ElementaryDivisorsMat(<mat>)  . . . . . . elementary divisors of a matrix
##
##  `ElementaryDivisors' returns a list of the elementary divisors, i.e., the
##  unique <d> with `<d>[<i>]' divides  `<d>[<i>+1]' and <mat> is  equivalent
##  to a diagonal matrix with the elements `<d>[<i>]' on the diagonal.
##
DeclareAttribute( "ElementaryDivisorsMat", IsMatrix );


#############################################################################
##
#A  NullspaceMat( <mat> ) . . . . . . basis of solutions of <vec> * <mat> = 0
##
##  returns a basis of the vector space of solutions to the equation
##  `<vec>*<mat>=0' in the form of an immutable matrix.
DeclareAttribute( "NullspaceMat", IsMatrix );


#############################################################################
##
#A  ProjectiveOrder( <mat> )
##
##  Returns an integer n and a finite field element e such that <A>^n = eI.
##  <mat> must be a matrix defined over a finite field.
##
DeclareAttribute( "ProjectiveOrder", IsMatrix );


#############################################################################
##
#A  RankMat( <mat> )  . . . . . . . . . . . . . . . . . . .  rank of a matrix
##
##  The rank of a matrix is the dimension of the vector space spanned by its
##  rows.
DeclareAttribute( "RankMat", IsMatrix );


#############################################################################
##
#A  SemiEchelonMat( <mat> )
##
##  A matrix over a field $F$ is in semi-echelon form if the first nonzero
##  element in each row is the identity of $F$,
##  and all values exactly below these pivots are the zero of $F$.
##
##  `SemiEchelonMat' returns a record that contains information about
##  a semi-echelonized form of the matrix <mat>.
##
##  The components of this record are
##
##  \beginitems
##  `vectors'&
##        list of row vectors, each with pivot element the identity of $F$,
##
##  `heads'&
##        list that contains at position <i>, if nonzero, the number of the
##        row for that the pivot element is in column <i>.
##  \enditems
##
DeclareAttribute( "SemiEchelonMat", IsMatrix );


#############################################################################
##
#A  SemiEchelonMatTransformation( <mat> )
##
##  does the same as `SemiEchelonMat' but additionally stores the linear
##  transformation $T$ performed on the matrix.
##  The additional components of the result are
##
##  \beginitems
##  `coeffs'&
##        a list of coefficients vectors of the `vectors' component,
##        with respect to the rows of <mat>, that is, `coeffs * mat'
##        is the `vectors' component.
##
##  `relations'&
##        a list of basis vectors for the (left) null space of <mat>.
##  \enditems
##
DeclareAttribute( "SemiEchelonMatTransformation", IsMatrix );


#############################################################################
##
#A  SemiEchelonMats( <mats> )
##
##  A list of matrices over a field $F$ is in semi-echelon form if the
##  list of row vectors obtained on concatenating the rows of each matrix
##  is a semi-echelonized matrix (see "SemiEchelonMat").
##
##  `SemiEchelonMats' returns a record that contains information about
##  a semi-echelonized form of the list <mats> of matrices.
##
##  The components of this record are
##
##  \beginitems
##  `vectors'&
##        list of matrices, each with pivot element the identity of $F$,
##
##  `heads'&
##        matrix that contains at position [<i>,<j>], if nonzero,
##        the number of the matrix for that the pivot element is in
##        this position
##  \enditems
##
DeclareGlobalFunction( "SemiEchelonMats" );


#############################################################################
##
#A  TransposedMat( <mat> )  . . . . . . . . . . . . .  transposed of a matrix
##
##  `TransposedMat'  returns the transposed of the  matrix <mat>, i.e., a new
##  matrix <trans> such that `<trans>[<i>][<k>] = <mat>[<k>][<i>]'. As it is
##  an attribute it returns an immutable matrix.
##
DeclareAttribute( "TransposedMat", IsMatrix );


############################################################################
##
#P  IsMonomialMatrix( <mat> )
##
##  A matrix is monomial if  and only if it  has exactly one nonzero entry in
##  every row and every column.
##
DeclareProperty( "IsMonomialMatrix", IsMatrix );


#############################################################################
##
#O  InverseMatMod( <mat>, <obj> )
##
##  For a square matrix <mat>, `InverseMatMod' returns a matrix <inv>
##  such that `<inv> * <mat>' is congruent to the identity matrix modulo
##  <obj>, if such a matrix exists, and `fail' otherwise.
##
DeclareOperation( "InverseMatMod", [ IsMatrix, IsObject ] );


#############################################################################
##
#O  KroneckerProduct( <mat1>, <mat2> )
##
##  The Kronecker product of two matrices is the matrix obtained when
##  replacing each entry <a> of <mat1> by the product `<a>*<mat2>' in one
##  matrix.
DeclareOperation( "KroneckerProduct", [ IsMatrix, IsMatrix ] );


#############################################################################
##
#O  SolutionMat( <mat>, <vec> ) . . . . . . . . . .  one solution of equation
##
##  One solution <x> of `<x> * <mat> = <vec>' or `fail'.
##
DeclareOperation( "SolutionMat", [ IsMatrix, IsRowVector ] );


############################################################################
##
#O  SumIntersectionMat( <M1>, <M2> )  . .  sum and intersection of two spaces
##
##  performs  Zassenhaus'  algorithm to compute  bases  for  the sum  and the
##  intersection of spaces generated by the rows of the matrices <M1>, <M2>.
##
##  returns a list  of length 2,   at first position   a base of the sum,  at
##  second  position a  base   of the   intersection.   Both  bases  are   in
##  semi-echelon form.
##
DeclareOperation( "SumIntersectionMat", [ IsMatrix, IsMatrix ] );


#############################################################################
##
#O  TriangulizeMat( <mat> ) . . . . . bring a matrix in upper triangular form
##
##  modifies the mutable matrix <mat> such that it is in upper triangular
##  form.
DeclareOperation( "TriangulizeMat", [ IsMatrix and IsMutable ] );


#############################################################################
##
#O  UpperSubdiagonal( <mat>, <pos> )
##
##  returns a mutable list containing the entries of the <pos>th upper
##  subdiagonal of <mat>.
DeclareOperation( "UpperSubdiagonal", [ IsMatrix, IsPosInt ] );


#############################################################################
##
#F  BaseFixedSpace( <mats> )  . . . . . . . . . . . .  calculate fixed points
##
##  `BaseFixedSpace' returns a base of the vector space $V$ such that
##  $M v = v$ for all $v$ in $V$ and all matrices $M$ in the list <mats>.
##  (This is the common eigenspace of all matrices in <mats> for the
##  eigenvalue 1.)
##
DeclareGlobalFunction( "BaseFixedSpace" );


#############################################################################
##
#F  BaseSteinitzVectors( <bas>, <mat> )
##
##  find vectors extending mat to a basis spanning the span of <bas>.
##  <bas> and <mat> must be matrices of full rank. It returns a record wqith
##  the following components:
##  \beginitems
##  `subspace'&is a basis of the space spanned by <mat> in upper triangular
##  form with leading ones at all echelon steps and zeroes above these ones.
##
##  `factorspace'& is a list of extending vectors in upper triangular form.
##
##  `factorzero'& is a zero vector.
##
##  `heads'& is a list of integers, the <i>th entry indicating the vector
##  that gives an echelon step at position <i>.
##  A negative number indicates an echelon step in the subspace, a positive
##  number an echelon step in the complement, the absolute value gives the
##  position of the vector in the lists `subspace' and `factorspace'.
##  \enditems
##
DeclareGlobalFunction( "BaseSteinitzVectors" );


#############################################################################
##
#F  BlownUpMat( <B>, <mat> )
##
##  Let <B> be a basis of a field extension $F / K$, and <mat> a matrix whose
##  entries are all  in $F$.   `BlownUpMat' returns a  matrix  over $K$ where
##  each entry of  <mat> is replaced   by its regular representation w.r.  to
##  <B>.
##
##  In other words:
##  If we regard  <mat> as a  linear transformation  on the space  $F^n$ with
##  respect to the  $F$-basis with vectors  $(v_1, ldots, v_n)$, say, and  if
##  the basis <B>  has vectors $(b_1,  \ldots, b_m)$ then the returned matrix
##  is the linear transformation  on the space $K^{mn}$  with respect to  the
##  $K$-basis whose vectors are $(b_1 v_1, \ldots b_m v_1, \ldots, b_m v_n)$.
##
##  Note that the linear transformations act on *row* vectors, i.e., the rows
##  of the matrix contains vectors that consist of <B>-coefficients.
##
DeclareGlobalFunction( "BlownUpMat" );


##########################################################################
##
#F  BlownUpVector( <B>, <vector> )
##
##  expands a vector in the same way as described under "BlownUpMat".
DeclareGlobalFunction( "BlownUpVector" );


#############################################################################
##
#F  DiagonalizeIntMatNormDriven(<mat>)  . . . . diagonalize an integer matrix
##
##  `DiagonalizeIntMatNormDriven'  diagonalizes  the  integer  matrix  <mat>.
##
##  It tries to keep the entries small  through careful  selection of pivots.
##
##  First it selects a nonzero entry for which the  product of row and column
##  norm is minimal (this need not be the entry with minimal absolute value).
##  Then it brings this pivot to the upper left corner and makes it positive.
##
##  Next it subtracts multiples of the first row from the other rows, so that
##  the new entries in the first column have absolute value at most  pivot/2.
##  Likewise it subtracts multiples of the 1st column from the other columns.
##
##  If afterwards not  all new entries in the  first column and row are zero,
##  then it selects a  new pivot from those  entries (again driven by product
##  of norms) and reduces the first column and row again.
##
##  If finally all offdiagonal entries in the first column  and row are zero,
##  then it  starts all over again with the submatrix  `<mat>{[2..]}{[2..]}'.
##
##  It is  based  upon  ideas by  George Havas  and code by  Bohdan Majewski.
##  G. Havas and B. Majewski, Integer Matrix Diagonalization, JSC, to appear
##
DeclareGlobalFunction( "DiagonalizeIntMatNormDriven" );

DeclareSynonym( "DiagonalizeIntMat", DiagonalizeIntMatNormDriven );


#############################################################################
##
#F  DiagonalizeMat(<mat>) . . . . . . . . . . . . . . .  diagonalize a matrix
##
#T  1996/05/06 mschoene should be extended for other rings
##
DeclareSynonym( "DiagonalizeMat", DiagonalizeIntMat );


#############################################################################
##
#F  IdentityMat( <m> [, <F>] )  . . . . . . . identity matrix of a given size
#F  MutableIdentityMat( <m> [, <F>] ) . . . . identity matrix of a given size
##
##  returns an <m>$\times$<m> identity matrix over the field given by <F>.
##  The first version returns an immutable matrix, the second a mutable
##  matrix.
##
DeclareGlobalFunction( "IdentityMat" );
DeclareGlobalFunction( "MutableIdentityMat" );


#############################################################################
##
#F  MutableTransposedMat( <mat> ) . . . . . . . . . .  transposed of a matrix
##
##  `MutableTransposedMat'  returns the transposed of  the  matrix <mat> as a
##  mutable matrix, i.e., a new matrix <trans> such that `<trans>[<i>][<k>] =
##  <mat>[<k>][<i>]'.
##
DeclareGlobalFunction( "MutableTransposedMat" );


#############################################################################
##
#F  NullMat( <m>, <n> [, <F>] ) . . . . . . . . . null matrix of a given size
#F  MutableNullMat( <m>, <n> [, <F>] )  . . . . . null matrix of a given size
##
##  returns an <m>$\times$<n> null matrix over the field given by <F>.
##  The first version returns an immutable matrix, the second a mutable
##  matrix.
##
DeclareGlobalFunction( "NullMat" );
DeclareGlobalFunction( "MutableNullMat" );


#############################################################################
##
#F  NullspaceModQ( <E>, <q> ) . . . . . . . . . . . .nullspace of <E> mod <q>
##
##  <E> must be a matrix of integers and <q> a prime power.
##  Then `NullspaceModQ' returns the set of all vectors of integers modulo
##  <q>, which solve the homogeneous equation system given by <E> modulo <q>.
##
DeclareGlobalFunction( "NullspaceModQ" );


#############################################################################
##
#F  PermutationMat( <perm>, <dim> [, <F> ] ) . . . . . .  permutation matrix
##
##  returns a matrix in dimenstion <dim> over the field given by <F> that
##  represents the permutation <perm> acting by permuting the basis vectors
##  as it permutes points.
DeclareGlobalFunction( "PermutationMat" );


#############################################################################
##
#F  DiagonalMat( <vector> ) . . . . . . . . . . . . . . . . . diagonal matrix
##
##  returns a diagonal matrix <mat> with the diagonal entries given by
##  <vector>.
DeclareGlobalFunction( "DiagonalMat" );


#############################################################################
##
#F  ReflectionMat( <coeffs> )
#F  ReflectionMat( <coeffs>, <root> )
#F  ReflectionMat( <coeffs>, <conj> )
#F  ReflectionMat( <coeffs>, <conj>, <root> )
##
##  Let <coeffs> be a row vector.
##  `ReflectionMat' returns the matrix of the reflection in this vector.
##
##  More precisely, if <coeffs> is the coefficients of a vector $v$ w.r.t. a
##  basis $B$, say, then the returned matrix describes the reflection in $v$
##  w.r.t. $B$ as a map on a row space, with action from the right.
##
##  The optional argument <root> is a root of unity that determines the order
##  of the reflection.  The default is a reflection of order 2.
##  For triflections one should choose a third root of unity etc.
##
##  <conj> is a function of one argument that conjugates a ring element.
##  The default is `ComplexConjugate'.
##
##  The matrix of the reflection in $v$ is defined as
##  $$ M = I_n + \overline{v^{tr}} \cdot \frac{w-1}{v \overline{v^{tr}}}
##                                 \cdot v$$ 
##  where `$w$ = root',
##  $n$ is the length of our coefficients list,
##  and $\overline{\ }$ denotes the conjugation.
##
DeclareGlobalFunction( "ReflectionMat" );


#############################################################################
##
#F  RandomInvertibleMat( <m> [, <R>] )  . . . make a random invertible matrix
##
##  `RandomInvertibleMat'  returns a invertible  random  matrix with <m> rows
##  and  columns with  elements  taken from the ring  <R>,  which defaults to
##  `Integers'.
##
DeclareGlobalFunction( "RandomInvertibleMat" );


#############################################################################
##
#F  RandomMat( <m>, <n> [, <R>] ) . . . . . . . . . . .  make a random matrix
##
##  `RandomMat' returns a  random matrix with  <m> rows and  <n> columns with
##  elements taken from the ring <R>, which defaults to `Integers'.
##
DeclareGlobalFunction( "RandomMat" );


#############################################################################
##
#F  RandomUnimodularMat( <m> )  . . . . . . . . . .  random unimodular matrix
##
##  returns a random <m>$\times$<m> matrix with integer entries that is
##  invertible over the integers.
DeclareGlobalFunction( "RandomUnimodularMat" );


#############################################################################
##
#F  SimultaneousEigenvalues( <matlist>, <expo> ) . . . . . . . . .eigenvalues
##
##  The  matgroup  generated  by <matlist>  must  be  an  abelian p-group  of
##  exponent <expo>.  The matrices in  matlist must  be matrices over GF(<q>)
##  for some prime <q>. Then the eigenvalues of <mat>  in the splitting field
##  GF(<q>^r) for some r are powers of an element ksi in the splitting field,
##  which is of order  <expo>.  `SimultaneousEigenspaces' returns a matrix of
##  integers  mod <expo>, say (a_{i,j}),  such that the power ksi^a_{i,j} is
##  an eigenvalue of the i-th matrix in  <matlist> and the eigenspaces of the
##  different matrices to the eigenvalues ksi^a_{i,j} for fixed j are equal.
##
DeclareGlobalFunction( "SimultaneousEigenvalues" );


#############################################################################
##
#F  TraceMat( <mat> ) . . . . . . . . . . . . . . . . . . . trace of a matrix
#F  Trace( <mat> )
##
##  The trace of a matrix is the sum of its diagonal entries.
##
DeclareGlobalFunction( "TraceMat" );


#############################################################################
##
#A  JordanDecomposition( <mat> )
##
##  `JordanDecomposition( <mat > )' returns a list `[S,N]' such that
##  `S' is a semisimple matrix and `N' is nilpotent. Furthermore, `S'
##  and `N' commute and `<mat>=S+N'.
##
DeclareAttribute( "JordanDecomposition", IsMatrix );

#############################################################################
##
#F  FlatBlockMat( <blockmat> ) . . . . . . . . convert block matrix to matrix
##
DeclareGlobalFunction( "FlatBlockMat" );


#############################################################################
##
#F  EmptyMatrix( <char> )
##
##  is an empty (ordinary) matrix in characteristic <char>
##  that acts on empty lists and can be added to or multiplied with empty
##  lists.
##
#T store in the family as an attribute?
##
DeclareGlobalFunction( "EmptyMatrix" );


#############################################################################
##
#E  matrix.gd . . . . . . . . . . . . . . . . . . . . . . . . . . . ends here
##
