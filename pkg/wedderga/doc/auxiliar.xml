<!-- $Id: auxiliar.xml,v 1.17 2007/12/27 19:33:26 alexk Exp $ -->

<!-- ********************auxiliar******************** -->

<!-- $Id: auxiliar.xml,v 1.17 2007/12/27 19:33:26 alexk Exp $ -->
<Chapter Label="Auxiliar">
<Heading>Useful properties and functions</Heading>

<Section Label="AuxiliarProperties">
<Heading>Semisimple group algebras of finite groups</Heading>

<ManSection>
   <Prop Name="IsSemisimpleZeroCharacteristicGroupAlgebra" 
         Arg="KG"  
         Comm="Is a group algebra of a finite group over the field of char zero?" />
   <Description>
         The input must be a group ring. <P/>
      
         Returns <K>true</K> if the input <A>KG</A> is a 
         <E>semisimple group algebra</E> (<Ref Sect="Semisimple" />) 
         over a field of characteristic zero (that is if <M>G</M> is finite), 
         and <K>false</K> otherwise.

<Example>
<![CDATA[
gap> CG:=GroupRing( GaussianRationals, DihedralGroup(16) );;
gap> IsSemisimpleZeroCharacteristicGroupAlgebra( CG );
true
gap> FG:=GroupRing( GF(2), SymmetricGroup(3) );;                    
gap> IsSemisimpleZeroCharacteristicGroupAlgebra( FG );
false
gap> f := FreeGroup("a");
<free group on the generators [ a ]>
gap> Qf:=GroupRing(Rationals,f);
<algebra-with-one over Rationals, with 2 generators>
gap> IsSemisimpleZeroCharacteristicGroupAlgebra(Qf);
false
]]>
</Example>

   </Description>
</ManSection>


<ManSection>
   <Prop Name="IsSemisimpleRationalGroupAlgebra" 
         Arg="KG"  
         Comm="Is rational group algebra of finite group?" />
   <Description>
    The input must be a group ring. <P/>
      
    Returns <K>true</K> if <A>KG</A> is a 
    <E>semisimple rational group algebra</E> (<Ref Sect="Semisimple" />) 
    and <K>false</K> otherwise.
    
<Example>
<![CDATA[
gap> QG:=GroupRing( Rationals, SymmetricGroup(4) );;       
gap> IsSemisimpleRationalGroupAlgebra( QG );       
true
gap> CG:=GroupRing( GaussianRationals, DihedralGroup(16) );;               
gap> IsSemisimpleRationalGroupAlgebra( CG );                              
false
gap> FG:=GroupRing( GF(2), SymmetricGroup(3) );;
gap> IsSemisimpleRationalGroupAlgebra( FG );
false
]]>
</Example>
    
   </Description>
</ManSection>


<ManSection>
   <Prop Name="IsSemisimpleANFGroupAlgebra" 
         Arg="KG"  
         Comm="Is a group algebra of a finite group over an abelian number field 
         (a subfield of a cyclotomic extension of the rationals)?" />
   <Description>
    The input must be a group ring. <P/>
    
         Returns <K>true</K> if <A>KG</A> is the group algebra of a finite 
         group over a subfield of a cyclotomic extension of the rationals and <K>false</K> 
         otherwise.

<Example>
<![CDATA[
gap> IsSemisimpleANFGroupAlgebra( GroupRing( NF(5,[4]) , CyclicGroup(28) ) );
true
gap> IsSemisimpleANFGroupAlgebra( GroupRing( GF(11) , CyclicGroup(28) ) );
false
]]>
</Example>

   </Description>
</ManSection>


<ManSection>
   <Prop Name="IsSemisimpleFiniteGroupAlgebra" 
         Arg="KG"  
         Comm="Is a semisimple group algebra of a finite group over a finite field?" />
   <Description>
    The input must be a group ring. <P/>
    
         Returns <K>true</K> if <A>KG</A> is a 
         <E>semisimple finite group algebra</E> (<Ref Sect="Semisimple" />), 
         that is a group algebra of a finite group <M>G</M> over a field <M>K</M> 
         of order coprime to the order of <M>G</M>, and <K>false</K> otherwisse.

<Example>
<![CDATA[
gap> FG:=GroupRing( GF(5), SymmetricGroup(3) );;
gap> IsSemisimpleFiniteGroupAlgebra( FG );
true
gap> KG:=GroupRing( GF(2), SymmetricGroup(3) );; 
gap> IsSemisimpleFiniteGroupAlgebra( KG ); 
false
gap> QG:=GroupRing( Rationals, SymmetricGroup(4) );;
gap> IsSemisimpleFiniteGroupAlgebra( QG );
false
]]>
</Example>

   </Description>
</ManSection>

</Section>


<Section Label="AuxiliarOperations">
<Heading>Operations with group rings elements</Heading>

<ManSection>
   <Oper Name="Centralizer" 
         Arg="G x"  
         Comm="Centralizer of a group ring element in a subgroup of G" />
   <Returns>
         A subgroup of a group <A>G</A>.
   </Returns>         
   <Description>
         The input should be formed by a finite group <A>G</A> and an element
         <A>x</A> of a group ring <M>FH</M> whose underlying group <M>H</M>
         contains <A>G</A> as a subgroup. <P/>
   
         Returns the centralizer of <A>x</A> in <A>G</A>. <P/>
         This operation adds a new method to the operation that already 
         exists in &GAP;.
         
<Example>
<![CDATA[
gap> D16 := DihedralGroup(16);
<pc group of size 16 with 4 generators>
gap> QD16 := GroupRing( Rationals, D16 );
<algebra-with-one over Rationals, with 4 generators>
gap> a:=QD16.1;b:=QD16.2;
(1)*f1
(1)*f2
gap> e := PrimitiveCentralIdempotentsByStrongSP( QD16)[3];;
gap> Centralizer( D16, a);
Group([ f1, f4 ])
gap> Centralizer( D16, b);
Group([ f2 ])
gap> Centralizer( D16, a+b);
Group([ f4 ])
gap> Centralizer( D16, e);
Group([ f1, f2 ])
]]>
</Example>
         
   </Description>
</ManSection>


<ManSection>
   <Oper Name="OnPoints" 
         Arg="x g"  
         Comm="Conjugate of x by g" />
   <Oper Name="\^" 
         Arg="x g"  
         Comm="Conjugate of x by g" />
   <Returns>
         An element of a group ring.
   </Returns>         
   <Description>
      The input should be formed by an element <A>x</A> of a group ring 
      <M>FG</M> and an element <A>g</A> in the underlying group 
      <M>G</M> of <M>FG</M>.<P/>
   
      Returns the conjugate <M>x^g = g^{-1} x g</M> of <A>x</A> by <A>g</A>. 
      Usage of <C>x&circum;g</C> produces the same output.
      <P/>
      
      This operation adds a new method to the operation that already 
      exists in &GAP;.
      <P/>

The following example is a continuation of the example from the 
description of <Ref Oper="Centralizer" />.

<Example>
<![CDATA[
gap> List(D16,x->a^x=a);
[ true, true, false, false, true, false, false, true, false, false, false,
  false, false, false, false, false ]
gap> List(D16,x->e^x=e);
[ true, true, true, true, true, true, true, true, true, true, true, true,
  true, true, true, true ]
gap> ForAll(D16,x->a^x=a);
false
gap> ForAll(D16,x->e^x=e);
true
]]>
</Example>

   </Description>
</ManSection>


<ManSection>
   <Oper Name="AverageSum" 
         Arg="RG X"  
         Comm="(x_1+...+x_n)/n" />
   <Returns>
         An element of a group ring.
   </Returns>         
   <Description>
    The input must be composed of a group ring <A>RG</A> and a finite subset <A>X</A> of the underlying
    group <M>G</M> of <A>RG</A>. The order of <A>X</A> must be invertible in the coefficient
    ring <M>R</M> of <A>RG</A>. <P/>
    
    Returns the element of the group ring <A>RG</A> that is equal to the
    sum of all elements of <A>X</A> divided by the order of <A>X</A>.
    <P/>

If <A>X</A> is a subgroup of <M>G</M> then the output is an idempotent 
of <M>RG</M> which is central if and only if <A>X</A> is normal in <M>G</M>. 

<Example>
<![CDATA[
gap> G:=DihedralGroup(16);;               
gap> QG:=GroupRing( Rationals, G );;
gap> FG:=GroupRing( GF(5), G );;
gap> e:=AverageSum( QG, DerivedSubgroup(G) );
(1/4)*<identity> of ...+(1/4)*f3+(1/4)*f4+(1/4)*f3*f4
gap> f:=AverageSum( FG, DerivedSubgroup(G) ); 
(Z(5)^2)*<identity> of ...+(Z(5)^2)*f3+(Z(5)^2)*f4+(Z(5)^2)*f3*f4
gap> G=Centralizer(G,e);
true
gap> H:=Subgroup(G,[G.1]);
Group([ f1 ])
gap> e:=AverageSum( QG, H );
(1/2)*<identity> of ...+(1/2)*f1
gap> G=Centralizer(G,e);
false
gap> IsNormal(G,H);
false
]]>
</Example>
    
   </Description>
</ManSection>

</Section>


<Section Label="CC">
<Heading>Cyclotomic classes</Heading>

<ManSection>
   <Oper Name="CyclotomicClasses" 
         Arg="q n"  
         Comm="Cyclotomic classes" />
   <Returns>
         A partition of <M>[ 0 .. n ]</M>.
   </Returns>          
   <Description>
   The input should be formed by two relatively prime positive integers. <P/>
   
   Returns the list <A>q</A>-<E>cyclotomic classes </E> 
   (<Ref Sect="CyclotomicClass" />) modulo <A>n</A>.

<Example>
<![CDATA[
gap> CyclotomicClasses( 2, 21 );
[ [ 0 ], [ 1, 2, 4, 8, 16, 11 ], [ 3, 6, 12 ], [ 5, 10, 20, 19, 17, 13 ],
  [ 7, 14 ], [ 9, 18, 15 ] ]
gap> CyclotomicClasses( 10, 21 );
[ [ 0 ], [ 1, 10, 16, 13, 4, 19 ], [ 2, 20, 11, 5, 8, 17 ],
  [ 3, 9, 6, 18, 12, 15 ], [ 7 ], [ 14 ] ]
]]>
</Example>

   </Description>
</ManSection>


<ManSection>
   <Oper Name="IsCyclotomicClass" 
         Arg="q n C"  
         Comm="Is Cyclotomic class" />
   <Description>
         The input should be formed by two relatively prime positive 
         integers <A>q</A> and <A>n</A> and a sublist <A>C</A> of 
         <M>[ 0 .. n ]</M>. <P/>
   
         Returns <K>true</K> if <A>C</A> is a 
         <A>q</A>-<E>cyclotomic class</E> 
         (<Ref Sect="CyclotomicClass" />) modulo <A>n</A> and 
         <K>false</K> otherwise.

<Example>
<![CDATA[
gap> IsCyclotomicClass( 2, 7, [1,2,4] );
true
gap> IsCyclotomicClass( 2, 21, [1,2,4] );
false
gap> IsCyclotomicClass( 2, 21, [3,6,12] );
true
]]>
</Example>

   </Description>
</ManSection>

</Section>


<Section Label="Other">
<Heading>Other commands</Heading>

<ManSection>
   <InfoClass Name="InfoWedderga"
              Comm="Info class for Wedderga algorithms" />
   <Description>
      <C>InfoWedderga</C> is a special Info class for &Wedderga; algorithms.
      It has 3 levels: 0, 1 (default) and 2. To change the info 
      level to <C>k</C>, use the command <C>SetInfoLevel(InfoWedderga, k)</C>. 
      <P/>
      
      In the example below we use this mechanism to see more details about 
      the Wedderburn components each time when we call 
      <C>WedderburnDecomposition</C>.

<Example>
<![CDATA[
gap> SetInfoLevel(InfoWedderga, 2);   
gap> WedderburnDecomposition( GroupRing( CF(5), DihedralGroup( 16 ) ) );
#I  Info version : [ [ 1, CF(5) ], [ 1, CF(5) ], [ 1, CF(5) ], [ 1, CF(5) ],
  [ 2, CF(5) ], [ 1, NF(40,[ 1, 31 ]), 8, [ 2, 7, 0 ] ] ]
[ CF(5), CF(5), CF(5), CF(5), ( CF(5)^[ 2, 2 ] ), 
  <crossed product with center NF(40,[ 1, 31 ]) over AsField( NF(40,
    [ 1, 31 ]), CF(40) ) of a group of size 2> ]
]]>
</Example>

   </Description>
</ManSection>


<ManSection>
   <Func Name="WEDDERGABuildManual" 
         Arg=""
	 Comm="requires GAPDoc, UNIX or Linux and TeX;" />
   <Description>
      This function is used to build the manual in the following formats:
      DVI, PDF, PS, HTML and text for online help.
      We recommend that the user should have a recent and fairly
      complete &TeX; distribution.
      Since &Wedderga; is distributed together with its manual,
      it is not necessary for the user to use this function. Normally
      it is intended to be used by the developers only. This is the only 
      function of &Wedderga; which requires a UNIX/Linux environment.
   </Description>
</ManSection>


<ManSection>
   <Func Name="WEDDERGABuildManualHTML" 
         Arg=""
	 Comm="requires only GAPDoc" />
   <Description>
      This fuction is used to build the manual only in HTML format.
      This does not depend on the availability of the &TeX; installation
      and works under Windows and MacOS as well.
      Since &Wedderga; is distributed together with its manual,
      it is not necessary for the user to use this function. Normally
      it is intended to be used by the developers only.
   </Description>
</ManSection>

</Section>

</Chapter>