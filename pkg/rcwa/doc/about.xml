<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  about.xml           RCWA documentation           Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:AboutRCWA"><Heading>About the RCWA Package</Heading>

<!-- #################################################################### -->

<Section Label="sec:motivation">
<Heading>Motivation</Heading>

<Index Key="Collatz conjecture">Collatz conjecture</Index>
<Index Key="Collatz conjecture">Collatz mapping</Index>
The development of this package has originally been inspired by the famous
<M>3n+1</M>-Conjecture, which asserts that iterated application of the
<E>Collatz mapping</E>
<Alt Only="LaTeX">
  <Display>
  <![CDATA[
    T: \ \ \mathbb{Z} \longrightarrow \mathbb{Z}, \ \ \ \
    n \ \longmapsto \
    \begin{cases}
      \frac{n}{2}    & \text{if} \ \ n \ \ \text{is even}, \\
      \frac{3n+1}{2} & \text{if} \ \ n \ \ \text{is odd}
    \end{cases}
  ]]>
  </Display>
</Alt>
<Alt Only="HTML"><![CDATA[<center>
  <img src = "collatz.png" width = "342" height = "63"
       alt = "T: Z -> Z, n |-> (n/2 if n even, (3n+1)/2 if n odd)"/>
</center>]]></Alt>
<Alt Only="Text"><Verb><![CDATA[
                                       /
                                      | n/2 if n even,
               T:  Z -> Z,   n  |->  <
                                      | (3n+1)/2 if n odd
                                       \
]]></Verb></Alt>
to any given positive integer eventually yields&nbsp;1
(cf.&nbsp;<Cite Key="Lagarias06"/>). <P/>

So far, no attempts have been made to investigate the structure of groups
whose elements are permutations which are <Q>similar to the Collatz
mapping</Q>, i.e. <E>residue-class-wise affine</E>. <P/>

After having investigated these groups for a couple of years,
the author felt that this is a gap which is worth to be filled.

</Section>

<!-- #################################################################### -->

<Section Label="sec:Purpose">
<Heading>Purpose of this package</Heading>

Most research in computational group theory focusses mainly on finite
permutation groups, matrix groups, finitely presented groups, polycyclically
presented groups and automata groups.
For details, we refer to&nbsp;<Cite Key="HoltEickOBrien05"/>. <P/>
The purpose of this package is twofold:

<List>

  <Item>
    On the one hand, it deals with another large class of groups which are
    accessible to computational methods, and it therefore extends the
    range of groups which can be dealt with by means of computation.
  </Item>

  <Item>
    On the other, residue-class-wise affine groups appear to be interesting
    mathematical objects in their own right, and this package is intended
    to serve as a tool to obtain a better understanding of their rich and
    often complicated group theoretical and combinatorial structure.
  </Item>

</List>

</Section>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<!-- #################################################################### -->

<Section Label="sec:GroupsWhichEmbed">
<Heading>Groups which this package can deal with</Heading>

In principle this package permits to construct and investigate all groups
which have faithful representations as residue-class-wise affine groups.
Among many others, the following groups and their subgroups belong to this
class:

<List>

  <Item>
    Finite groups, and certain divisible torsion groups which they
    embed into.
  </Item>

  <Item>
    Free groups of finite rank.
  </Item>

  <Item>
    Free products of finitely many finite groups, thus in particular
    the modular group PSL(2,&ZZ;).
  </Item>

  <Item>
    Direct products of the above groups.
  </Item>

  <Item>
    Wreath products of the above groups with finite groups and
    with&nbsp;(&ZZ;,+).
  </Item>

</List>

This list permits already to conclude that there are finitely generated
residue-class-wise affine groups which do not have finite presentations,
and such with algorithmically unsolvable membership problem.
However the list is certainly by far not exhaustive, and using this
package it is easy to construct groups of types which are not mentioned
there. <P/>

The group CT(&ZZ;) which is generated by all <E>class transpositions</E>
of&nbsp;&ZZ; -- these are involutions which interchange two disjoint residue
classes, see <Ref Func="ClassTransposition" Label="r1, m1, r2, m2"/>
-- is a simple group which has subgroups of all types listed above.
It is countable, but it has an uncountable series of simple subgroups
which is parametrized by the sets of odd primes. <P/>

Proofs of most of the results mentioned here can be found
in&nbsp;<Cite Key="Kohl09"/>. Descriptions of a part of the algorithms
and methods which are implemented in this package can be found
in&nbsp;<Cite Key="Kohl08b"/>.

</Section>

<!-- #################################################################### -->

<Section Label="sec:Scope">
<Heading>Scope of this package</Heading>

This package can be applied in various ways to various different problems,
and it is simply not possible to say what can be found out with its help
about which groups. The best way to get an idea about this is likely to
experiment with the examples discussed in this manual. <P/>

Of course this package often does not provide an out-of-the-box solution
for a given problem. Quite often it is possible to find an answer for
a given question by using an interactive trial-and-error approach. <P/>

With substancial help of this package, the author has found the results
mentioned in Section&nbsp;<Ref Label="sec:GroupsWhichEmbed"/>.
Interactive sessions with this package have also lead to the development
of most of the algorithms which are now implemented in it. Just to mention
one example, developing the factorization method for residue-class-wise
affine permutations (see&nbsp;<Ref Attr="FactorizationIntoCSCRCT"
Label="for an rcwa permutation of Z"/>) solely by means of theory would
likely have been very hard.

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->
