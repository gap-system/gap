<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (guava) - Chapter 6: Manipulating Codes</title>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="pcenter"><table class="chlink"><tr><td class="chlink1">Goto Chapter: </td><td><a href="chap0.html">Top</a></td><td><a href="chap1.html">1</a></td><td><a href="chap2.html">2</a></td><td><a href="chap3.html">3</a></td><td><a href="chap4.html">4</a></td><td><a href="chap5.html">5</a></td><td><a href="chap6.html">6</a></td><td><a href="chap7.html">7</a></td><td><a href="chapBib.html">Bib</a></td><td><a href="chapInd.html">Ind</a></td></tr></table><br /></div>
<p><a id="s0ss0" name="s0ss0"></a></p>

<h3>6. Manipulating Codes</h3>

<p>In this chapter we describe several functions <strong class="pkg">GUAVA</strong> uses to manipulate codes. Some of the best codes are obtained by starting with for example a BCH code, and manipulating it.</p>

<p>In some cases, it is faster to perform calculations with a manipulated code than to use the original code. For example, if the dimension of the code is larger than half the word length, it is generally faster to compute the weight distribution by first calculating the weight distribution of the dual code than by directly calculating the weight distribution of the original code. The size of the dual code is smaller in these cases.</p>

<p>Because <strong class="pkg">GUAVA</strong> keeps all information in a code record, in some cases the information can be preserved after manipulations. Therefore, computations do not always have to start from scratch.</p>

<p>In Section <a href="chap6.html#s1ss0"><b>6.1</b></a>, we describe functions that take a code with certain parameters, modify it in some way and return a different code (see <code class="func">ExtendedCode</code> (<a href="chap6.html#s1ss1"><b>6.1-1</b></a>), <code class="func">PuncturedCode</code> (<a href="chap6.html#s1ss2"><b>6.1-2</b></a>), <code class="func">EvenWeightSubcode</code> (<a href="chap6.html#s1ss3"><b>6.1-3</b></a>), <code class="func">PermutedCode</code> (<a href="chap6.html#s1ss4"><b>6.1-4</b></a>), <code class="func">ExpurgatedCode</code> (<a href="chap6.html#s1ss5"><b>6.1-5</b></a>), <code class="func">AugmentedCode</code> (<a href="chap6.html#s1ss6"><b>6.1-6</b></a>), <code class="func">RemovedElementsCode</code> (<a href="chap6.html#s1ss7"><b>6.1-7</b></a>), <code class="func">AddedElementsCode</code> (<a href="chap6.html#s1ss8"><b>6.1-8</b></a>), <code class="func">ShortenedCode</code> (<a href="chap6.html#s1ss9"><b>6.1-9</b></a>), <code class="func">LengthenedCode</code> (<a href="chap6.html#s1ss10"><b>6.1-10</b></a>), <code class="func">ResidueCode</code> (<a href="chap6.html#s1ss11"><b>6.1-11</b></a>), <code class="func">ConstructionBCode</code> (<a href="chap6.html#s1ss12"><b>6.1-12</b></a>), <code class="func">DualCode</code> (<a href="chap6.html#s1ss13"><b>6.1-13</b></a>), <code class="func">ConversionFieldCode</code> (<a href="chap6.html#s1ss14"><b>6.1-14</b></a>), <code class="func">ConstantWeightSubcode</code> (<a href="chap6.html#s1ss16"><b>6.1-16</b></a>), <code class="func">StandardFormCode</code> (<a href="chap6.html#s1ss17"><b>6.1-17</b></a>) and <code class="func">CosetCode</code> (<a href="chap6.html#s1ss15"><b>6.1-15</b></a>)). In Section <a href="chap6.html#s2ss0"><b>6.2</b></a>, we describe functions that generate a new code out of two codes (see <code class="func">DirectSumCode</code> (<a href="chap6.html#s2ss1"><b>6.2-1</b></a>), <code class="func">UUVCode</code> (<a href="chap6.html#s2ss2"><b>6.2-2</b></a>), <code class="func">DirectProductCode</code> (<a href="chap6.html#s2ss3"><b>6.2-3</b></a>), <code class="func">IntersectionCode</code> (<a href="chap6.html#s2ss4"><b>6.2-4</b></a>) and <code class="func">UnionCode</code> (<a href="chap6.html#s2ss5"><b>6.2-5</b></a>)).</p>

<p><a id="s1ss0" name="s1ss0"></a></p>

<h4>6.1 
Functions that Generate a New Code from a Given Code
</h4>

<p><a id="s1ss1" name="s1ss1"></a></p>

<h5>6.1-1 ExtendedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ExtendedCode</code>( <var>C[, i]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ExtendedCode</code> extends the code <var>C</var> <var>i</var> times and returns the result. <var>i</var> is equal to 1 by default. Extending is done by adding a parity check bit after the last coordinate. The coordinates of all codewords now add up to zero. In the binary case, each codeword has even weight.</p>

<p>The word length increases by <var>i</var>. The size of the code remains the same. In the binary case, the minimum distance increases by one if it was odd. In other cases, that is not always true.</p>

<p>A cyclic code in general is no longer cyclic after extending.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := HammingCode( 3, GF(2) );
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
gap&gt; C2 := ExtendedCode( C1 );
a linear [8,4,4]2 extended code
gap&gt; IsEquivalent( C2, ReedMullerCode( 1, 3 ) );
true
gap&gt; List( AsSSortedList( C2 ), WeightCodeword );
[ 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8 ]
gap&gt; C3 := EvenWeightSubcode( C1 );
a linear [7,3,4]2..3 even weight subcode 

</pre></td></tr></table>

<p>To undo extending, call <code class="code">PuncturedCode</code> (see <code class="func">PuncturedCode</code> (<a href="chap6.html#s1ss2"><b>6.1-2</b></a>)). The function <code class="code">EvenWeightSubcode</code> (see <code class="func">EvenWeightSubcode</code> (<a href="chap6.html#s1ss3"><b>6.1-3</b></a>)) also returns a related code with only even weights, but without changing its word length.</p>

<p><a id="s1ss2" name="s1ss2"></a></p>

<h5>6.1-2 PuncturedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PuncturedCode</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">PuncturedCode</code> punctures <var>C</var> in the last column, and returns the result. Puncturing is done simply by cutting off the last column from each codeword. This means the word length decreases by one. The minimum distance in general also decrease by one.</p>

<p>This command can also be called with the syntax <code class="code">PuncturedCode( C, L )</code>. In this case, <code class="code">PuncturedCode</code> punctures <var>C</var> in the columns specified by <var>L</var>, a list of integers. All columns specified by <var>L</var> are omitted from each codeword. If l is the length of <var>L</var> (so the number of removed columns), the word length decreases by l. The minimum distance can also decrease by l or less.</p>

<p>Puncturing a cyclic code in general results in a non-cyclic code. If the code is punctured in all the columns where a word of minimal weight is unequal to zero, the dimension of the resulting code decreases.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := BCHCode( 15, 5, GF(2) );
a cyclic [15,7,5]3..5 BCH code, delta=5, b=1 over GF(2)
gap&gt; C2 := PuncturedCode( C1 );
a linear [14,7,4]3..5 punctured code
gap&gt; ExtendedCode( C2 ) = C1;
false
gap&gt; PuncturedCode( C1, [1,2,3,4,5,6,7] );
a linear [8,7,1]1 punctured code
gap&gt; PuncturedCode( WholeSpaceCode( 4, GF(5) ) );
a linear [3,3,1]0 punctured code  # The dimension decreased from 4 to 3 

</pre></td></tr></table>

<p><code class="code">ExtendedCode</code> extends the code again (see <code class="func">ExtendedCode</code> (<a href="chap6.html#s1ss1"><b>6.1-1</b></a>)), although in general this does not result in the old code.</p>

<p><a id="s1ss3" name="s1ss3"></a></p>

<h5>6.1-3 EvenWeightSubcode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; EvenWeightSubcode</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">EvenWeightSubcode</code> returns the even weight subcode of <var>C</var>, consisting of all codewords of <var>C</var> with even weight. If <var>C</var> is a linear code and contains words of odd weight, the resulting code has a dimension of one less. The minimum distance always increases with one if it was odd. If <var>C</var> is a binary cyclic code, and g(x) is its generator polynomial, the even weight subcode either has generator polynomial g(x) (if g(x) is divisible by x-1) or g(x)* (x-1) (if no factor x-1 was present in g(x)). So the even weight subcode is again cyclic.</p>

<p>Of course, if all codewords of <var>C</var> are already of even weight, the returned code is equal to <var>C</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := EvenWeightSubcode( BCHCode( 8, 4, GF(3) ) );
an (8,33,4..8)3..8 even weight subcode
gap&gt; List( AsSSortedList( C1 ), WeightCodeword );
[ 0, 4, 4, 4, 4, 4, 4, 6, 4, 4, 4, 4, 6, 4, 4, 6, 4, 4, 8, 6, 4, 6, 8, 4, 4, 
  4, 6, 4, 6, 8, 4, 6, 8 ]
gap&gt; EvenWeightSubcode( ReedMullerCode( 1, 3 ) );
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2) 

</pre></td></tr></table>

<p><code class="code">ExtendedCode</code> also returns a related code of only even weights, but without reducing its dimension (see <code class="func">ExtendedCode</code> (<a href="chap6.html#s1ss1"><b>6.1-1</b></a>)).</p>

<p><a id="s1ss4" name="s1ss4"></a></p>

<h5>6.1-4 PermutedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PermutedCode</code>( <var>C, L</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">PermutedCode</code> returns <var>C</var> after column permutations. <var>L</var> (in <strong class="pkg">GAP</strong> disjoint cycle notation) is the permutation to be executed on the columns of <var>C</var>. If <var>C</var> is cyclic, the result in general is no longer cyclic. If a permutation results in the same code as <var>C</var>, this permutation belongs to the automorphism group of <var>C</var> (see <code class="func">AutomorphismGroup</code> (<a href="chap3.html#s4ss3"><b>3.4-3</b></a>)). In any case, the returned code is equivalent to <var>C</var> (see <code class="func">IsEquivalent</code> (<a href="chap3.html#s4ss1"><b>3.4-1</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := PuncturedCode( ReedMullerCode( 1, 4 ) );
a linear [15,5,7]5 punctured code
gap&gt; C2 := BCHCode( 15, 7, GF(2) );
a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
gap&gt; C2 = C1;
false
gap&gt; p := CodeIsomorphism( C1, C2 );
( 2, 4,14, 9,13, 7,11,10, 6, 8,12, 5)
gap&gt; C3 := PermutedCode( C1, p );
a linear [15,5,7]5 permuted code
gap&gt; C2 = C3;
true 

</pre></td></tr></table>

<p><a id="s1ss5" name="s1ss5"></a></p>

<h5>6.1-5 ExpurgatedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ExpurgatedCode</code>( <var>C, L</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ExpurgatedCode</code> expurgates the code <var>C</var>&gt; by throwing away codewords in list <var>L</var>. <var>C</var> must be a linear code. <var>L</var> must be a list of codeword input. The generator matrix of the new code no longer is a basis for the codewords specified by <var>L</var>. Since the returned code is still linear, it is very likely that, besides the words of <var>L</var>, more codewords of <var>C</var> are no longer in the new code.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := HammingCode( 4 );; WeightDistribution( C1 );
[ 1, 0, 0, 35, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
gap&gt; L := Filtered( AsSSortedList(C1), i -&gt; WeightCodeword(i) = 3 );;
gap&gt; C2 := ExpurgatedCode( C1, L );
a linear [15,4,3..4]5..11 code, expurgated with 7 word(s)
gap&gt; WeightDistribution( C2 );
[ 1, 0, 0, 0, 14, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 ] 

</pre></td></tr></table>

<p>This function does not work on non-linear codes. For removing words from a non-linear code, use <code class="code">RemovedElementsCode</code> (see <code class="func">RemovedElementsCode</code> (<a href="chap6.html#s1ss7"><b>6.1-7</b></a>)). For expurgating a code of all words of odd weight, use `EvenWeightSubcode' (see <code class="func">EvenWeightSubcode</code> (<a href="chap6.html#s1ss3"><b>6.1-3</b></a>)).</p>

<p><a id="s1ss6" name="s1ss6"></a></p>

<h5>6.1-6 AugmentedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AugmentedCode</code>( <var>C, L</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">AugmentedCode</code> returns <var>C</var> after augmenting. <var>C</var> must be a linear code, <var>L</var> must be a list of codeword inputs. The generator matrix of the new code is a basis for the codewords specified by <var>L</var> as well as the words that were already in code <var>C</var>. Note that the new code in general will consist of more words than only the codewords of <var>C</var> and the words <var>L</var>. The returned code is also a linear code.</p>

<p>This command can also be called with the syntax <code class="code">AugmentedCode(C)</code>. When called without a list of codewords, <code class="code">AugmentedCode</code> returns <var>C</var> after adding the all-ones vector to the generator matrix. <var>C</var> must be a linear code. If the all-ones vector was already in the code, nothing happens and a copy of the argument is returned. If <var>C</var> is a binary code which does not contain the all-ones vector, the complement of all codewords is added.</p>


<table class="example">
<tr><td><pre>

gap&gt; C31 := ReedMullerCode( 1, 3 );
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
gap&gt; C32 := AugmentedCode(C31,["00000011","00000101","00010001"]);
a linear [8,7,1..2]1 code, augmented with 3 word(s)
gap&gt; C32 = ReedMullerCode( 2, 3 );
true 
gap&gt; C1 := CordaroWagnerCode(6);
a linear [6,2,4]2..3 Cordaro-Wagner code over GF(2)
gap&gt; Codeword( [0,0,1,1,1,1] ) in C1;
true
gap&gt; C2 := AugmentedCode( C1 );
a linear [6,3,1..2]2..3 code, augmented with 1 word(s)
gap&gt; Codeword( [1,1,0,0,0,0] ) in C2;
true

</pre></td></tr></table>

<p>The function <code class="code">AddedElementsCode</code> adds elements to the codewords instead of adding them to the basis (see <code class="func">AddedElementsCode</code> (<a href="chap6.html#s1ss8"><b>6.1-8</b></a>)).</p>

<p><a id="s1ss7" name="s1ss7"></a></p>

<h5>6.1-7 RemovedElementsCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RemovedElementsCode</code>( <var>C, L</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">RemovedElementsCode</code> returns code <var>C</var> after removing a list of codewords <var>L</var> from its elements. <var>L</var> must be a list of codeword input. The result is an unrestricted code.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := HammingCode( 4 );; WeightDistribution( C1 );
[ 1, 0, 0, 35, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
gap&gt; L := Filtered( AsSSortedList(C1), i -&gt; WeightCodeword(i) = 3 );;
gap&gt; C2 := RemovedElementsCode( C1, L );
a (15,2013,3..15)2..15 code with 35 word(s) removed
gap&gt; WeightDistribution( C2 );
[ 1, 0, 0, 0, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
gap&gt; MinimumDistance( C2 );
3        # C2 is not linear, so the minimum weight does not have to
         # be equal to the minimum distance 

</pre></td></tr></table>

<p>Adding elements to a code is done by the function <code class="code">AddedElementsCode</code> (see <code class="func">AddedElementsCode</code> (<a href="chap6.html#s1ss8"><b>6.1-8</b></a>)). To remove codewords from the base of a linear code, use <code class="code">ExpurgatedCode</code> (see <code class="func">ExpurgatedCode</code> (<a href="chap6.html#s1ss5"><b>6.1-5</b></a>)).</p>

<p><a id="s1ss8" name="s1ss8"></a></p>

<h5>6.1-8 AddedElementsCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AddedElementsCode</code>( <var>C, L</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">AddedElementsCode</code> returns code <var>C</var> after adding a list of codewords <var>L</var> to its elements. <var>L</var> must be a list of codeword input. The result is an unrestricted code.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := NullCode( 6, GF(2) );
a cyclic [6,0,6]6 nullcode over GF(2)
gap&gt; C2 := AddedElementsCode( C1, [ "111111" ] );
a (6,2,1..6)3 code with 1 word(s) added
gap&gt; IsCyclicCode( C2 );
true
gap&gt; C3 := AddedElementsCode( C2, [ "101010", "010101" ] );
a (6,4,1..6)2 code with 2 word(s) added
gap&gt; IsCyclicCode( C3 );
true 

</pre></td></tr></table>

<p>To remove elements from a code, use <code class="code">RemovedElementsCode</code> (see <code class="func">RemovedElementsCode</code> (<a href="chap6.html#s1ss7"><b>6.1-7</b></a>)). To add elements to the base of a linear code, use <code class="code">AugmentedCode</code> (see <code class="func">AugmentedCode</code> (<a href="chap6.html#s1ss6"><b>6.1-6</b></a>)).</p>

<p><a id="s1ss9" name="s1ss9"></a></p>

<h5>6.1-9 ShortenedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ShortenedCode</code>( <var>C[, L]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ShortenedCode( C )</code> returns the code <var>C</var> shortened by taking a cross section. If <var>C</var> is a linear code, this is done by removing all codewords that start with a non-zero entry, after which the first column is cut off. If <var>C</var> was a [n,k,d] code, the shortened code generally is a [n-1,k-1,d] code. It is possible that the dimension remains the same; it is also possible that the minimum distance increases.</p>

<p>If <var>C</var> is a non-linear code, <code class="code">ShortenedCode</code> first checks which finite field element occurs most often in the first column of the codewords. The codewords not starting with this element are removed from the code, after which the first column is cut off. The resulting shortened code has at least the same minimum distance as <var>C</var>.</p>

<p>This command can also be called using the syntax <code class="code">ShortenedCode(C,L)</code>. When called in this format, <code class="code">ShortenedCode</code> repeats the shortening process on each of the columns specified by <var>L</var>. <var>L</var> therefore is a list of integers. The column numbers in <var>L</var> are the numbers as they are before the shortening process. If <var>L</var> has l entries, the returned code has a word length of l positions shorter than <var>C</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := HammingCode( 4 );
a linear [15,11,3]1 Hamming (4,2) code over GF(2)
gap&gt; C2 := ShortenedCode( C1 );
a linear [14,10,3]2 shortened code
gap&gt; C3 := ElementsCode( ["1000", "1101", "0011" ], GF(2) );
a (4,3,1..4)2 user defined unrestricted code over GF(2)
gap&gt; MinimumDistance( C3 );
2
gap&gt; C4 := ShortenedCode( C3 );
a (3,2,2..3)1..2 shortened code
gap&gt; AsSSortedList( C4 );
[ [ 0 0 0 ], [ 1 0 1 ] ]
gap&gt; C5 := HammingCode( 5, GF(2) );
a linear [31,26,3]1 Hamming (5,2) code over GF(2)
gap&gt; C6 := ShortenedCode( C5, [ 1, 2, 3 ] );
a linear [28,23,3]2 shortened code
gap&gt; OptimalityLinearCode( C6 );
0

</pre></td></tr></table>

<p>The function <code class="code">LengthenedCode</code> lengthens the code again (only for linear codes), see <code class="func">LengthenedCode</code> (<a href="chap6.html#s1ss10"><b>6.1-10</b></a>). In general, this is not exactly the inverse function.</p>

<p><a id="s1ss10" name="s1ss10"></a></p>

<h5>6.1-10 LengthenedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LengthenedCode</code>( <var>C[, i]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">LengthenedCode( C )</code> returns the code <var>C</var> lengthened. <var>C</var> must be a linear code. First, the all-ones vector is added to the generator matrix (see <code class="func">AugmentedCode</code> (<a href="chap6.html#s1ss6"><b>6.1-6</b></a>)). If the all-ones vector was already a codeword, nothing happens to the code. Then, the code is extended <var>i</var> times (see <code class="func">ExtendedCode</code> (<a href="chap6.html#s1ss1"><b>6.1-1</b></a>)). <var>i</var> is equal to 1 by default. If <var>C</var> was an [n,k] code, the new code generally is a [n+i,k+1] code.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := CordaroWagnerCode( 5 );
a linear [5,2,3]2 Cordaro-Wagner code over GF(2)
gap&gt; C2 := LengthenedCode( C1 );
a linear [6,3,2]2..3 code, lengthened with 1 column(s) 

</pre></td></tr></table>

<p><code class="code">ShortenedCode</code>' shortens the code, see <code class="func">ShortenedCode</code> (<a href="chap6.html#s1ss9"><b>6.1-9</b></a>). In general, this is not exactly the inverse function.</p>

<p><a id="s1ss11" name="s1ss11"></a></p>

<h5>6.1-11 ResidueCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ResidueCode</code>( <var>C[, c]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The function <code class="code">ResidueCode</code> takes a codeword <var>c</var> of <var>C</var> (if <var>c</var> is omitted, a codeword of minimal weight is used). It removes this word and all its linear combinations from the code and then punctures the code in the coordinates where <var>c</var> is unequal to zero. The resulting code is an [n-w, k-1, d-lfloor w*(q-1)/q rfloor ] code. <var>C</var> must be a linear code and <var>c</var> must be non-zero. If <var>c</var> is not in <var></var> then no change is made to <var>C</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := BCHCode( 15, 7 );
a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
gap&gt; C2 := ResidueCode( C1 );
a linear [8,4,4]2 residue code
gap&gt; c := Codeword( [ 0,0,0,1,0,0,1,1,0,1,0,1,1,1,1 ], C1);;
gap&gt; C3 := ResidueCode( C1, c );
a linear [7,4,3]1 residue code 

</pre></td></tr></table>

<p><a id="s1ss12" name="s1ss12"></a></p>

<h5>6.1-12 ConstructionBCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ConstructionBCode</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The function <code class="code">ConstructionBCode</code> takes a binary linear code <var>C</var> and calculates the minimum distance of the dual of <var>C</var> (see <code class="func">DualCode</code> (<a href="chap6.html#s1ss13"><b>6.1-13</b></a>)). It then removes the columns of the parity check matrix of <var>C</var> where a codeword of the dual code of minimal weight has coordinates unequal to zero. The resulting matrix is a parity check matrix for an [n-dd, k-dd+1, &gt;= d] code, where dd is the minimum distance of the dual of <var>C</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := ReedMullerCode( 2, 5 );
a linear [32,16,8]6 Reed-Muller (2,5) code over GF(2)
gap&gt; C2 := ConstructionBCode( C1 );
a linear [24,9,8]5..10 Construction B (8 coordinates)
gap&gt; BoundsMinimumDistance( 24, 9, GF(2) );
rec( n := 24, k := 9, q := 2, references := rec(  ), 
  construction := [ [ Operation "UUVCode" ], 
      [ [ [ Operation "UUVCode" ], [ [ [ Operation "DualCode" ], 
                      [ [ [ Operation "RepetitionCode" ], [ 6, 2 ] ] ] ], 
                  [ [ Operation "CordaroWagnerCode" ], [ 6 ] ] ] ], 
          [ [ Operation "CordaroWagnerCode" ], [ 12 ] ] ] ], lowerBound := 8, 
  lowerBoundExplanation := [ "Lb(24,9)=8, u u+v construction of C1 and C2:", 
      "Lb(12,7)=4, u u+v construction of C1 and C2:", 
      "Lb(6,5)=2, dual of the repetition code", 
      "Lb(6,2)=4, Cordaro-Wagner code", "Lb(12,2)=8, Cordaro-Wagner code" ], 
  upperBound := 8, 
  upperBoundExplanation := [ "Ub(24,9)=8, otherwise construction B would 
                             contradict:", "Ub(18,4)=8, Griesmer bound" ] )
# so C2 is optimal

</pre></td></tr></table>

<p><a id="s1ss13" name="s1ss13"></a></p>

<h5>6.1-13 DualCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DualCode</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">DualCode</code> returns the dual code of <var>C</var>. The dual code consists of all codewords that are orthogonal to the codewords of <var>C</var>. If <var>C</var> is a linear code with generator matrix G, the dual code has parity check matrix G (or if <var>C</var> has parity check matrix H, the dual code has generator matrix H). So if <var>C</var> is a linear [n, k] code, the dual code of <var>C</var> is a linear [n, n-k] code. If <var>C</var> is a cyclic code with generator polynomial g(x), the dual code has the reciprocal polynomial of g(x) as check polynomial.</p>

<p>The dual code is always a linear code, even if <var>C</var> is non-linear.</p>

<p>If a code <var>C</var> is equal to its dual code, it is called <em>self-dual</em>.</p>


<table class="example">
<tr><td><pre>

gap&gt; R := ReedMullerCode( 1, 3 );
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
gap&gt; RD := DualCode( R );
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
gap&gt; R = RD;
true
gap&gt; N := WholeSpaceCode( 7, GF(4) );
a cyclic [7,7,1]0 whole space code over GF(4)
gap&gt; DualCode( N ) = NullCode( 7, GF(4) );
true 

</pre></td></tr></table>

<p><a id="s1ss14" name="s1ss14"></a></p>

<h5>6.1-14 ConversionFieldCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ConversionFieldCode</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ConversionFieldCode</code> returns code <var>C</var> after converting its field. If the field of <var>C</var> is GF(q^m), the returned code has field GF(q). Each symbol of every codeword is replaced by a concatenation of m symbols from GF(q). If <var>C</var> is an (n, M, d_1) code, the returned code is a (n* m, M, d_2) code, where d_2 &gt; d_1.</p>

<p>See also <code class="func">HorizontalConversionFieldMat</code> (<a href="chap7.html#s3ss10"><b>7.3-10</b></a>).</p>


<table class="example">
<tr><td><pre>

gap&gt; R := RepetitionCode( 4, GF(4) );
a cyclic [4,1,4]3 repetition code over GF(4)
gap&gt; R2 := ConversionFieldCode( R );
a linear [8,2,4]3..4 code, converted to basefield GF(2)
gap&gt; Size( R ) = Size( R2 );
true
gap&gt; GeneratorMat( R );
[ [ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ] ]
gap&gt; GeneratorMat( R2 );
[ [ Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2) ],
  [ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ] ] 

</pre></td></tr></table>

<p><a id="s1ss15" name="s1ss15"></a></p>

<h5>6.1-15 CosetCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CosetCode</code>( <var>C, w</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CosetCode</code> returns the coset of a code <var>C</var> with respect to word <var>w</var>. <var>w</var> must be of the codeword type. Then, <var>w</var> is added to each codeword of <var>C</var>, yielding the elements of the new code. If <var>C</var> is linear and <var>w</var> is an element of <var>C</var>, the new code is equal to <var>C</var>, otherwise the new code is an unrestricted code.</p>

<p>Generating a coset is also possible by simply adding the word <var>w</var> to <var>C</var>. See <a href="chap3.html#s2ss0"><b>3.2</b></a>.</p>


<table class="example">
<tr><td><pre>

gap&gt; H := HammingCode(3, GF(2));
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
gap&gt; c := Codeword("1011011");; c in H;
false
gap&gt; C := CosetCode(H, c);
a (7,16,3)1 coset code
gap&gt; List(AsSSortedList(C), el-&gt; Syndrome(H, el));
[ [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ],
  [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ],
  [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ] ]
# All elements of the coset have the same syndrome in H 

</pre></td></tr></table>

<p><a id="s1ss16" name="s1ss16"></a></p>

<h5>6.1-16 ConstantWeightSubcode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ConstantWeightSubcode</code>( <var>C, w</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ConstantWeightSubcode</code> returns the subcode of <var>C</var> that only has codewords of weight <var>w</var>. The resulting code is a non-linear code, because it does not contain the all-zero vector.</p>

<p>This command also can be called with the syntax <code class="code">ConstantWeightSubcode(C)</code> In this format, <code class="code">ConstantWeightSubcode</code> returns the subcode of <var>C</var> consisting of all minimum weight codewords of <var>C</var>.</p>

<p><code class="code">ConstantWeightSubcode</code> first checks if Leon's binary <code class="code">wtdist</code> exists on your computer (in the default directory). If it does, then this program is called. Otherwise, the constant weight subcode is computed using a GAP program which checks each codeword in <var>C</var> to see if it is of the desired weight.</p>


<table class="example">
<tr><td><pre>

gap&gt; N := NordstromRobinsonCode();; WeightDistribution(N);
[ 1, 0, 0, 0, 0, 0, 112, 0, 30, 0, 112, 0, 0, 0, 0, 0, 1 ]
gap&gt; C := ConstantWeightSubcode(N, 8);
a (16,30,6..16)5..8 code with codewords of weight 8
gap&gt; WeightDistribution(C);
[ 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0 ] 
gap&gt; eg := ExtendedTernaryGolayCode();; WeightDistribution(eg);
[ 1, 0, 0, 0, 0, 0, 264, 0, 0, 440, 0, 0, 24 ]
gap&gt; C := ConstantWeightSubcode(eg);
a (12,264,6..12)3..6 code with codewords of weight 6
gap&gt; WeightDistribution(C);
[ 0, 0, 0, 0, 0, 0, 264, 0, 0, 0, 0, 0, 0 ] 

</pre></td></tr></table>

<p><a id="s1ss17" name="s1ss17"></a></p>

<h5>6.1-17 StandardFormCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; StandardFormCode</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">StandardFormCode</code> returns <var>C</var> after putting it in standard form. If <var>C</var> is a non-linear code, this means the elements are organized using lexicographical order. This means they form a legal <strong class="pkg">GAP</strong> `Set'.</p>

<p>If <var>C</var> is a linear code, the generator matrix and parity check matrix are put in standard form. The generator matrix then has an identity matrix in its left part, the parity check matrix has an identity matrix in its right part. Although <strong class="pkg">GUAVA</strong> always puts both matrices in a standard form using <code class="code">BaseMat</code>, this never alters the code. <code class="code">StandardFormCode</code> even applies column permutations if unavoidable, and thereby changes the code. The column permutations are recorded in the construction history of the new code (see <code class="func">Display</code> (<a href="chap3.html#s6ss3"><b>3.6-3</b></a>)). <var>C</var> and the new code are of course equivalent.</p>

<p>If <var>C</var> is a cyclic code, its generator matrix cannot be put in the usual upper triangular form, because then it would be inconsistent with the generator polynomial. The reason is that generating the elements from the generator matrix would result in a different order than generating the elements from the generator polynomial. This is an unwanted effect, and therefore <code class="code">StandardFormCode</code> just returns a copy of <var>C</var> for cyclic codes.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := GeneratorMatCode( Z(2) * [ [0,1,1,0], [0,1,0,1], [0,0,1,1] ],
&gt; "random form code", GF(2) );
a linear [4,2,1..2]1..2 random form code over GF(2)
gap&gt; Codeword( GeneratorMat( G ) );
[ [ 0 1 0 1 ], [ 0 0 1 1 ] ]
gap&gt; Codeword( GeneratorMat( StandardFormCode( G ) ) );
[ [ 1 0 0 1 ], [ 0 1 0 1 ] ] 

</pre></td></tr></table>

<p><a id="s1ss18" name="s1ss18"></a></p>

<h5>6.1-18 PiecewiseConstantCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PiecewiseConstantCode</code>( <var>part, wts[, F]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">PiecewiseConstantCode</code> returns a code with length n = sum n_i, where <var>part</var>=[ n_1, dots, n_k ]. <var>wts</var> is a list of <var>constraints</var> w=(w_1,...,w_k), each of length k, where 0 &lt;= w_i &lt;= n_i. The default field is GF(2).</p>

<p>A constraint is a list of integers, and a word c = ( c_1, dots, c_k ) (according to <var>part</var>, i.e., each c_i is a subword of length n_i) is in the resulting code if and only if, for some constraint w in <var>wts</var>, |c_i| = w_i$ for all $1 &lt;= i &lt;= k, where | ...| denotes the Hamming weight.</p>

<p>An example might make things clearer:</p>


<table class="example">
<tr><td><pre>

gap&gt; PiecewiseConstantCode( [ 2, 3 ],
&gt; [ [ 0, 0 ], [ 0, 3 ], [ 1, 0 ], [ 2, 2 ] ],
&gt; GF(2) );
a (5,7,1..5)1..5 piecewise constant code over GF(2)
gap&gt; AsSSortedList(last);
[ [ 0 0 0 0 0 ], [ 0 0 1 1 1 ], [ 0 1 0 0 0 ], [ 1 0 0 0 0 ], [ 1 1 0 1 1 ], 
  [ 1 1 1 0 1 ], [ 1 1 1 1 0 ] ]

</pre></td></tr></table>

<p>The first constraint is satisfied by codeword 1, the second by codeword 2, the third by codewords 3 and 4, and the fourth by codewords 5, 6 and 7.</p>

<p><a id="s2ss0" name="s2ss0"></a></p>

<h4>6.2 
Functions that Generate a New Code from Two Given Codes
</h4>

<p><a id="s2ss1" name="s2ss1"></a></p>

<h5>6.2-1 DirectSumCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DirectSumCode</code>( <var>C1, C2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">DirectSumCode</code> returns the direct sum of codes <var>C1</var> and <var>C2</var>. The direct sum code consists of every codeword of <var>C1</var> concatenated by every codeword of <var>C2</var>. Therefore, if <var>Ci</var> was a (n_i,M_i,d_i) code, the result is a (n_1+n_2,M_1*M_2,min(d_1,d_2)) code.</p>

<p>If both <var>C1</var> and <var>C2</var> are linear codes, the result is also a linear code. If one of them is non-linear, the direct sum is non-linear too. In general, a direct sum code is not cyclic.</p>

<p>Performing a direct sum can also be done by adding two codes (see Section <a href="chap3.html#s2ss0"><b>3.2</b></a>). Another often used method is the `u, u+v'-construction, described in <code class="func">UUVCode</code> (<a href="chap6.html#s2ss2"><b>6.2-2</b></a>).</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := ElementsCode( [ [1,0], [4,5] ], GF(7) );;
gap&gt; C2 := ElementsCode( [ [0,0,0], [3,3,3] ], GF(7) );;
gap&gt; D := DirectSumCode(C1, C2);;
gap&gt; AsSSortedList(D);
[ [ 1 0 0 0 0 ], [ 1 0 3 3 3 ], [ 4 5 0 0 0 ], [ 4 5 3 3 3 ] ]
gap&gt; D = C1 + C2;   # addition = direct sum
true 

</pre></td></tr></table>

<p><a id="s2ss2" name="s2ss2"></a></p>

<h5>6.2-2 UUVCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UUVCode</code>( <var>C1, C2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">UUVCode</code> returns the so-called (u|u+v) construction applied to <var>C1</var> and <var>C2</var>. The resulting code consists of every codeword u of <var>C1</var> concatenated by the sum of u and every codeword v of <var>C2</var>. If <var>C1</var> and <var>C2</var> have different word lengths, sufficient zeros are added to the shorter code to make this sum possible. If <var>Ci</var> is a (n_i,M_i,d_i) code, the result is an (n_1+max(n_1,n_2),M_1* M_2,min(2* d_1,d_2)) code.</p>

<p>If both <var>C1</var> and <var>C2</var> are linear codes, the result is also a linear code. If one of them is non-linear, the UUV sum is non-linear too. In general, a UUV sum code is not cyclic.</p>

<p>The function <code class="code">DirectSumCode</code> returns another sum of codes (see <code class="func">DirectSumCode</code> (<a href="chap6.html#s2ss1"><b>6.2-1</b></a>)).</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := EvenWeightSubcode(WholeSpaceCode(4, GF(2)));
a cyclic [4,3,2]1 even weight subcode
gap&gt; C2 := RepetitionCode(4, GF(2));
a cyclic [4,1,4]2 repetition code over GF(2)
gap&gt; R := UUVCode(C1, C2);
a linear [8,4,4]2 U U+V construction code
gap&gt; R = ReedMullerCode(1,3);
true 

</pre></td></tr></table>

<p><a id="s2ss3" name="s2ss3"></a></p>

<h5>6.2-3 DirectProductCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DirectProductCode</code>( <var>C1, C2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">DirectProductCode</code> returns the direct product of codes <var>C1</var> and <var>C2</var>. Both must be linear codes. Suppose <var>Ci</var> has generator matrix G_i. The direct product of <var>C1</var> and <var>C2</var> then has the Kronecker product of G_1 and G_2 as the generator matrix (see the <strong class="pkg">GAP</strong> command <code class="code">KroneckerProduct</code>).</p>

<p>If <var>Ci</var> is a [n_i, k_i, d_i] code, the direct product then is an [n_1* n_2,k_1* k_2,d_1* d_2] code.</p>


<table class="example">
<tr><td><pre>

gap&gt; L1 := LexiCode(10, 4, GF(2));
a linear [10,5,4]2..4 lexicode over GF(2)
gap&gt; L2 := LexiCode(8, 3, GF(2));
a linear [8,4,3]2..3 lexicode over GF(2)
gap&gt; D := DirectProductCode(L1, L2);
a linear [80,20,12]20..45 direct product code 

</pre></td></tr></table>

<p><a id="s2ss4" name="s2ss4"></a></p>

<h5>6.2-4 IntersectionCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IntersectionCode</code>( <var>C1, C2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">IntersectionCode</code> returns the intersection of codes <var>C1</var> and <var>C2</var>. This code consists of all codewords that are both in <var>C1</var> and <var>C2</var>. If both codes are linear, the result is also linear. If both are cyclic, the result is also cyclic.</p>


<table class="example">
<tr><td><pre>

gap&gt; C := CyclicCodes(7, GF(2));
[ a cyclic [7,7,1]0 enumerated code over GF(2),
  a cyclic [7,6,1..2]1 enumerated code over GF(2),
  a cyclic [7,3,1..4]2..3 enumerated code over GF(2),
  a cyclic [7,0,7]7 enumerated code over GF(2),
  a cyclic [7,3,1..4]2..3 enumerated code over GF(2),
  a cyclic [7,4,1..3]1 enumerated code over GF(2),
  a cyclic [7,1,7]3 enumerated code over GF(2),
  a cyclic [7,4,1..3]1 enumerated code over GF(2) ]
gap&gt; IntersectionCode(C[6], C[8]) = C[7];
true 

</pre></td></tr></table>

<p>The <em>hull</em> of a linear code is the intersection of the code with its dual code. In other words, the hull of C is <code class="code">IntersectionCode(C, DualCode(C))</code>.</p>

<p><a id="s2ss5" name="s2ss5"></a></p>

<h5>6.2-5 UnionCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UnionCode</code>( <var>C1, C2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">UnionCode</code> returns the union of codes <var>C1</var> and <var>C2</var>. This code consists of the union of all codewords of <var>C1</var> and <var>C2</var> and all linear combinations. Therefore this function works only for linear codes. The function <code class="code">AddedElementsCode</code> can be used for non-linear codes, or if the resulting code should not include linear combinations. See <code class="func">AddedElementsCode</code> (<a href="chap6.html#s1ss8"><b>6.1-8</b></a>). If both arguments are cyclic, the result is also cyclic.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := GeneratorMatCode([[1,0,1],[0,1,1]]*Z(2)^0, GF(2));
a linear [3,2,1..2]1 code defined by generator matrix over GF(2)
gap&gt; H := GeneratorMatCode([[1,1,1]]*Z(2)^0, GF(2));
a linear [3,1,3]1 code defined by generator matrix over GF(2)
gap&gt; U := UnionCode(G, H);
a linear [3,3,1]0 union code
gap&gt; c := Codeword("010");; c in G;
false
gap&gt; c in H;
false
gap&gt; c in U;
true 

</pre></td></tr></table>

<p><a id="s2ss6" name="s2ss6"></a></p>

<h5>6.2-6 ExtendedDirectSumCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ExtendedDirectSumCode</code>( <var>L, B, m</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The extended direct sum construction is described in section V of Graham and Sloane <a href="chapBib.html#biBGS85">[GS85]</a>. The resulting code consists of <var>m</var> copies of <var>L</var>, extended by repeating the codewords of <var>B</var> <var>m</var> times.</p>

<p>Suppose <var>L</var> is an [n_L, k_L]r_L code, and <var>B</var> is an [n_L, k_B]r_B code (non-linear codes are also permitted). The length of <var>B</var> must be equal to the length of <var>L</var>. The length of the new code is n = m n_L, the dimension (in the case of linear codes) is k &lt;= m k_L + k_B, and the covering radius is r &lt;= lfloor m Psi( L, B ) rfloor, with</p>

<p class="pcenter">\[
\Psi( L, B ) = \max_{u \in F_2^{n_L}} \frac{1}{2^{k_B}}
               \sum_{v \in B} {\rm d}( L, v + u ).
 \]</p>

<p>However, this computation will not be executed, because it may be too time consuming for large codes.</p>

<p>If L subseteq B, and L and B are linear codes, the last copy of <var>L</var> is omitted. In this case the dimension is k = m k_L + (k_B - k_L).</p>


<table class="example">
<tr><td><pre>

gap&gt; c := HammingCode( 3, GF(2) );
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
gap&gt; d := WholeSpaceCode( 7, GF(2) );
a cyclic [7,7,1]0 whole space code over GF(2)
gap&gt; e := ExtendedDirectSumCode( c, d, 3 );
a linear [21,15,1..3]2 3-fold extended direct sum code

</pre></td></tr></table>

<p><a id="s2ss7" name="s2ss7"></a></p>

<h5>6.2-7 AmalgamatedDirectSumCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AmalgamatedDirectSumCode</code>( <var>c1, c2[, check]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">AmalgamatedDirectSumCode</code> returns the amalgamated direct sum of the codes <var>c1</var> and <var>c2</var>. The amalgamated direct sum code consists of all codewords of the form (u , | ,0 , | , v) if (u , | , 0) in c_1 and (0 , | , v) in c_2 and all codewords of the form (u , | , 1 , | , v) if (u , | , 1) in c_1 and (1 , | , v) in c_2. The result is a code with length n = n_1 + n_2 - 1 and size M &lt;= M_1 * M_2 / 2.</p>

<p>If both codes are linear, they will first be standardized, with information symbols in the last and first coordinates of the first and second code, respectively.</p>

<p>If <var>c1</var> is a normal code (see <code class="func">IsNormalCode</code> (<a href="chap7.html#s4ss5"><b>7.4-5</b></a>)) with the last coordinate acceptable (see <code class="func">IsCoordinateAcceptable</code> (<a href="chap7.html#s4ss3"><b>7.4-3</b></a>)), and <var>c2</var> is a normal code with the first coordinate acceptable, then the covering radius of the new code is r &lt;= r_1 + r_2. However, checking whether a code is normal or not is a lot of work, and almost all codes seem to be normal. Therefore, an option <var>check</var> can be supplied. If <var>check</var> is true, then the codes will be checked for normality. If <var>check</var> is false or omitted, then the codes will not be checked. In this case it is assumed that they are normal. Acceptability of the last and first coordinate of the first and second code, respectively, is in the last case also assumed to be done by the user.</p>


<table class="example">
<tr><td><pre>

gap&gt; c := HammingCode( 3, GF(2) );
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
gap&gt; d := ReedMullerCode( 1, 4 );
a linear [16,5,8]6 Reed-Muller (1,4) code over GF(2)
gap&gt; e := DirectSumCode( c, d );
a linear [23,9,3]7 direct sum code
gap&gt; f := AmalgamatedDirectSumCode( c, d );;
gap&gt; MinimumDistance( f );;
gap&gt; CoveringRadius( f );; 
gap&gt; f;
a linear [22,8,3]7 amalgamated direct sum code

</pre></td></tr></table>

<p><a id="s2ss8" name="s2ss8"></a></p>

<h5>6.2-8 BlockwiseDirectSumCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BlockwiseDirectSumCode</code>( <var>C1, L1, C2, L2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">BlockwiseDirectSumCode</code> returns a subcode of the direct sum of <var>C1</var> and <var>C2</var>. The fields of <var>C1</var> and <var>C2</var> must be same. The lists <var>L1</var> and <var>L2</var> are two equally long with elements from the ambient vector spaces of <var>C1</var> and <var>C2</var>, respectively, <em>or</em> <var>L1</var> and <var>L2</var> are two equally long lists containing codes. The union of the codes in <var>L1</var> and <var>L2</var> must be <var>C1</var> and <var>C2</var>, respectively.</p>

<p>In the first case, the blockwise direct sum code is defined as</p>

<p class="pcenter">\[
bds = \bigcup_{1 \leq i \leq \ell} ( C_1 + (L_1)_i ) \oplus ( C_2 + (L_2)_i ),
 \]</p>

<p>where ell is the length of <var>L1</var> and <var>L2</var>, and oplus is the direct sum.</p>

<p>In the second case, it is defined as</p>

<p class="pcenter">\[
bds = \bigcup_{1 \leq i \leq \ell} ( (L_1)_i \oplus (L_2)_i ).
 \]</p>

<p>The length of the new code is n = n_1 + n_2.</p>


<table class="example">
<tr><td><pre>

gap&gt; C1 := HammingCode( 3, GF(2) );;
gap&gt; C2 := EvenWeightSubcode( WholeSpaceCode( 6, GF(2) ) );;
gap&gt; BlockwiseDirectSumCode( C1, [[ 0,0,0,0,0,0,0 ],[ 1,0,1,0,1,0,0 ]],
&gt; C2, [[ 0,0,0,0,0,0 ],[ 1,0,1,0,1,0 ]] );
a (13,1024,1..13)1..2 blockwise direct sum code

</pre></td></tr></table>


<div class="pcenter">
<table class="chlink"><tr><td><a href="chap0.html">Top of Book</a></td><td><a href="chap5.html">Previous Chapter</a></td><td><a href="chap7.html">Next Chapter</a></td></tr></table>
<br />


<div class="pcenter"><table class="chlink"><tr><td class="chlink1">Goto Chapter: </td><td><a href="chap0.html">Top</a></td><td><a href="chap1.html">1</a></td><td><a href="chap2.html">2</a></td><td><a href="chap3.html">3</a></td><td><a href="chap4.html">4</a></td><td><a href="chap5.html">5</a></td><td><a href="chap6.html">6</a></td><td><a href="chap7.html">7</a></td><td><a href="chapBib.html">Bib</a></td><td><a href="chapInd.html">Ind</a></td></tr></table><br /></div>

</div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
