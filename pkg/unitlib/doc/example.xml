<!-- $Id: example.xml,v 1.2 2007/03/14 20:41:57 alexk Exp $ -->
<Chapter Label="Example">
<Heading>An example of &UnitLib; usage</Heading>

We will finish with several examples of &UnitLib; usage 
to give an idea how to work with the package.
<P/>

In the first example we retrieve from the library the
normalized unit group of the group algebra of the dihedral
group of order 128 over the field of two elements, 
compute its center and express one of its 
generators in terms of group algebra elements:

<Example>
<![CDATA[
gap> IdGroup(DihedralGroup(128));
[ 128, 161 ]
gap> V := PcNormalizedUnitGroupSmallGroup( 128, 161 );
<pc group of size 170141183460469231731687303715884105728 
  with 127 generators>
gap> C := Center( V );           
<pc group with 34 generators>  
gap> gens := MinimalGeneratingSet( C );;
gap> KG := UnderlyingGroupRing( V );
<algebra-with-one over GF(2), with 7 generators>
gap> f := NaturalBijectionToNormalizedUnitGroup( KG );;
gap> gens[8]^f;
(Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^0)*f7+(Z(2)^0)*f3*f4+(Z(2)^
0)*f3*f5+(Z(2)^0)*f3*f6+(Z(2)^0)*f3*f7+(Z(2)^0)*f4*f5+(Z(2)^
0)*f4*f6+(Z(2)^0)*f4*f7+(Z(2)^0)*f3*f4*f5+(Z(2)^0)*f3*f4*f6+(
Z(2)^0)*f3*f4*f7+(Z(2)^0)*f3*f5*f6+(Z(2)^0)*f3*f5*f7+(Z(2)^
0)*f3*f6*f7+(Z(2)^0)*f4*f5*f6+(Z(2)^0)*f4*f5*f7+(Z(2)^
0)*f4*f6*f7+(Z(2)^0)*f3*f4*f5*f6+(Z(2)^0)*f3*f4*f5*f7+(Z(2)^
0)*f3*f4*f6*f7+(Z(2)^0)*f3*f5*f6*f7+(Z(2)^0)*f4*f5*f6*f7+(Z(2)^
0)*f3*f4*f5*f6*f7
]]>
</Example>

In the second example we will check the conjecture about
the coincidence of the lower and upper Lie nilpotency indices
of the modular group algebras for all non-abelian groups of
order 64.
<P/>
 
It is known that these indices coincide for <M>p</M>-groups
with <M> p>3 </M> <Cite Key="Bhandari-Passi"/>, but in the 
general case the problem remains open.
<P/>

The indices <M>t_L(G)</M> and <M>t^L(G)</M> can be computed 
using the &LAGUNA; package. While the upper Lie nilpotency 
index can be expressed only in terms of the underlying group 
<M>G</M>, the lower Lie nilpotency index is determined by the 
formula <M>t_L(G) =</M> cl <M>V(KG) + 1</M> <Cite Key="Du" />,
and can be computed immediately whenever <M>V(KG)</M> is known.
<P/>

In the program below we enumerate all groups of size 64 and check
the conjecture (we do not exclude from consideration some particular
cases when the conjecture is known to be true for <M>p=2</M>, 
because this is beyond the task of this manual).

<Example>
<![CDATA[
gap> for n in [ 1 .. NrSmallGroups( 64 ) ] do
> if not IsAbelian( SmallGroup( 64, n ) ) then
>   Print( n, "\r" );
>   V := PcNormalizedUnitGroupSmallGroup( 64, n );
>   KG := UnderlyingGroupRing( V );
>   if LieLowerNilpotencyIndex( KG ) <>
>      LieUpperNilpotencyIndex( KG ) then
>     Print( n," - counterexample !!! \n" );
>     break;
>   fi;
> fi;
> od;
gap>
]]>
</Example>

Thus, the test was finished without finding a counterexample.
<P/>

In the next example we will answer the question about 
possible nilpotency classes of normalized unit groups 
of modular group algebras of nonabelian groups of order 128:

<Example>
<![CDATA[
gap> cl := [];
gap> for n in [ 1 .. NrSmallGroups( 128 ) ] do
> if not IsAbelian( SmallGroup( 128, n ) ) then
>   Print( n, "\r" );
>   V := PcNormalizedUnitGroupSmallGroup( 128, n );  
>   AddSet( cl, NilpotencyClassOfGroup( V ) );
> fi;
> od;
gap> cl;
[ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16, 32 ]
]]>
</Example>

With &UnitLib; you can perform the computation from the
last example in several hours on a modern computer. 
Without &UnitLib; you will spend the same time to compute 
only several normalized unit groups <M>V(KG)</M> for groups
of order 128 with the help of the &LAGUNA; package.
Note that without &LAGUNA; such computation would not
be feasible at all.

</Chapter>