<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %W  language.msk           GAP documentation                Martin Schönert -->
<!-- %% -->
<!-- %H  @(#)<M>Id: language.msk,v 1.41 2006/09/27 21:40:31 gap Exp </M> -->
<!-- %% -->
<!-- %Y  Copyright 1990-1992, Lehrstuhl D für Mathematik, RWTH Aachen, Germany -->
<!-- %% -->
<!-- %%  This file describes the &GAP; programming language. -->
<!-- %% -->
<Chapter Label="The Programming Language">
<Heading>The Programming Language</Heading>

This chapter describes the &GAP; programming language.  It should allow
you in principle to predict the result of each and every input. In order
to know what we are talking about, we first have to look more closely at
the process of interpretation and the various representations of data
involved.

<!-- %%  The &GAP; language and its interpreter in the kernel were designed by  -->
<!-- %%  Martin Sch{\"o}nert. -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Language Overview">
<Heading>Language Overview</Heading>

First we have the input to &GAP;, given as a string of characters. How
those characters enter &GAP; is operating system dependent, e.g., they
might be entered at a terminal, pasted with a mouse into a window, or
read from a file. The mechanism does not matter. This representation of
expressions by characters is called the <E>external representation</E> of the
expression. Every expression has at least one external representation
that can be entered to get exactly this expression.
<P/>
The input, i.e., the external representation, is transformed in a process
called <E>reading</E> to an internal representation.  At this point the input
is analyzed and inputs  that are not legal external representations,
according to the rules given below, are rejected as errors. Those rules
are usually called the <E>syntax</E> of a programming language.
<P/>
The internal representation created by reading is called either an
<E>expression</E> or a <E>statement</E>.
Later we will distinguish between those two terms.
However for now we will use them interchangeably.
The exact form of the internal representation does not matter.
It could be a string of characters equal to the external representation,
in which case the reading would only need to check for errors.
It could be a series of machine instructions for the processor on which
&GAP; is running, in which case the reading would more appropriately
be called compilation.
It is in fact a tree-like structure.
<P/>
After the input has been read it is again transformed in a process called
<E>evaluation</E> or <E>execution</E>.
Later we will distinguish between those two terms too,
but for the moment we will use them interchangeably. The name
hints at the nature of this process, it replaces an expression with the
value of the expression. This works recursively, i.e., to evaluate an
expression first the subexpressions are evaluated and then the value of
the expression is computed from those values according to rules given below.
Those rules are usually called the <E>semantics</E> of a programming language.
<P/>
The result of the evaluation is, not surprisingly, called a <E>value</E>.
<!-- % The -->
<!-- % set of values  is of course a  much smaller set than the  set of -->
<!-- % expressions; for every value there may be several expressions that will -->
<!-- % evaluate to  this value. -->
Again the form in which such a  value is
represented internally does not  matter. It is  in fact a tree-like
structure again.
<P/>
The last process is called <E>printing</E>. It takes the value produced by
the evaluation and creates an external representation, i.e., a string of
characters again. What you do with this external representation is up to
you. You can look at it, paste it with the mouse into another window, or
write it to a file.
<P/>
Lets look at an example to make this more clear. Suppose you type in the
following string of 8 characters
<P/>
<Listing><![CDATA[
1 + 2 * 3;
]]></Listing>
<P/>
&GAP; takes  this external representation  and creates  a tree-like
internal representation, which we can picture as follows
<P/>
<Listing><![CDATA[
  +
 / \
1   *
   / \
  2   3
]]></Listing>
<P/>
This expression is then evaluated. To do this &GAP; first evaluates the
right subexpression <C>2*3</C>.  Again, to do this &GAP; first evaluates its
subexpressions 2 and 3. However they are so simple that they are their
own value, we say that they are self-evaluating. After this has been
done, the rule for <C>*</C> tells us that the value is the product of the
values of the two subexpressions, which in this case is clearly 6.
Combining this with the value of the left operand of the <C>+</C>, which is
self-evaluating, too, gives us the value of the whole expression 7. This
is then printed, i.e., converted into the external representation
consisting of the single character <C>7</C>.
<P/>
In this fashion we can predict the result of every input when we know the
syntactic rules that govern the process of reading and the semantic rules
that tell us for every expression how its value is computed in terms of
the values of the subexpressions.
The syntactic rules are given in sections <Ref Sect="Lexical Structure"/>,
<Ref Sect="Symbols"/>, <Ref Sect="Whitespaces"/>, <Ref Sect="Keywords"/>,
<!-- <Ref Sect="Identifiers"/>, and <Ref Sect="The Syntax in BNF"/>, -->
and <Ref Sect="Identifiers"/>,
the semantic rules are given in sections <Ref Sect="Expressions"/>,
<Ref Sect="Variables"/>, <Ref Sect="Function Calls"/>,
<Ref Sect="Comparisons"/>, <Ref Sect="Arithmetic Operators"/>,
<Ref Sect="Statements"/>, <Ref Sect="Assignments"/>,
<Ref Sect="Procedure Calls"/>, <Ref Sect="If"/>, <Ref Sect="While"/>,
<Ref Sect="Repeat"/>, <Ref Sect="For"/>, <Ref Sect="Function"/>,
and the chapters describing the individual data types.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Lexical Structure">
<Heading>Lexical Structure</Heading>

Most input of &GAP; consists of sequences of the following characters.
<P/>
Digits, uppercase and lowercase letters, <B>Space</B>, <B>Tab</B>,
<B>Newline</B>, <B>Return</B> and the special characters
<P/>
<Listing><![CDATA[
"    `    (    )    *    +    ,    -    #
.    /    :    ;    <    =    >    ~    
[    \    ]    ^    _    {    }    ! 
]]></Listing>
<P/>
It is possible to use other characters in identifiers by escaping
them with backslashes, but we do not recommend to use this feature.
Inside strings
(see section&nbsp;<Ref Sect="Symbols"/> and
chapter&nbsp;<Ref Chap="Strings and Characters"/>)
and comments (see&nbsp;<Ref Sect="Whitespaces"/>) the full character set
supported by the computer is allowed.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Symbols">
<Heading>Symbols</Heading>

The process of reading, i.e., of assembling the input into expressions,
has a subprocess, called <E>scanning</E>, that assembles the characters into
symbols.  A <E>symbol</E> is a sequence of characters that form a lexical
unit. The set of symbols consists of keywords, identifiers, strings,
integers, and operator and delimiter symbols.
<P/>
A <E>keyword</E> is a reserved word (see <Ref Sect="Keywords"/>).
An <E>identifier</E> is a sequence of letters, digits and underscores
(or other characters escaped by backslashes) that contains at least one
non-digit and is not a keyword (see <Ref Sect="Identifiers"/>).
An integer is a sequence of digits (see <Ref Chap="Integers"/>),
possibly prepended by <C>-</C> and <C>+</C> sign characters.
A <E>string</E> is a sequence of arbitrary characters enclosed in
double quotes (see <Ref Chap="Strings and Characters"/>).
<P/>
Operator and delimiter symbols are
<P/>
<Listing><![CDATA[
+    -    *    /    ^    ~   !.
=    <>   <    <=   >    >=  ![
:=   .    ..   ->   ,    ;   !{
[    ]    {    }    (    )    :
]]></Listing>
<P/>
Note also that during the process of scanning all whitespace is removed
(see <Ref Sect="Whitespaces"/>).

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Whitespaces">
<Heading>Whitespaces</Heading>

<Index>space</Index>
<Index>blank</Index><Index>tabulator</Index><Index>newline</Index>
<Index>comments</Index>
The characters <B>Space</B>, <B>Tab</B>, <B>Newline</B>, and <B>Return</B>
are called <E>whitespace characters</E>.
Whitespace is used as necessary to separate lexical symbols,
such as integers, identifiers, or keywords. For example
<C>Thorondor</C> is a single identifier,
while <C>Th or ondor</C> is the keyword <K>or</K> between the two identifiers
<C>Th</C> and <C>ondor</C>.
Whitespace may occur between any two symbols, but not within a symbol.
Two or more adjacent whitespace characters are equivalent to a single
whitespace.
Apart from the role as separator of symbols,
whitespace characters are otherwise insignificant.
Whitespace characters may also occur inside a string,
where they are significant.
Whitespace characters should also be used freely for improved readability.
<P/>
A <E>comment</E> starts with the  character <C>#</C>,
which is sometimes called sharp or hatch,
and continues to the end of the line on which the comment character appears.
The whole comment, including <C>#</C> and the <B>Newline</B> character
is treated as a single whitespace.
Inside a string, the comment character <C>#</C> loses its role and is just
an ordinary character.
<P/>
For example, the following statement
<P/>
<Listing><![CDATA[
if i<0 then a:=-i;else a:=i;fi;
]]></Listing>
<P/>
is equivalent to
<P/>
<Listing><![CDATA[
if i < 0 then   # if i is negative
  a := -i;      #   take its additive inverse
else            # otherwise
  a := i;       #   take itself
fi;
]]></Listing>
<P/>
(which by the way shows that it is possible to write superfluous
comments). However the first statement is <E>not</E> equivalent to
<P/>
<Listing><![CDATA[
ifi<0thena:=-i;elsea:=i;fi;
]]></Listing>
<P/>
since the keyword <K>if</K> must be separated from the identifier <C>i</C>
by a whitespace, and similarly <K>then</K> and <C>a</C>,
and <K>else</K> and <C>a</C> must be separated.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Keywords">
<Heading>Keywords</Heading>

<Index Key="GAPInfo.Keywords"><C>GAPInfo.Keywords</C></Index>

<E>Keywords</E> are reserved words that are used to denote special operations
or are part of statements. They must not be used as identifiers. The list of
keywords is contained in the <C>GAPInfo.Keywords</C> component of the
<C>GAPInfo</C> record (see <Ref Sect="GAPInfo"/>). We will show how to print
it in a nice table, demonstrating at the same time some list manipulation
techniques:
<P/>
<Example><![CDATA[
gap> keys:=SortedList( GAPInfo.Keywords );; l:=Length( keys );;
gap> arr:= List( [ 0 .. Int( l/4 )-1 ], i-> keys{ 4*i + [ 1 .. 4 ] } );;
gap> if l mod 4 <> 0 then Add( arr, keys{[ 4*Int(l/4) + 1 .. l ]} ); fi;
gap> Length( keys ); PrintArray( arr );
35
[ [         Assert,           Info,        IsBound,           QUIT ],
  [  TryNextMethod,         Unbind,            and,         atomic ],
  [          break,       continue,             do,           elif ],
  [           else,            end,          false,             fi ],
  [            for,       function,             if,             in ],
  [          local,            mod,            not,             od ],
  [             or,           quit,       readonly,      readwrite ],
  [            rec,         repeat,         return,           then ],
  [           true,          until,          while ] ]
]]></Example>
<P/>
Note that (almost) all keywords are written in lowercase and that they
are case sensitive.
For example <K>else</K> is a keyword; <C>Else</C>, <C>eLsE</C>, <C>ELSE</C>
and so forth are ordinary identifiers.
Keywords must not contain whitespace, for example <C>el if</C> is not the
same as <K>elif</K>.
<P/>
<E>Note</E>: 
Several tokens from the list of keywords above may appear to be normal 
identifiers representing functions or literals of various kinds but are 
actually implemented as keywords for technical reasons. The only 
consequence of this is that those identifiers cannot be re-assigned, and 
do not actually have function objects bound to them, which could be 
assigned to other variables or passed to functions. These keywords are
<K>true</K>, <K>false</K>, <Ref Func="Assert"/>, 
<Ref Func="IsBound" Label="for a global variable"/>,
<Ref Func="Unbind" Label="unbind a variable"/>, 
<Ref Func="Info"/> and <Ref Func="TryNextMethod"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Identifiers">
<Heading>Identifiers</Heading>

An <E>identifier</E> is used to refer to a variable
(see <Ref Sect="Variables"/>).
An identifier usually consists of letters, digits, underscores <C>_</C>,
and <Q>at</Q>-characters <C>@</C>,
and must contain at least one non-digit.
An identifier is terminated by the first character not in this class.
Note that the <Q>at</Q>-character <C>@</C> is used to implement
namespaces, see Section <Ref Sect="Namespaces"/> for details.
<P/>
Examples of valid identifiers are
<P/>
<Listing><![CDATA[
a           foo         aLongIdentifier
hello       Hello       HELLO
x100        100x       _100
some_people_prefer_underscores_to_separate_words
WePreferMixedCaseToSeparateWords
abc@def
]]></Listing>
<P/>
Note that case is significant, so the three identifiers in the second
line are distinguished.
<P/>
The backslash <C>\</C> can be used to include other characters in identifiers;
a backslash followed by a character is equivalent  to the character,
except that this escape sequence is considered to be an ordinary letter.
For example
<Listing><![CDATA[
G\(2\,5\)
]]></Listing>
is an identifier, not a call to a function <C>G</C>.
<P/>
An identifier that starts with a backslash is never a keyword, so for
example <C>\*</C> and <C>\mod</C> are identifiers.
<P/>
The length of identifiers is not limited,
however only the first <M>1023</M> characters are significant.
The escape sequence <C>\</C><B>newline</B> is ignored,
making it possible to split long identifiers over multiple lines.

<#Include Label="IsValidIdentifier">

Note that the <Q>at</Q>-character is used to implement namespaces
for global variables in packages. See <Ref Sect="Namespaces"/> for
details.
<Index>namespace</Index>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Expressions">
<Heading>Expressions</Heading>

<Index>evaluation</Index>
An <E>expression</E> is a construct that evaluates to a value.
Syntactic constructs that are executed to produce a side effect and return
no value are called <E>statements</E> (see <Ref Sect="Statements"/>).
Expressions appear as right hand sides of assignments
(see <Ref Sect="Assignments"/>), as actual arguments in function calls
(see <Ref Sect="Function Calls"/>), and in statements.
<P/>
Note that an expression is not the same as a value.
For example <C>1 + 11</C> is an expression, whose value is the integer 12.
The external representation of this integer is the character sequence
<C>12</C>, i.e., this sequence is output if the integer is printed.
This sequence is another expression whose value is the integer <M>12</M>.
The process of finding the value of an expression is done by the interpreter
and is called the <E>evaluation</E> of the expression.
<P/>
Variables, function calls, and integer, permutation, string, function, list,
and record literals
(see <Ref Sect="Variables"/>, <Ref Sect="Function Calls"/>,
<Ref Chap="Integers"/>, <Ref Chap="Permutations"/>,
<Ref Chap="Strings and Characters"/>, <Ref Sect="Function"/>,
<Ref Chap="Lists"/>, <Ref Chap="Records"/>),
are the simplest cases of expressions.
<P/>
Expressions, for example the simple expressions mentioned above, can be
combined with the operators to form more complex expressions. Of course
those expressions can then be combined further with the operators to form
even more complex expressions. The <E>operators</E> fall into three classes.
<Index>operators</Index>
The <E>comparisons</E> are <C>=</C>, <C>&lt;></C>, <C>&lt;</C>, <C>&lt;=</C>,
<C>></C>, <C>>=</C>, and <K>in</K> (see <Ref Sect="Comparisons"/> and
<Ref Sect="Membership Test for Collections"/>).
The <E>arithmetic operators</E> are <C>+</C>, <C>-</C>, <C>*</C>, <C>/</C>,
<K>mod</K>, and <C>^</C> (see&nbsp;<Ref Sect="Arithmetic Operators"/>).
The <E>logical operators</E> are <K>not</K>, <K>and</K>, and <K>or</K>
(see&nbsp;<Ref Sect="Operations for Booleans"/>).
<P/>
The following example shows a very simple expression with value 4 and a
more complex expression.
<P/>
<Example><![CDATA[
gap> 2 * 2;
4
gap> 2 * 2 + 9 = Fibonacci(7) and Fibonacci(13) in Primes;
true
]]></Example>
<P/>
For the precedence of operators, see&nbsp;<Ref Sect="Comparisons"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Variables">
<Heading>Variables</Heading>

<Index>scope</Index><Index>bound</Index>
A <E>variable</E> is a location in a &GAP; program that points to a value.
We say the variable is <E>bound</E> to this value.
If a variable is evaluated it evaluates to this value.
<P/>
Initially an ordinary variable is not bound to any value.
The variable can be bound to a value by <E>assigning</E> this value to the
variable (see <Ref Sect="Assignments"/>).
Because of this we sometimes say that a variable that is not bound to any
value has no assigned value.
Assignment is in fact the only way by which a variable, which is not an
argument of a function, can be bound to a value.
After a variable has been bound to a  value an assignment can also be used
to bind the variable to another value.
<P/>
A special class of variables is the class of <E>arguments</E> of functions.
They behave similarly to other variables,
except they are bound to the value of the
actual arguments upon a function call (see <Ref Sect="Function Calls"/>).
<P/>
Each variable has a name that is also called its <E>identifier</E>. This is
because in a given scope an identifier identifies a unique variable (see
<Ref Sect="Identifiers"/>).
A <E>scope</E> is a lexical part of a program text. There is
the <E>global scope</E> that encloses the entire program text, and there are
local scopes that range from the <K>function</K> keyword, denoting the
beginning of a function definition, to the corresponding <K>end</K> keyword.
A <E>local scope</E> introduces new variables, whose identifiers are given in
the formal argument list and the <K>local</K> declaration of the function (see
<Ref Sect="Function"/>). Usage of an identifier in a program text refers to the
variable in the innermost scope that has this identifier as its name.
Because this mapping from identifiers to variables is done when the
program is read, not when it is executed, &GAP; is said to have <E>lexical
scoping</E>.  The following example shows how one identifier refers to
different variables at different points in the program text.
<P/>
<Listing><![CDATA[
g := 0;      # global variable g
x := function ( a, b, c )
  local  y;
  g := c;     # c refers to argument c of function x
  y := function ( y )
    local d, e, f;
    d := y;   # y refers to argument y of function y
    e := b;   # b refers to argument b of function x
    f := g;   # g refers to global variable g
    return d + e + f;
  end;
  return y( a ); # y refers to local y of function x
end;
]]></Listing>
<P/>
It is important to note that the concept of a variable in &GAP; is quite
different from the concept of a variable in most compiled programming languages.
<P/>
In those languages a variable denotes a block of memory. The
value of the variable is stored in this block. So in those languages two
variables can have the same value, but they can never have identical
values, because they denote different blocks of memory.  Note that
some languages have the concept of a reference argument. It seems as if such an
argument and the variable used in the actual function call have the same
value, since changing the argument's value also changes the value of the
variable used in the actual function call.  But this is not so; the
reference argument is actually a pointer to the variable used in the
actual function call, and it is the compiler that inserts enough magic to
make the pointer invisible.  In order for this to work the compiler
needs enough information to compute the amount of memory needed for each
variable in a program, which is readily available in the declarations.
<P/>
In &GAP; on the other hand each variable just points to a value,
and different variables can share the same value.


<ManSection>
<Func Name="IsBound" Arg='ident' Label="for a global variable"/>

<Description>
<Ref Func="IsBound" Label="for a global variable"/> returns <K>true</K>
if the variable <A>ident</A> points to a value,
and <K>false</K> otherwise.
<P/>
For records and lists <Ref Func="IsBound" Label="for a global variable"/>
can be used to check whether components or entries, respectively,
are bound
(see Chapters&nbsp;<Ref Chap="Records"/> and <Ref Chap="Lists"/>).
</Description>
</ManSection>


<ManSection>
<Func Name="Unbind" Arg='ident' Label="unbind a variable"/>

<Description>
deletes the identifier <A>ident</A>.
If there is no other variable pointing to the same value as <A>ident</A> was,
this value will be removed by the next garbage collection.
Therefore <Ref Func="Unbind" Label="unbind a variable"/> can be used to get
rid of unwanted large objects.
<P/>
For records and lists <Ref Func="Unbind" Label="unbind a variable"/>
can be used to delete components or entries, respectively
(see Chapters&nbsp;<Ref Chap="Records"/> and <Ref Chap="Lists"/>).
</Description>
</ManSection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="More About Global Variables">
<Heading>More About Global Variables</Heading>

The vast majority of variables in &GAP; are defined at the outer
level (the global scope). They are used to access functions and
other objects created either in the &GAP; library or packages or in the user's
code. 
<P/>
Note that for packages there is a mechanism to implement package local
namespaces on top of this global namespace. See Section <Ref
Sect="Namespaces"/> for details.
<Index>namespace</Index>
<P/>
Certain special facilities are provided for manipulating global
variables which are not available for other types of variable (such as 
local variables or function arguments).
<P/>
First, such variables may be marked <E>read-only</E> using
<Ref Func="MakeReadOnlyGlobal"/>. In which case
attempts to change them will fail. Most of the global variables
defined in the &GAP; library are so marked. <E>read-only</E> variables
can be made read-write again by calling <Ref Func="MakeReadWriteGlobal"/>.
GAP also features <E>constant</E> variables, which are created by calling
<Ref Func="MakeConstantGlobal"/>. Constant variables can never be changed.
In some cases, GAP can optimise code which uses <E>constant</E> variables,
as their value never changes. In this version GAP these optimisations can be
observed by printing the function back out, but this behaviour may change
in future.
<Example><![CDATA[
gap> globali := 1 + 2;;
gap> globalb := true;;
gap> MakeConstantGlobal("globali");
gap> MakeConstantGlobal("globalb");
gap> f := function()
>     if globalb then
>         return globali + 1;
>     else
>         return globali + 2;
>     fi;
> end;;
gap> Print(f);
function (  )
    return 3 + 1;
end
]]></Example>


<P/>
Second, a group of functions are supplied for accessing and altering the
values assigned to global variables. Use of these functions differs
from the use of assignment,
<Ref Func="Unbind" Label="unbind a variable"/> and
<Ref Func="IsBound" Label="for a global variable"/>
statements, in two ways.
First, these functions always affect global variables, even if 
local variables of the same names exist.
Second, the variable names are passed as strings,
rather than being written directly into the statements. 
<P/>
Note that the functions <Ref Func="NamesGVars"/>,
<Ref Func="NamesSystemGVars"/>, <Ref Func="NamesUserGVars"/>,
and <Ref Func="TemporaryGlobalVarName"/>
deal with the <E>global namespace</E>.


<ManSection>
<Func Name="IsReadOnlyGlobal" Arg='name'/>

<Description>
returns <K>true</K> if the global variable named by the string <A>name</A> is 
read-only and <K>false</K> otherwise (the default). 
</Description>
</ManSection>


<ManSection>
<Func Name="MakeReadOnlyGlobal" Arg='name'/>

<Description>
marks the global variable named by the string <A>name</A> as read-only. 
<P/>
A warning is given if <A>name</A> has no value bound to it or if it is
already read-only.
</Description>
</ManSection>


<ManSection>
<Func Name="MakeReadWriteGlobal" Arg='name'/>

<Description>
marks the global variable named by the string <A>name</A> as read-write.
<P/>
A warning is given if <A>name</A> is already read-write.
<P/>
<Log><![CDATA[
gap> xx := 17;
17
gap> IsReadOnlyGlobal("xx");
false
gap> xx := 15;
15
gap> MakeReadOnlyGlobal("xx");
gap> xx := 16;
Variable: 'xx' is read only
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' after making it writable to continue
brk> quit;
gap> IsReadOnlyGlobal("xx");
true
gap> MakeReadWriteGlobal("xx");
gap> xx := 16;
16
gap> IsReadOnlyGlobal("xx");
false
]]></Log>
</Description>
</ManSection>

<#Include Label="MakeConstantGlobal">

<ManSection>
<Func Name="ValueGlobal" Arg='name'/>

<Description>
returns the value currently bound to the global variable named by the 
string <A>name</A>. An error is raised if no value is currently bound.
</Description>
</ManSection>


<ManSection>
<Func Name="IsBoundGlobal" Arg='name'/>

<Description>
returns <K>true</K> if a value currently bound
to the global variable named by the string <A>name</A> and <K>false</K> otherwise.
</Description>
</ManSection>


<ManSection>
<Func Name="UnbindGlobal" Arg='name'/>

<Description>
removes any value currently bound
to the global variable named by the string <A>name</A>. Nothing is returned.
<P/>
A warning is given if <A>name</A> was not bound. The global variable named
by <A>name</A> must be writable, otherwise an error is raised.
</Description>
</ManSection>


<#Include Label="BindGlobal">


<ManSection>
<Func Name="NamesGVars" Arg=''/>

<Description>
This function returns an immutable
(see&nbsp;<Ref Sect="Mutability and Copyability"/>)
sorted (see&nbsp;<Ref Sect="Sorted Lists and Sets"/>) list of all the global
variable names known to the system.  This includes names of variables
which were bound but have now been unbound and some other names which
have never been bound but have become known to the system by various
routes.
</Description>
</ManSection>


<ManSection>
<Func Name="NamesSystemGVars" Arg=''/>

<Description>
This function returns an immutable sorted list of all the global
variable names created by the &GAP; library when &GAP; was started.
</Description>
</ManSection>


<ManSection>
<Func Name="NamesUserGVars" Arg=''/>

<Description>
This function returns an immutable sorted list of the global variable
names created since the library was read, to which a value is
currently bound.
</Description>
</ManSection>


<ManSection>
<Func Name="TemporaryGlobalVarName" Arg='[prefix]'/>

<Description>
returns a string  that can be used
as the  name  of a global  variable  that is not bound   at the time when
<Ref Func="TemporaryGlobalVarName"/> is called.
The optional argument <A>prefix</A> can
specify a string with which the name of the global variable starts.
</Description>
</ManSection>

<!-- here name spaces -->

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Namespaces">
<Heading>Namespaces for &GAP; packages</Heading>

As mentioned in Section <Ref Sect="More About Global Variables"/>
above all global variables share a common namespace. This can
relatively easily lead to name clashes, in particular when many
&GAP; packages are loaded at the same time. To give package code
a way to have a package local namespace without breaking backward
compatibility of the &GAP; language, the following simple rule has
been devised:
<P/>
If in package code a global variable that ends with an
<Q>at</Q>-character <C>@</C> is accessed in any way, the name of the
package is appended before accessing it. Here, <Q>package code</Q>
refers to everything which is read with <Ref Func="ReadPackage"/>.
As the name of the package the entry <C>PackageName</C> in its 
<F>PackageInfo.g</F> file is taken. As for all identifiers,
this name is case sensitive.
<P/>
For example, if the following is done in the code of a package with name
<C>xYz</C>:

<Log><![CDATA[
gap> a@ := 12;
]]>
</Log>

Then actually the global variable <C>a@xYz</C> is assigned. Further
accesses to <C>a@</C> within the package code will all be redirected
to <C>a@xYz</C>. This includes all the functions described in Section
<Ref Sect="More About Global Variables"/> and indeed all the functions
described Section <Ref Sect="Global Variables in the Library"/> like
for example <Ref Func="DeclareCategory"/>. Note that from code in the
same package it is still possible to access the same global variable
via <C>a@xYz</C> explicitly.
<P/>
All other code outside the package as well as interactive user input
that wants to refer to that variable <C>a@xYz</C> must do so explicitly
by using <C>a@xYz</C>.
<P/>
Since in earlier releases of &GAP; the <Q>at</Q>-character <C>@</C>
was not a legal character (without using backslashes), this small
extension of the language does not break any old code.

</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Function Calls">
<Heading>Function Calls</Heading>

<Subsection Label="Function Call With Arguments">
<Heading>Function Call With Arguments</Heading>

<C><A>function-var</A>( [<A>arg-expr</A>[, <A>arg-expr</A>, ...]] )</C>
<P/>
The function call has the effect of calling the function <A>function-var</A>.
The precise semantics are as follows.
<P/>
First &GAP; evaluates the <A>function-var</A>.
Usually <A>function-var</A> is a variable,
and &GAP; does nothing more than taking the value of this variable.
It is allowed though that <A>function-var</A> is a more complex expression,
such as a reference to an element of a list
(see Chapter&nbsp;<Ref Chap="Lists"/>)
<C><A>list-var</A>[<A>int-expr</A>]</C>,
or to a component of a record (see Chapter&nbsp;<Ref Chap="Records"/>)
<C><A>record-var</A>.<A>ident</A></C>.
In any case &GAP; tests whether the value is a function.
If it is not, &GAP; signals an error.
<P/>
<Index Subkey="with a variable number of arguments, calling">functions</Index>
<Index Key="arg" Subkey="special function argument, calling with"><C>arg</C></Index>
Next &GAP; checks that the number of actual arguments <A>arg-expr</A>s agrees
with the number of <E>formal arguments</E> as given in the function definition.
If they do not agree &GAP; signals an error.
An exception is the case when the function has a variable length argument list,
which is denoted by adding <C>...</C> after the final argument.
In this case there must be at least as many
actual arguments as there are formal arguments <E>before the
final argument</E> and can be any larger number
(see&nbsp;<Ref Sect="Function"/> for examples).
<P/>
Now &GAP; allocates for each formal argument and for each <E>formal local</E>
(that is, the identifiers in the <K>local</K> declaration) a new variable.
Remember that a variable is a location in a &GAP; program
that points to a value. Thus for  each formal argument and for each
formal local such a location is allocated.
<P/>
Next the arguments <A>arg-expr</A>s are evaluated, and the values are assigned
to the newly created variables corresponding to the formal arguments. Of
course the first value is assigned to the new variable corresponding to
the first formal argument, the second  value  is assigned to the new
variable corresponding  to  the second  formal argument, and  so on.
However, &GAP; does not make any guarantee about the order in which the
arguments are evaluated. They might be evaluated left to right, right to
left, or in any other order, but each argument is evaluated once. An
exception again occurs if the last formal argument has
the name <C>arg</C>. In this case the values of all the actual
arguments not assigned to the other formal parameters are
stored in  a list and this  list is assigned to the  new variable
corresponding to the formal argument <C>arg</C>.
<P/>
The new variables corresponding to the formal locals are initially not
bound to any  value.  So trying  to evaluate those  variables before
something has been assigned to them will signal an error.
<P/>
Now the body of the function, which is a statement, is executed. If the
identifier of one of the formal arguments or formal locals appears in the
body of the function it refers to the new variable that was allocated for
this formal argument or formal local, and evaluates to the value of this
variable.
<P/>
If during the execution of the body of the function a <K>return</K> statement
with an expression (see <Ref Sect="Return (With or without Value)"/>)
is executed, execution of the body is
terminated and the value of the function call is the value of the
expression of the <K>return</K>. If during the execution of the body a
<K>return</K> statement without an expression is executed, execution of the
body is terminated and the function call does not produce a value, in
which case we call this call a procedure call (see <Ref Sect="Procedure Calls"/>).
If the execution of the body completes without execution of a <K>return</K>
statement, the function call again produces no value, and again we talk
about a procedure call.
<P/>
<Example><![CDATA[
gap> Fibonacci( 11 );
89
]]></Example>
<P/>
The above example shows a call to the function <Ref Func="Fibonacci"/> with
actual argument <C>11</C>, the following one shows a call to the operation
<Ref Func="RightCosets"/> where the second actual argument is another
function call.
<P/>
<Log><![CDATA[
gap> RightCosets( G, Intersection( U, V ) );;
]]></Log>

</Subsection>


<Subsection Label="Function Call With Options">
<Heading>Function Call With Options</Heading>

<C><A>function-var</A>( <A>arg-expr</A>[, <A>arg-expr</A>, ...][ : [ <A>option-expr</A> [,<A>option-expr</A>, ....]]])</C>
<P/>
As well as passing arguments to a function, providing the mathematical 
input to its calculation, it is sometimes useful to supply <Q>hints</Q>
suggesting to &GAP; how the desired result may be computed more
quickly, or specifying a level of tolerance for random errors in a
Monte Carlo algorithm.
<P/>
Such hints may be supplied to a function-call <E>and to all subsidiary
functions called from that call</E> using the options mechanism. Options
are separated from the actual arguments by a colon <C>:</C> and have much
the same syntax as the components of a record expression. The one
exception to this is that a component name may appear without a value,
in which case the value <K>true</K> is silently inserted.
<P/>
The following example shows a call to <Ref Func="Size"/> passing the options
<C>hard</C> (with the value <K>true</K>)
and <C>tcselection</C> (with the string <C>"external"</C> as value).
<P/>
<Log><![CDATA[
gap> Size( fpgrp : hard, tcselection := "external" );
]]></Log>
<P/>
Options supplied with function calls in this way are passed down using 
the global options stack described in chapter <Ref Chap="Options Stack"/>,
so that the call above is exactly equivalent to
<P/>
<Log><![CDATA[
gap> PushOptions( rec( hard := true, tcselection := "external") );
gap> Size( fpgrp );
gap> PopOptions( );
]]></Log>
<P/>
<E>Note</E> that any option may be passed with any function, whether or not 
it has any actual meaning for that function, or any function called by 
it. The system provides no safeguard against misspelled option names.

</Subsection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Comparisons">
<Heading>Comparisons</Heading>

<Index>equality test</Index>
<C><A>left-expr</A> = <A>right-expr</A></C>
<P/>
<Index>inequality test</Index>
<C><A>left-expr</A> &lt;> <A>right-expr</A></C>
<P/>
The operator <C>=</C> tests for equality of its two operands and evaluates to
<K>true</K> if they are equal and to <K>false</K> otherwise.
Likewise <C>&lt;></C> tests for inequality of its two operands.
For each type of objects the definition of equality is given in the
respective chapter.
Objects in different families (see&nbsp;<Ref Sect="Families"/>) are never equal,
i.e., <C>=</C> evaluates in this case to <K>false</K>, and <C>&lt;></C> evaluates to <K>true</K>.
<P/>
<Index>smaller test</Index>
<C><A>left-expr</A> &lt; <A>right-expr</A></C>
<P/>
<Index>larger test</Index>
<C><A>left-expr</A> >  <A>right-expr</A></C>
<P/>
<Index>smaller or equal</Index>
<C><A>left-expr</A> &lt;= <A>right-expr</A></C>
<P/>
<Index>larger or equal</Index>
<C><A>left-expr</A> >= <A>right-expr</A></C>
<P/>
<C>&lt;</C> denotes less than, <C>&lt;=</C> less than or equal, <C>></C> greater than, and
<C>>=</C> greater than or equal of its two operands.
For each kind of objects the definition of the ordering is given in the
respective chapter.
<P/>
Note that <C>&lt;</C> implements a <E>total ordering</E> of objects (which
can be used for example to sort a list of elements). Therefore in general
<C>&lt;</C> will not be compatible with any inclusion relation (which can be
tested using <Ref Func="IsSubset"/>). (For
example, it is possible to compare permutation groups with <C>&lt;</C> in a
total ordering of all permutation groups, but this ordering is not
compatible with the relation of being a subgroup.)
<P/>
<#Include Label="[1]{object.gi}">
<P/>
Comparison operators, including the operator <K>in</K>
(see&nbsp;<Ref Sect="Membership Test for Lists"/>),
are not associative,
Hence it is not allowed to write <C><A>a</A> = <A>b</A> &lt;> <A>c</A> = <A>d</A></C>,
you must use <C>(<A>a</A> = <A>b</A>) &lt;> (<A>c</A> = <A>d</A>)</C> instead.
The comparison operators have  higher precedence than the logical operators
<Index Subkey="precedence">operators</Index>
(see&nbsp;<Ref Sect="Operations for Booleans"/>), but lower precedence than the arithmetic
operators (see&nbsp;<Ref Sect="Arithmetic Operators"/>).
Thus, for instance, <C><A>a</A> * <A>b</A> = <A>c</A> and <A>d</A></C> is interpreted as
<C>((<A>a</A> * <A>b</A>) = <A>c</A>) and <A>d</A>)</C>.
<P/>
The following example shows a comparison where the left operand is an
expression.
<P/>
<Example><![CDATA[
gap> 2 * 2 + 9 = Fibonacci(7);
true
]]></Example>
<P/>
For the underlying operations of the operators introduced above,
see&nbsp;<Ref Sect="Comparison Operations for Elements"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Arithmetic Operators">
<Heading>Arithmetic Operators</Heading>

<Index>precedence</Index>
<Index>associativity</Index>
<Index Subkey="arithmetic">operators</Index>
<Index Key="+"><C>+</C></Index>
<Index Key="-"><C>-</C></Index>
<Index Key="*"><C>*</C></Index>
<Index Key="/"><C>/</C></Index>
<Index Key="^"><C>^</C></Index>
<Index Key="mod" Subkey="arithmetic operators"><K>mod</K></Index>
<Index>modulo</Index>
<Index Subkey="arithmetic operators">modulo</Index>
<Index>positive number</Index>
<C>+ <A>right-expr</A></C>
<P/>
<Index>negative number</Index>
<C>- <A>right-expr</A></C>
<P/>
<Index>addition</Index>
<C><A>left-expr</A> + <A>right-expr</A></C>
<P/>
<Index>subtraction</Index>
<C><A>left-expr</A> - <A>right-expr</A></C>
<P/>
<Index>multiplication</Index>
<C><A>left-expr</A> * <A>right-expr</A></C>
<P/>
<Index>division</Index>
<C><A>left-expr</A> / <A>right-expr</A></C>
<P/>
<Index Key="mod"><K>mod</K></Index>
<C><A>left-expr</A> mod <A>right-expr</A></C>
<P/>
<Index>power</Index>
<C><A>left-expr</A> ^ <A>right-expr</A></C>
<P/>
The arithmetic operators are <C>+</C>, <C>-</C>, <C>*</C>, <C>/</C>,
<K>mod</K>, and <C>^</C>.
The meanings (semantics) of those operators generally depend on the types
of the operands involved,
and they are defined in the various chapters describing the types.
However basically the meanings are as follows.
<P/>
<C><A>a</A> + <A>b</A></C> denotes the addition of additive elements <A>a</A> and <A>b</A>.
<P/>
<C><A>a</A> - <A>b</A></C> denotes the addition of <A>a</A> and the additive inverse of <A>b</A>.
<P/>
<C><A>a</A> * <A>b</A></C> denotes the multiplication of multiplicative elements <A>a</A> and
<A>b</A>.
<P/>
<C><A>a</A> / <A>b</A></C> denotes the multiplication of <A>a</A> with the multiplicative
inverse of <A>b</A>.
<P/>
<Index Subkey="rationals">mod</Index>
<C><A>a</A> mod <A>b</A></C>, for integer or rational left operand <A>a</A> and for non-zero
integer right operand <A>b</A>, is defined as follows.
If <A>a</A> and <A>b</A> are both integers, <C><A>a</A> mod <A>b</A></C> is the integer <A>r</A> in the
integer range <C>0 .. |<A>b</A>| - 1</C> satisfying <C><A>a</A> = <A>r</A> + <A>b</A><A>q</A></C>,
for some integer <A>q</A> (where the operations occurring have their usual meaning
over the integers, of course).
<P/>
<Index>modular remainder</Index><Index>modular inverse</Index>
<Index>coprime</Index><Index>relatively prime</Index>
If <A>a</A> is a rational number and <A>b</A> is a non-zero integer,
and <C><A>a</A> = <A>m</A> / <A>n</A></C> where <A>m</A> and <A>n</A> are
coprime integers  with  <A>n</A>  positive,  then
<C><A>a</A> mod <A>b</A></C> is the integer <A>r</A> in the integer range
<C>0 .. |<A>b</A>| - 1</C>
such that <A>m</A> is congruent to <C><A>r</A><A>n</A></C> modulo <A>b</A>,
and <A>r</A> is called the
<Q>modular remainder</Q> of <A>a</A> modulo <A>b</A>.
Also,  <C>1  /  <A>n</A>  mod  <A>b</A></C>  is
called the <Q>modular inverse</Q> of <A>n</A> modulo <A>b</A>.
(A pair of integers is said to be <E>coprime</E> (or <E>relatively prime</E>)
if their greatest common divisor is 1.)
<P/>
With the above definition, <C>4 / 6 mod 32</C> equals <C>2 / 3 mod 32</C>
and hence exists (and is equal to 22),
despite the fact that 6 has no inverse modulo 32.
<P/>
<E>Note:</E>
For rational <A>a</A>, <C><A>a</A> mod <A>b</A></C> could have been defined
to be the non-negative rational <A>c</A> less than <C>|<A>b</A>|</C>
such that <C><A>a</A> - <A>c</A></C> is a multiple of <A>b</A>.
However this definition is seldom useful and <E>not</E> the
one chosen for &GAP;.
<P/>
<C>+</C> and <C>-</C> can also be used as unary operations.
The unary <C>+</C> is ignored. The unary <C>-</C> returns the additive inverse of
its operand; over the integers it is equivalent to multiplication by <C>-1</C>.
<P/>
<C>^</C> denotes powering of a multiplicative element if the right operand  is
an integer, and is also used to denote the action of a group element on a
point of a set if the right operand is a group element.
<P/>
<Index Subkey="precedence">arithmetic operators</Index>
The <E>precedence</E> of those operators is as follows.
The powering operator <C>^</C> has the highest precedence,
followed by the unary operators <C>+</C> and <C>-</C>,
which are followed by the multiplicative operators <C>*</C>, <C>/</C>, and
<K>mod</K>,
and the additive binary operators <C>+</C> and <C>-</C> have the lowest
precedence.
That means that the expression <C>-2 ^ -2 * 3 + 1</C> is
interpreted as <C>(-(2 ^ (-2)) * 3) + 1</C>. If in doubt use parentheses
to clarify your intention.
<P/>
<Index Subkey="associativity">operators</Index>
The <E>associativity</E> of the arithmetic operators is as follows.
<C>^</C> is not associative, i.e., it is invalid to write <C>2^3^4</C>,
use parentheses to clarify whether you mean <C>(2^3)^4</C> or <C>2^(3^4)</C>.
The unary operators <C>+</C> and <C>-</C> are right associative,
because they are written to the left of their operands.
<C>*</C>, <C>/</C>, <K>mod</K>, <C>+</C>, and <C>-</C> are all left
associative,
i.e., <C>1-2-3</C> is interpreted as <C>(1-2)-3</C> not as <C>1-(2-3)</C>.
Again, if in doubt use parentheses to clarify your intentions.
<P/>
The arithmetic operators have higher precedence than the comparison
operators (see&nbsp;<Ref Sect="Comparisons"/>
and&nbsp;<Ref Sect="Membership Test for Collections"/>)
and the logical operators (see <Ref Sect="Operations for Booleans"/>).
Thus, for example,
<C><A>a</A> * <A>b</A> = <A>c</A> and <A>d</A></C> is interpreted,
<C>((<A>a</A> * <A>b</A>) = <A>c</A>) and <A>d</A></C>.
<P/>
<Example><![CDATA[
gap> 2 * 2 + 9;  # a very simple arithmetic expression
13
]]></Example>
<P/>
For other arithmetic operations, and for the underlying operations of
the operators introduced above,
see&nbsp;<Ref Sect="Arithmetic Operations for Elements"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Statements">
<Heading>Statements</Heading>

<Index>execution</Index>
Assignments (see <Ref Sect="Assignments"/>),
Procedure calls (see <Ref Sect="Procedure Calls"/>),
<K>if</K> statements (see <Ref Sect="If"/>),
<K>while</K> (see <Ref Sect="While"/>),
<K>repeat</K> (see <Ref Sect="Repeat"/>) and
<K>for</K> loops (see <Ref Sect="For"/>),
and the <K>return</K> statement
(see <Ref Sect="Return (With or without Value)"/>)
are called <E>statements</E>.
They can be entered interactively or be part of a function definition.
Every statement must be terminated by a semicolon.
<P/>
Statements, unlike expressions, have no value. They are executed only to
produce an effect. For example an assignment has the effect of assigning
a  value to a variable, a <K>for</K> loop  has the effect of executing a
statement sequence for all elements in a list and so on.
We will talk about <E>evaluation</E> of expressions
but about <E>execution</E> of statements to emphasize this difference.
<P/>
Using expressions as statements is treated as syntax error.
<P/>
<Log><![CDATA[
gap> i := 7;;
gap> if i <> 0 then k = 16/i; fi;
Syntax error: := expected
if i <> 0 then k = 16/i; fi;
                 ^
gap> 
]]></Log>
<P/>
As you can see from the example this warning does in particular address
those users who are used to languages where <C>=</C> instead of <C>:=</C>
denotes assignment.
<P/>
Empty statements are permitted and have no effect.
<P/>
A sequence of one or more statements is a <E>statement sequence</E>, and may
occur everywhere instead of a single statement.
Each construct is terminated by a keyword.
The simplest statement sequence is a single semicolon, which can be
used as an empty statement sequence. In fact an empty statement
sequence as in <C>for i in [ 1 .. 2 ] do od</C> is also permitted and is
silently translated into the sequence containing just a semicolon.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Assignments">
<Heading>Assignments</Heading>

<Index Subkey="variable">assignment</Index>
<C><A>var</A> := <A>expr</A>;</C>
<P/>
The <E>assignment</E> has the effect of assigning the value of the expressions
<A>expr</A> to the variable <A>var</A>.
<P/>
The variable <A>var</A> may be an ordinary variable
(see <Ref Sect="Variables"/>),
a list element selection <C><A>list-var</A>[<A>int-expr</A>]</C>
(see <Ref Sect="List Assignment"/>) or a record component selection
<C><A>record-var</A>.<A>ident</A></C> (see <Ref Sect="Record Assignment"/>).
Since a list element or a record component may itself be a
list or a record the left hand side of an assignment may be arbitrarily
complex.
<P/>
Note that variables do not have a type. Thus any value may be assigned
to any variable.  For example a variable with an integer value may be
assigned a permutation or a list or anything else.
<P/>
<Example><![CDATA[
gap> data:= rec( numbers:= [ 1, 2, 3 ] );
rec( numbers := [ 1, 2, 3 ] )
gap> data.string:= "string";; data;
rec( numbers := [ 1, 2, 3 ], string := "string" )
gap> data.numbers[2]:= 4;; data;
rec( numbers := [ 1, 4, 3 ], string := "string" )
]]></Example>
<P/>
If the expression <A>expr</A> is a function call then this function must
return a value.  If the function does not return a value an error is
signalled and you enter a break loop (see <Ref Sect="Break Loops"/>).
As usual you can leave the break  loop  with <C>quit;</C>.
If you enter <C>return <A>return-expr</A>;</C> the value of the expression
<A>return-expr</A> is assigned to the variable,
and execution continues after the assignment.
<P/>
<Log><![CDATA[
gap> f1:= function( x ) Print( "value: ", x, "\n" ); end;;
gap> f2:= function( x ) return f1( x ); end;;
gap> f2( 4 );
value: 4
Function Calls: <func> must return a value at
return f1( x );
 called from
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can supply one by 'return <value>;' to continue
brk> return "hello";
"hello"
]]></Log>
<P/>
In the above example, the function <C>f2</C> calls <C>f1</C> with argument
<C>4</C>,
and since <C>f1</C> does not return a value (but only prints a line
<Q><C>value: ...</C></Q>),
the <K>return</K> statement of <C>f2</C> cannot be executed.
The error message says that it is possible to return an appropriate value,
and the returned string <C>"hello"</C> is used by <C>f2</C> instead of the
missing return value of <C>f1</C>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Procedure Calls">
<Heading>Procedure Calls</Heading>

<Index>procedure call</Index>
<Index>procedure call with arguments</Index>
<C><A>procedure-var</A>( [<A>arg-expr</A> [,<A>arg-expr</A>, ...]] );</C>
<P/>
The <E>procedure call</E> has  the  effect  of calling  the procedure
<A>procedure-var</A>.  A procedure call is done exactly like a function call
(see <Ref Sect="Function Calls"/>).
The distinction between functions and procedures is only for the sake of the
discussion, &GAP; does not distinguish between them.
So we state the following conventions.
<P/>
A <E>function</E> does return a value but does not produce a side effect. As
a convention the name of a function is a noun, denoting what the function
returns, e.g., <C>"Length"</C>, <C>"Concatenation"</C> and <C>"Order"</C>.
<P/>
A <E>procedure</E> is a function that does not return a value but produces
some  effect. Procedures are called  only for  this effect. As  a
convention the name of a procedure is a verb, denoting what the procedure
does, e.g., <C>"Print"</C>, <C>"Append"</C> and <C>"Sort"</C>.
<P/>
<Log><![CDATA[
gap> Read( "myfile.g" );   # a call to the procedure Read
gap> l := [ 1, 2 ];;
gap> Append( l, [3,4,5] );  # a call to the procedure Append
]]></Log>
<P/>
There are a few exceptions of &GAP; functions that do both return
a value and produce some effect.
An example is <Ref Func="Sortex"/> which sorts a list
and returns the corresponding permutation of the entries.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="If">
<Heading>If</Heading>

<Index Key="fi"><K>fi</K></Index>
<Index Key="then"><K>then</K></Index>
<Index Key="else"><K>else</K></Index>
<Index Key="elif"><K>elif</K></Index>
<C>if <A>bool-expr1</A> then <A>statements1</A> { elif <A>bool-expr2</A> then <A>statements2</A> }[ else <A>statements3</A> ] fi;</C>
<Index Key="if statement"><K>if</K> statement</Index>
<P/>
The <K>if</K> statement allows one to execute statements depending on the
value of some boolean expression. The execution is done as follows.
<P/>
First the expression <A>bool-expr1</A> following the <K>if</K> is evaluated.
If it evaluates to <K>true</K> the statement sequence <A>statements1</A>
after the first <K>then</K> is executed,
and the execution of the <K>if</K> statement is complete.
<P/>
Otherwise the expressions <A>bool-expr2</A> following the <K>elif</K> are
evaluated in turn.
There may be any number of <K>elif</K> parts, possibly none at all.
As soon as an expression evaluates to <K>true</K> the corresponding statement
sequence <A>statements2</A> is executed and execution of the <K>if</K>
statement is complete.
<P/>
If the <K>if</K> expression and all, if any, <K>elif</K> expressions evaluate
to <K>false</K> and there is an <K>else</K> part, which is optional,
its statement sequence <A>statements3</A> is executed and the execution of
the <K>if</K> statement is complete.
If there is no <K>else</K> part the <K>if</K> statement is complete without
executing any statement sequence.
<P/>
Since the <K>if</K> statement is terminated by the <K>fi</K> keyword
there is no question where an <K>else</K> part belongs,
i.e., &GAP; has no <Q>dangling else</Q>.
In
<P/>
<Listing><![CDATA[
if expr1 then if expr2 then stats1 else stats2 fi; fi;
]]></Listing>
<P/>
the <K>else</K> part belongs to the second  <K>if</K> statement, whereas in
<P/>
<Listing><![CDATA[
if expr1 then if expr2 then stats1 fi; else stats2 fi;
]]></Listing>
<P/>
the <K>else</K> part belongs to the first <K>if</K> statement.
<P/>
Since an <K>if</K> statement is not an expression it is not possible to write
<P/>
<Listing><![CDATA[
abs := if x > 0 then x; else -x; fi;
]]></Listing>
<P/>
which would, even if legal syntax, be  meaningless, since the <K>if</K>
statement does not produce a value that could be assigned to <C>abs</C>.
<P/>
If one of the expressions <A>bool-expr1</A>, <A>bool-expr2</A> is evaluated
and its value is neither <K>true</K> nor <K>false</K> an error is signalled
and a break loop (see <Ref Sect="Break Loops"/>) is entered.
As usual you can leave  the break loop with <C>quit;</C>.
If you enter <C>return true;</C>,
execution of the <K>if</K> statement continues as if the expression whose
evaluation  failed had evaluated to <K>true</K>.
Likewise, if you enter <C>return false;</C>,
execution of the <K>if</K> statement continues as if the expression
whose evaluation failed had evaluated to <K>false</K>.
<P/>
<Example><![CDATA[
gap> i := 10;;
gap> if 0 < i then
>    s := 1;
>  elif i < 0 then
>    s := -1;
>  else
>    s := 0;
>  fi;
gap> s;  # the sign of i
1
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="While">
<Heading>While</Heading>

<Index Subkey="while">loop</Index>
<Index Key="while loop"><K>while</K> loop</Index>
<C>while <A>bool-expr</A> do <A>statements</A> od;</C>
<P/>
The <K>while</K> loop executes the statement sequence <A>statements</A> while
the condition <A>bool-expr</A> evaluates to <K>true</K>.
<P/>
First <A>bool-expr</A> is evaluated.
If it evaluates to <K>false</K> execution of the <K>while</K> loop terminates
and the statement immediately following the <K>while</K> loop is executed
next.
Otherwise if it evaluates to <K>true</K> the
<A>statements</A> are executed and the whole process begins again.
<P/>
The difference between the <K>while</K> loop
and the <K>repeat</K> <K>until</K> loop (see <Ref Sect="Repeat"/>)
is that the <A>statements</A> in the <K>repeat</K> <K>until</K> loop are
executed at least once, while the <A>statements</A> in the <K>while</K> loop
are not executed at all if <A>bool-expr</A> is <K>false</K> at the first
iteration.
<P/>
If <A>bool-expr</A> does not evaluate to <K>true</K> or <K>false</K> an error
is signalled and a break loop (see <Ref Sect="Break Loops"/>) is entered.
As usual you can leave the break loop with <C>quit;</C>.
If you enter <C>return false;</C>,
execution continues with the next statement immediately following the
<K>while</K> loop.
If you enter <C>return true;</C>, execution continues at <A>statements</A>,
after which the next evaluation of <A>bool-expr</A> may cause another error.
<P/>
The following example shows a <K>while</K> loop that sums up the squares
<M>1^2, 2^2, \ldots</M> until the sum exceeds <M>200</M>.
<P/>
<Example><![CDATA[
gap> i := 0;; s := 0;;
gap> while s <= 200 do
>    i := i + 1; s := s + i^2;
>  od;
gap> s;
204
]]></Example>
<P/>
A <K>while</K> loop may be left prematurely using <K>break</K>,
see <Ref Sect="Break"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Repeat">
<Heading>Repeat</Heading>

<Index Subkey="repeat">loop</Index>
<Index Key="until"><K>until</K></Index>
<Index Key="repeat loop"><K>repeat</K> loop</Index>
<C>repeat <A>statements</A> until <A>bool-expr</A>;</C>
<P/>
The <K>repeat</K> loop executes the statement sequence <A>statements</A>
until the condition <A>bool-expr</A> evaluates to <K>true</K>.
<P/>
First <A>statements</A> are executed.
Then <A>bool-expr</A> is evaluated.
If it evaluates to <K>true</K> the <K>repeat</K> loop terminates
and the statement immediately following the <K>repeat</K> loop is executed
next.
Otherwise if it evaluates to <K>false</K> the whole process begins again
with the execution of the <A>statements</A>.
<P/>
The difference between the <K>while</K> loop (see <Ref Sect="While"/>)
and the <K>repeat</K> <K>until</K> loop is that the <A>statements</A>
in the <K>repeat</K> <K>until</K> loop are executed at least once,
while the <A>statements</A> in the <K>while</K> loop are not executed at all
if <A>bool-expr</A> is <K>false</K> at the first iteration.
<P/>
If <A>bool-expr</A> does not evaluate to <K>true</K> or <K>false</K>
an error is signalled and a break loop (see <Ref Sect="Break Loops"/>)
is entered.
As usual you can leave the break loop with <C>quit;</C>.
If you enter <C>return true;</C>,
execution continues with the next statement immediately following the
<K>repeat</K> loop.
If you enter <C>return false;</C>, execution continues at <A>statements</A>,
after which the next evaluation of <A>bool-expr</A> may cause another error.
<P/>
The <K>repeat</K> loop in the following example has the same purpose as the
<K>while</K> loop in the preceding example, namely to sum up the squares
<M>1^2, 2^2, \ldots</M> until the sum exceeds <M>200</M>.
<P/>
<Example><![CDATA[
gap> i := 0;; s := 0;;
gap> repeat
>    i := i + 1; s := s + i^2;
>  until s > 200;
gap> s;
204
]]></Example>
<P/>
A <K>repeat</K> loop may be left prematurely using <K>break</K>,
see <Ref Sect="Break"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="For">
<Heading>For</Heading>

<Index Subkey="for">loop</Index>
<Index Key="do"><K>do</K></Index>
<Index Key="od"><K>od</K></Index>
<C>for <A>simple-var</A> in <A>list-expr</A> do <A>statements</A> od;</C>
<Index Key="for loop"><K>for</K> loop</Index>
<P/>
The <K>for</K> loop executes the statement sequence <A>statements</A> for
every element of the list <A>list-expr</A>.
<P/>
The statement sequence <A>statements</A> is first executed with
<A>simple-var</A> bound to the first element of the list <A>list-expr</A>,
then with <A>simple-var</A> bound to the second element of <A>list-expr</A>
and so on.
<A>simple-var</A> must be a simple variable, it must not be a list element
selection <C><A>list-var</A>[<A>int-expr</A>]</C>
or a record component selection <C><A>record-var</A>.<A>ident</A></C>.
<P/>
The execution of the <K>for</K> loop over a list is exactly equivalent to
the following <K>while</K> loop.
<P/>
<Listing><![CDATA[
loop_list := list;
loop_index := 1;
while loop_index <= Length(loop_list) do
  variable := loop_list[loop_index];
  statements
  loop_index := loop_index + 1;
od;
]]></Listing>
<P/>
with the  exception  that <Q>loop_list</Q> and <Q>loop_index</Q> are different
variables for each <K>for</K> loop,
i.e., these variables of different <K>for</K> loops do not interfere with
each other.
<P/>
The list <A>list-expr</A> is very often a range (see&nbsp;<Ref Sect="Ranges"/>).
<P/>
<P/>
<Index>loop over range</Index>
<C>for <A>variable</A> in [<A>from</A>..<A>to</A>] do <A>statements</A> od;</C>
<P/>
corresponds to the more common
<P/>
<C>for <A>variable</A> from <A>from</A> to <A>to</A> do <A>statements</A> od;</C>
<P/>
in other programming languages.
<P/>
<Example><![CDATA[
gap> s := 0;;
gap> for i in [1..100] do
>    s := s + i;
> od;
gap> s;
5050
]]></Example>
<P/>
Note in the following example how the modification of the <E>list</E> in the
loop body causes the loop body also to be executed for the new values.
<P/>
<Example><![CDATA[
gap> l := [ 1, 2, 3, 4, 5, 6 ];;
gap> for i in l do
>    Print( i, " " );
>    if i mod 2 = 0 then Add( l, 3 * i / 2 ); fi;
> od; Print( "\n" );
1 2 3 4 5 6 3 6 9 9 
gap> l;
[ 1, 2, 3, 4, 5, 6, 3, 6, 9, 9 ]
]]></Example>
<P/>
Note in the following example that the modification of the <E>variable</E>
that holds the list has no influence on the loop.
<P/>
<Example><![CDATA[
gap> l := [ 1, 2, 3, 4, 5, 6 ];;
gap> for i in l do
>    Print( i, " " );
>    l := [];
> od; Print( "\n" );
1 2 3 4 5 6 
gap> l;
[  ]
]]></Example>
<P/>
<Index>loop over iterator</Index>
<C>for <A>variable</A> in <A>iterator</A> do <A>statements</A> od;</C>
<P/>
It is also possible to have a <K>for</K>-loop run over an iterator
(see&nbsp;<Ref Sect="Iterators"/>). In this case
the <K>for</K>-loop is equivalent to
<P/>
<Listing><![CDATA[
while not IsDoneIterator(iterator) do
  variable := NextIterator(iterator)
  statements
od;
]]></Listing>
<P/>
<Index>loop over object</Index>
<C>for <A>variable</A> in <A>object</A> do <A>statements</A> od;</C>
<P/>
Finally, if an object <A>object</A> which is not a list or an iterator appears in a
<K>for</K>-loop, then &GAP; will attempt to evaluate the function call
<C>Iterator(<A>object</A>)</C>. If this is successful then the loop is taken to
run over the iterator returned.
<P/>
<Example><![CDATA[
gap> g := Group((1,2,3,4,5),(1,2)(3,4)(5,6));
Group([ (1,2,3,4,5), (1,2)(3,4)(5,6) ])
gap> count := 0;; sumord := 0;;
gap> for x in g do
> count := count + 1; sumord := sumord + Order(x); od;
gap> count;
120
gap> sumord;
471
]]></Example>
<P/>
The effect of
<P/>
<C>for <A>variable</A> in <A>domain</A> do</C>
<P/>
should thus normally be the same as 
<P/>
<C>for <A>variable</A> in AsList(<A>domain</A>) do</C>
<P/>
but may use much less storage, as the iterator may be more compact than
a list of all the elements.
<P/>
See <Ref Sect="Iterators"/> for details about iterators.
<P/>
A <K>for</K> loop may be left prematurely using <K>break</K>,
see <Ref Sect="Break"/>. This
combines especially well with a loop over an iterator, as a way of
searching through a domain for an element with some useful property.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Break">
<Heading>Break</Heading>

<Index Subkey="leaving">loops</Index>
<C>break;</C>
<Index Key="break statement"><K>break</K> statement</Index>
<P/>
The statement <C>break;</C> causes an immediate exit from the innermost
loop enclosing it.
<P/>
<Example><![CDATA[
gap> g := Group((1,2,3,4,5),(1,2)(3,4)(5,6));
Group([ (1,2,3,4,5), (1,2)(3,4)(5,6) ])
gap> for x in g do
> if Order(x) = 3 then
> break;
> fi; od;
gap> x;
(1,5,2)(3,4,6)
]]></Example>
<P/>
It is an error to use this statement other than inside a loop.
<P/>
<Log><![CDATA[
gap> break;
Error, A break statement can only appear inside a loop
not in any function
]]></Log>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Continue">
<Heading>Continue</Heading>

<Index Subkey="restarting">loops</Index>
<C>continue;</C>
<Index Key="continue statement"><K>continue</K> statement</Index>
<P/>
The statement <C>continue;</C> causes the rest of the current iteration of
the innermost loop enclosing it to be skipped.
<P/>
<Example><![CDATA[
gap> g := Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> for x in g do
> if Order(x) = 3 then
> continue;
> fi; Print(x,"\n"); od;
()
(2,3)
(1,3)
(1,2)
]]></Example>
<P/>
It is an error to use this statement other than inside a loop.
<P/>
<Log><![CDATA[
gap> continue;
Error, A continue statement can only appear inside a loop
not in any function
]]></Log>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Function">
<Heading>Function</Heading>

<Index Subkey="definition of">functions</Index>
<Index Key="end"><K>end</K></Index>
<Index Key="local"><K>local</K></Index>
<Index>recursion</Index>
<Index Subkey="recursive">functions</Index>
<Index>environment</Index><Index>body</Index>
<C>function( [ <A>arg-ident</A> {, <A>arg-ident</A>} ] )</C>
<P/>
<C>&nbsp;&nbsp;[local  <A>loc-ident</A> {, <A>loc-ident</A>} ; ]</C>
<P/>
<C>&nbsp;&nbsp;<A>statements</A></C>
<P/>
<C>end</C>
<P/>
A function is in fact a literal and not a statement. Such a function
literal can be assigned to a variable or to a list element or a record
component.
Later this function can be called as described in <Ref Sect="Function Calls"/>.
<P/>
The following is an example of a function definition.  It is a function
to compute values of the Fibonacci sequence (see <Ref Func="Fibonacci"/>).
<P/>
<Example><![CDATA[
gap> fib := function ( n )
>     local f1, f2, f3, i;
>     f1 := 1; f2 := 1;
>     for i in [3..n] do
>       f3 := f1 + f2;
>       f1 := f2;
>       f2 := f3;
>     od;
>     return f2;
>   end;;
gap> List( [1..10], fib );
[ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
]]></Example>
<P/>
Because for each of the formal arguments <A>arg-ident</A> and for each of the
formal locals <A>loc-ident</A> a new variable is allocated when the function
is called (see <Ref Sect="Function Calls"/>),
it is possible that a function calls itself.
This is usually called <E>recursion</E>.
The following is a recursive function that computes values of the Fibonacci
sequence.
<P/>
<Example><![CDATA[
gap> fib := function ( n )
>     if n < 3 then
>       return 1;
>     else
>       return fib(n-1) + fib(n-2);
>     fi;
>   end;;
gap> List( [1..10], fib );
[ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
]]></Example>
<P/>
Note that the recursive version needs <C>2 * fib(<A>n</A>)-1</C> steps
to compute <C>fib(<A>n</A>)</C>,
while the iterative version of <C>fib</C> needs only <C><A>n</A>-2</C> steps.
Both are not optimal however, the library function <Ref Func="Fibonacci"/>
only needs about <C>Log(<A>n</A>)</C> steps.
<P/>
<Index Subkey="with a variable number of arguments">functions</Index>
<Index Key="arg" Subkey="special function argument"><C>arg</C></Index>
As noted in Section&nbsp;<Ref Sect="Function Calls"/>,
the case where a function's last argument is followed by <C>...</C> is special.
It provides a way of defining  a  function  with  a  variable  number  of
arguments. The values of the actual arguments are computed and the
first ones are assigned to the new variables corresponding to the
formal arguments before the last argument, if any. The values of all the
remaining actual arguments are stored  in  a  list
and this list is assigned to the new variable corresponding to the final formal
argument. There are  two  typical  scenarios  for  wanting  such  a
possibility:  having  optional  arguments  and  having  any   number   of
arguments.
<P/>
The  following  example  shows  one  way  that  the  function
<Ref Func="Position"/> might be encoded  and  demonstrates  the
<Q>optional argument</Q> scenario.
<P/>
<Example><![CDATA[
gap> position := function ( list, obj, arg... )    
>     local pos;
>     if 0 = Length(arg) then
>       pos := 0;
>     else
>       pos := arg[1];
>     fi;
>     repeat
>       pos := pos + 1;
>       if pos > Length(list) then
>         return fail;
>       fi;
>     until list[pos] = obj;
>     return pos;
>    end;
function( list, obj, arg... ) ... end
gap> position([1, 4, 2], 4);
2
gap> position([1, 4, 2], 3);
fail
gap> position([1, 4, 2], 4, 2);
fail
]]></Example>
<P/>
The following  example  demonstrates  the  <Q>any  number  of  arguments</Q>
scenario.
<P/>
<Example><![CDATA[
gap> sum := function ( l... )
>     local total, x;
>     total := 0;
>     for x in l do
>       total := total + x;
>     od;
>     return total;
>    end;
function( l... ) ... end
gap> sum(1, 2, 3);
6
gap> sum(1, 2, 3, 4);
10
gap> sum();
0
]]></Example>
<P/>
The user should compare the above with the  &GAP; function <Ref Func="Sum"/>
which, for example, may take a list argument and optionally
an initial element (which zero should the sum of an empty list return?).
<P/>
GAP will also special case a function with a single argument with the name
<C>arg</C> as function with a variable length list of arguments, as if the
user had written <C>arg...</C>.
<P/>
Note that if a function <A>f</A> is defined as above
then <C>NumberArgumentsFunction(<A>f</A>)</C> returns
minus the number of formal arguments (including the final argument)
(see&nbsp;<Ref Func="NumberArgumentsFunction"/>).
<P/>
Using the <C>...</C> notation on a function <A>f</A> with only a single
named argument tells &GAP; that when it encounters <A>f</A> that it should
form a list out of the arguments of <A>f</A>.
What if one wishes to do the <Q>opposite</Q>:
tell &GAP; that a list should be <Q>unwrapped</Q> and passed as several
arguments to a function.
The function <Ref Func="CallFuncList"/> is provided for this purpose.
<P/>
Also see Chapter&nbsp;<Ref Chap="Functions"/>.
<P/>
<Index Subkey="definition by arrow notation">functions</Index>
<Index>arrow notation for functions</Index>
<C>{ <A>arg-list</A> } -> <A>expr</A></C>
<P/>
This is a shorthand for
<P/>
<C>function ( <A>arg-list</A> ) return <A>expr</A>; end.</C>
<P/>
<A>arg-list</A> is a (possibly empty) argument list. Any arguments list
which would be valid for a normal GAP function is also valid here (including
variadic arguments).
<P/>
The following gives a couple of examples of a typical use of such a function
<P/>
<Example><![CDATA[
gap> Sum( List( [1..100], {x} -> x^2 ) );
338350
gap> list := [3, 5, 2, 1, 3];;
gap> Sort(list, {x,y} -> x > y);
gap> list;
[ 5, 3, 3, 2, 1 ]
gap> f := {x,y...} -> y;;
gap> f(1,2,3,4);
[ 2, 3, 4 ]
gap> f := {} -> 2;
function(  ) ... end
gap> Print(f);
function (  )
    return 2;
end
gap> f();
2
]]></Example>
<P/>
The <C>{</C> and <C>}</C> may be omitted for
functions with one argument:
<Example><![CDATA[
gap> Sum( List( [1..100], {x} -> x^2 ) );
338350
gap> Sum( List( [1..100], x -> x^2 ) );
338350
]]></Example>

<P/>
When the definition of a function <A>fun1</A> is evaluated inside another
function <A>fun2</A>,
&GAP; binds all the identifiers inside the function <A>fun1</A> that
are identifiers of an argument or a local of <A>fun2</A> to the corresponding
variable.
This set of bindings is called the environment of the function <A>fun1</A>.
When <A>fun1</A> is called, its body is executed in this environment.
The following implementation of a simple stack uses this.
Values can be pushed onto the stack and then later be popped off again.
The interesting thing here is that the functions <C>push</C> and <C>pop</C>
in the record returned by <C>Stack</C> access the local variable <C>stack</C>
of <C>Stack</C>.
When <C>Stack</C> is called, a new variable for the identifier <C>stack</C>
is created.
When the function definitions of <C>push</C> and <C>pop</C> are then
evaluated (as part of the <K>return</K> statement) each reference to
<C>stack</C> is bound to this new variable.
Note also that the two stacks <C>A</C> and <C>B</C> do not interfere,
because each call of <C>Stack</C> creates a new variable for <C>stack</C>.
<P/>
<Example><![CDATA[
gap> Stack := function ()
>     local  stack;
>     stack := [];
>     return rec(
>       push := function ( value )
>         Add( stack, value );
>       end,
>       pop := function ()
>         local  value;
>         value := stack[Length(stack)];
>         Unbind( stack[Length(stack)] );
>         return value;
>       end
>     );
>  end;;
gap> A := Stack();;
gap> B := Stack();;
gap> A.push( 1 ); A.push( 2 ); A.push( 3 );
gap> B.push( 4 ); B.push( 5 ); B.push( 6 );
gap> A.pop(); A.pop(); A.pop();
3
2
1
gap> B.pop(); B.pop(); B.pop();
6
5
4
]]></Example>
<P/>
This feature should be used rarely, since its implementation in &GAP; is
not very efficient.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="Return (With or without Value)">
<Heading>Return (With or without Value)</Heading>

<Index Key="return" Subkey="no value"><K>return</K></Index>
<C>return;</C>
<P/>
In this form <K>return</K> terminates the call of the innermost function that
is currently executing, and control returns to the calling function. An
error is signalled if no function is currently executing. No value is
returned by the function.
<P/>
<C>return <A>expr</A>;</C>
<Index Key="return" Subkey="with value"><K>return</K></Index>
<P/>
In this form <K>return</K> terminates the call of the innermost function that
is currently executing, and returns the value of the expression <A>expr</A>.
Control returns to the calling function. An error is signalled if no
function is currently executing.
<P/>
Both statements can also be used in break loops
(see <Ref Sect="Break Loops"/>).
<C>return;</C> has the effect that the computation continues where it was
interrupted by an error or the user hitting <B>Ctrl-C</B>.
<C>return <A>expr</A>;</C> can be used to continue execution after an error.
What happens with the value <A>expr</A> depends on the particular error.
<P/>
For examples of <K>return</K> statements, see the functions <C>fib</C> and
<C>Stack</C> in Section&nbsp;<Ref Sect="Function"/>.

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!--
<Section Label="The Syntax in BNF">
<Heading>The Syntax in BNF</Heading>

<Index>BNF</Index>
This section contains the definition of the &GAP; syntax in
Backus-Naur form. A few recent additions to the syntax may be missing
from this definition. Also, the actual rules for identifier names
implemented by the system, are somewhat more permissive than those
given below (see section <Ref Sect="Identifiers"/>).
<P/>
A  BNF is a set of rules, whose left side  is the name of  a  syntactical
construct.  Those  names  are written using <A>this font</A>.
The right side of each rule contains a possible form for that
syntactic  construct.   Each  right  side  may  contain  names  of  other
syntactic  constructs,  again  enclosed in angle brackets and written  in
<A>italics</A>,  or character  sequences that  must  occur literally; they are
written in <C>this font</C>.
<P/>
Furthermore  each right hand side  can contain  the  following metasymbols.
If the right  hand  side contains forms separated
by a pipe symbol  (<M>|</M>)  this means  that one  of the possible forms can
occur.  If a part of a form  is enclosed  in square brackets  (<C>[]</C>)  this
means that this part is optional, i.e.  might be present or  missing.  If
part  of the form is enclosed  in curly braces  (<C>{}</C>)  this means that
the part may occur arbitrarily often, or possibly be missing.
<P/>
<Table Align="lll">
<Row>
  <Item><A>Ident</A></Item>
  <Item>:=</Item>
  <Item><C>a</C><M>|\ldots|</M><C>z</C><M>|</M>
        <C>A</C><M>|\ldots|</M><C>Z</C><M>|</M>
        <C>_</C>
        <C>{a</C><M>|\ldots|</M><C>z</C><M>|</M>
                <C>A</C><M>|\ldots|</M><C>Z</C><M>|</M>
                <C>0</C><M>|\ldots|</M><C>9</C><M>|</M>
                <C>_}</C></Item>
</Row>
<Row>
  <Item><A>Var</A></Item>
  <Item>:=</Item>
  <Item><A>Ident</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>.</C> <A>Ident</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>. (</C> <A>Expr</A> <C>)</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>[</C> <A>Expr</A> <C>]</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>{</C> <A>Expr</A> <C>}</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>(</C> [ <A>Expr</A> <C>{,</C> <A>Expr</A> <C>} ] )</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>!.</C> <A>Ident</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>!. (</C> <A>Expr</A> <C>)</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>![</C> <A>Expr</A> <C>]</C></Item>
</Row>
<Row>
  <Item><A>List</A></Item>
  <Item>:=</Item>
  <Item><C>[</C> [ <A>Expr</A> ] <C>{,</C> [ <A>Expr</A> ] <C>} ]</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><C>[</C> <A>Expr</A> [<C>,</C> <A>Expr</A> ] <C>..</C> <A>Expr</A> <C>]</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>List</A> <C>{</C> <A>List</A> <C>}</C></Item>
</Row>
<Row>
  <Item><A>Record</A></Item>
  <Item>:=</Item>
  <Item><C>rec(</C> [ <A>Ident</A> <C>:=</C> <A>Expr</A>
                         <C>{,</C> <A>Ident</A> <C>:=</C> <A>Expr</A> <C>} ] )</C></Item>
</Row>
<Row>
  <Item><A>Permutation</A></Item>
  <Item>:=</Item>
  <Item><C>(</C> <A>Expr</A> <C>{,</C> <A>Expr</A> <C>} )</C>
                    <C>{ (</C> <A>Expr</A> <C>{,</C> <A>Expr</A> <C>} ) }</C></Item>
</Row>
<Row>
  <Item><A>Function</A></Item>
  <Item>:=</Item>
  <Item><C>function (</C> [ <A>Ident</A> <C>{,</C> <A>Ident</A> <C>} ] )</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item>[ <K>local</K> <A>Ident</A> <C>{,</C> <A>Ident</A> <C>} ;</C> ]</Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item><A>Statements</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item><K>end</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Ident</A> <C>-></C> <A>Expr</A></Item>
</Row>
<Row>
  <Item><A>Char</A></Item>
  <Item>:=</Item>
  <Item><C>'<A>any character</A>'</C></Item>
</Row>
<Row>
  <Item><A>String</A></Item>
  <Item>:=</Item>
  <Item><C>" {</C> <A>any character</A> <C>} "</C></Item>
</Row>
<Row>
  <Item><A>Int</A></Item>
  <Item>:=</Item>
  <Item><C>0</C><M>|</M><C>1</C><M>|</M>...<M>|</M><C>9</C>
        <C>{0</C><M>|</M><C>1</C><M>|</M>...<M>|</M><C>9}</C></Item>
</Row>
<Row>
  <Item><A>Atom</A></Item>
  <Item>:=</Item>
  <Item><A>Int</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><C>(</C> <A>Expr</A> <C>)</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Permutation</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Char</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>String</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Function</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>List</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Record</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><C>{</C> <K>not</K> <C>}</C> <K>true</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><C>{</C> <K>not</K> <C>}</C> <K>false</K></Item>
</Row>
<Row>
  <Item><A>Factor</A></Item>
  <Item>:=</Item>
  <Item><C>{+</C><M>|</M><C>-}</C> <A>Atom</A>
                [ <C>^ {+</C><M>|</M><C>-}</C> <A>Atom</A> ]</Item>
</Row>
<Row>
  <Item><A>Term</A></Item>
  <Item>:=</Item>
  <Item><A>Factor</A> <C>{ *</C><M>|</M><C>/</C><M>|</M><K>mod</K> <A>Factor</A> <C>}</C></Item>
</Row>
<Row>
  <Item><A>Arith</A></Item>
  <Item>:=</Item>
  <Item><A>Term</A> <C>{ +</C><M>|</M><C>-</C> <A>Term</A> <C>}</C></Item>
</Row>
<Row>
  <Item><A>Rel</A></Item>
  <Item>:=</Item>
  <Item><C>{</C> <K>not</K> <C>}</C> <A>Arith</A>
                [ <C>=</C><M>|</M><C>&lt;></C><M>|</M><C>&lt;</C><M>|</M><C>></C><M>|</M><C>&lt;=</C><M>|</M><C>>=</C><M>|</M><K>in</K> <A>Arith</A> ]</Item>
</Row>
<Row>
  <Item><A>And</A></Item>
  <Item>:=</Item>
  <Item><A>Rel</A> <C>{</C> <K>and</K> <A>Rel</A> <C>}</C></Item>
</Row>
<Row>
  <Item><A>Logical</A></Item>
  <Item>:=</Item>
  <Item><A>And</A> <C>{</C> <K>or</K> <A>And</A> <C>}</C></Item>
</Row>
<Row>
  <Item><A>Expr</A></Item>
  <Item>:=</Item>
  <Item><A>Logical</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A></Item>
</Row>
<Row>
  <Item><A>Statement</A></Item>
  <Item>:=</Item>
  <Item><A>Expr</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><A>Var</A> <C>:=</C> <A>Expr</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>if</K> <A>Expr</A> <K>then</K> <A>Statements</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item><C>{</C> <K>elif</K> <A>Expr</A> <K>then</K> <A>Statements</A> <C>}</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item></Item>
  <Item>[ <K>else</K> <A>Statements</A> ] <K>fi</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>for</K> <A>Var</A> <K>in</K> <A>Expr</A> <K>do</K> <A>Statements</A> <K>od</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>while</K> <A>Expr</A> <K>do</K> <A>Statements</A> <K>od</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>repeat</K> <A>Statements</A> <K>until</K> <A>Expr</A></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>return</K> [ <A>Expr</A> ]</Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>break</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>quit</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><K>QUIT</K></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item></Item>
</Row>
<Row>
  <Item><A>Statements</A></Item>
  <Item>:=</Item>
  <Item><C>{</C> <A>Statement</A> <C>; }</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item><C>;</C></Item>
</Row>
<Row>
  <Item></Item>
  <Item><M>|</M></Item>
  <Item></Item>
</Row>
</Table>

</Section>
-->
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %% -->
<!-- %E -->
